CI/CD‚Äëpipeline








h√§r kommer en komplett, hands‚Äëon plan f√∂r din CI/CD‚Äëpipeline (GitHub Actions) med Docker, GHCR, staging/prod‚Äëdeploy, canary‚Äëpreview, nattliga regressionstester och s√§kerhetsartefakter (SBOM + cosign).
Uppl√§gget f√∂ljer din stil: f√∂rst enkel f√∂rklaring, sedan exakta kommandon, vad som h√§nder och hur du verifierar ‚Äî och vi visar hela filinneh√•llet f√∂r alla nya filer.

üéØ M√•l

K√∂r allt lokalt i Docker.

Bygg/testrunner i CI.

Push av images till GHCR.

Automatisk deploy till staging p√• push till main.

Canary/preview per PR.

Nightly selector‚Äëregression mot syntetiska testsajter.

SBOM och cosign signering/validering.

Responsivt och s√§kert fl√∂de med sp√§rr mot parallella deployer.

0) F√∂ruts√§ttningar

Enkel f√∂rklaring
Vi beh√∂ver ett GitHub‚Äërepo med GitHub Actions aktiverat, Docker installerat d√§r vi k√∂r lokalt, och ett containerregister (GHCR). P√• din staging/production‚Äëserver k√∂r Docker + Docker Compose. Vi l√§gger in hemligheter som GitHub Secrets.

Kommandon

Windows (PowerShell) ‚Äì lokalt:

# kontrollera docker lokalt
docker --version
docker compose version


macOS/Linux:

docker --version
docker compose version


Vad h√§nder & verifiering
Du ser versionsnummer. Om inte: installera Docker Desktop (Win/macOS) eller Docker Engine + Compose (Linux).

1) Register & Secrets

Enkel f√∂rklaring
Vi trycker images till GHCR. Actions loggar in med GITHUB_TOKEN. F√∂r deploy via SSH till servern anv√§nder vi nyckel.

Kommandon
Inga lokala kommandon h√§r ‚Äî vi l√§gger secrets i GitHub UI:

GitHub ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí New repository secret och skapa:

SSH_HOST_STAGING ‚Äì t.ex. staging.example.com

SSH_USER_STAGING ‚Äì t.ex. ubuntu

SSH_PRIVATE_KEY_STAGING ‚Äì din privata nyckel (PEM) endast f√∂r denna server

(valfritt prod) SSH_HOST_PROD, SSH_USER_PROD, SSH_PRIVATE_KEY_PROD

COMPOSE_DIR_STAGING ‚Äì t.ex. /srv/sparkling-owl-spin (serverns katalog d√§r docker-compose.yml ligger)

COMPOSE_DIR_CANARY ‚Äì t.ex. /srv/sparkling-owl-spin-canary (root f√∂r PR‚Äëpreview)

NODE_VERSION ‚Äì t.ex. 20

PYTHON_VERSION ‚Äì t.ex. 3.11

Vad h√§nder & verifiering
Secrets √§r p√• plats. Verifiera genom att √∂ppna Settings ‚Üí Secrets och att inga stavas fel.

üí° Tips: Skydda milj√∂er via Environments (staging, production) med ‚Äúrequired reviewers‚Äù f√∂r extra s√§kerhet.

2) Katalog f√∂r workflows

Enkel f√∂rklaring
Vi skapar GitHub Actions‚Äëkatalogen i repo och l√§gger in alla pipelines som separata YAML‚Äëfiler.

Kommandon

mkdir .github
mkdir .github\workflows


macOS/Linux:

mkdir -p .github/workflows


Verifiering

dir .github\workflows


Du ska se en tom katalog.

3) CI ‚Äì Bygg, lint, test & (p√• main) bygg/pusha images

Enkel f√∂rklaring
Denna k√∂rs p√• PR och push. Den lintar, bygger frontend, k√∂r Python‚Äëtester och (p√• main) bygger/pushar Docker‚Äëimages till GHCR.

Skapa filen: .github/workflows/ci.yml

Hela filen:

name: CI

on:
  push:
    branches: [ "**" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_API: ${{ github.repository }}-api
  IMAGE_WORKER: ${{ github.repository }}-worker
  PY_VERSION: ${{ vars.PYTHON_VERSION || '3.11' }}
  NODE_VERSION: ${{ vars.NODE_VERSION || '20' }}
  CACHE_KEY_PREFIX: ci-${{ github.ref_name }}-

jobs:
  lint-and-test-backend:
    name: Backend lint & test (Python)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PY_VERSION }}
          cache: 'pip'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements_dev.txt ]; then pip install -r requirements_dev.txt; fi
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f pyproject.toml ]; then pip install .; fi

      - name: Lint (ruff/mypy if present)
        run: |
          if [ -f ruff.toml ]; then pip install ruff && ruff check .; else echo "No ruff"; fi
          if [ -f mypy.ini ]; then pip install mypy && mypy . || true; else echo "No mypy"; fi

      - name: Run tests
        run: |
          if [ -f Makefile ] && make -q test 2>/dev/null; then
            make test
          else
            pytest -q || pytest
          fi

  build-frontend:
    name: Frontend build (Node)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm install; fi

      - name: Typecheck & build
        run: |
          if [ -f tsconfig.json ]; then npm run typecheck || true; fi
          npm run build

      - name: Upload frontend build artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: |
            frontend/dist
            !**/node_modules/**

  docker-build-push:
    name: Docker build & push (only main)
    needs: [lint-and-test-backend, build-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta_api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_API }}
          tags: |
            type=sha,prefix=
            type=raw,value=staging,enable={{is_default_branch}}

      - name: Build & push API
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.app
          push: true
          tags: ${{ steps.meta_api.outputs.tags }}
          labels: ${{ steps.meta_api.outputs.labels }}
          build-args: |
            GIT_SHA=${{ github.sha }}

      - name: Extract metadata (worker)
        id: meta_worker
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_WORKER }}
          tags: |
            type=sha,prefix=
            type=raw,value=staging,enable={{is_default_branch}}

      - name: Build & push Worker
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.worker
          push: true
          tags: ${{ steps.meta_worker.outputs.tags }}
          labels: ${{ steps.meta_worker.outputs.labels }}
          build-args: |
            GIT_SHA=${{ github.sha }}

      - name: Save image digests
        run: |
          echo "API_DIGEST=${{ steps.meta_api.outputs.digest }}" >> $GITHUB_ENV
          echo "WORKER_DIGEST=${{ steps.meta_worker.outputs.digest }}" >> $GITHUB_ENV


Vad h√§nder & verifiering

PR: k√∂r lint, test, frontend build.

Push p√• main: bygger & pushar ghcr.io/<owner>/<repo>-api och -worker med taggar staging + sha.
Verifiera: GitHub ‚Üí Actions ‚Üí CI run ska bli gr√∂n. Under Packages i repo/owner ska du se images.

4) Deploy till staging via SSH + Docker Compose

Enkel f√∂rklaring
N√§r main uppdateras drar staging‚Äëservern nya images fr√•n GHCR och k√∂r docker compose up -d.

Krav p√• servern

Docker + Docker Compose.

Katalog ${{ secrets.COMPOSE_DIR_STAGING }} med docker-compose.yml som refererar images ghcr.io/<owner>/<repo>-api:staging osv.

Din publika nyckel i ~/.ssh/authorized_keys.

Skapa filen: .github/workflows/deploy_staging.yml

Hela filen:

name: Deploy Staging

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  packages: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_API: ${{ github.repository }}-api
  IMAGE_WORKER: ${{ github.repository }}-worker

jobs:
  deploy:
    name: SSH deploy to staging
    runs-on: ubuntu-latest
    environment: staging
    concurrency:
      group: staging-deploy
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4

      - name: Ensure images exist (optional)
        run: echo "Will deploy images: $REGISTRY/$IMAGE_API:staging and $REGISTRY/$IMAGE_WORKER:staging"

      - name: Add SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_STAGING }}

      - name: Known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SSH_HOST_STAGING }} >> ~/.ssh/known_hosts

      - name: Pull & compose up
        run: |
          ssh ${{ secrets.SSH_USER_STAGING }}@${{ secrets.SSH_HOST_STAGING }} <<'EOF'
          set -euo pipefail
          cd ${{ secrets.COMPOSE_DIR_STAGING }}
          docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}
          docker compose pull
          docker compose up -d
          docker image prune -f
          EOF


Vad h√§nder & verifiering
Jobbet loggar in via SSH, drar images och startar containrar.
Verifiera p√• servern:

docker ps
docker compose ls
docker compose logs -n 100 api


Och testa h√§lso‚ÄëURL (om finns): curl http://<staging-host>/healthz

5) Canary/Preview per Pull Request

Enkel f√∂rklaring
F√∂r varje PR spinna upp en tillf√§llig milj√∂ (‚Äúcanary‚Äù) p√• en s√§rskild server/katalog. Projektet k√∂rs med images taggade p√• commit‚ÄëSHA och ett Compose‚Äëprojekt med namn pr-<nummer>.

Serverkrav
Reverse proxy (t.ex. Traefik/Nginx) som routar pr-<num>.<din-dom√§n> ‚Üí canary‚Äëcompose. (Konfig sker p√• server; pipeline s√§tter bara upp containern.)

Skapa filen: .github/workflows/deploy_canary.yml

Hela filen:

name: Canary Preview

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_target:
    types: [closed]

permissions:
  contents: read
  packages: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_API: ${{ github.repository }}-api
  IMAGE_WORKER: ${{ github.repository }}-worker

jobs:
  up:
    if: github.event_name == 'pull_request'
    name: Up PR canary
    runs-on: ubuntu-latest
    concurrency:
      group: canary-pr-${{ github.event.number }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4

      - name: Add SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_STAGING }}

      - name: Known hosts
        run: ssh-keyscan -H ${{ secrets.SSH_HOST_STAGING }} >> ~/.ssh/known_hosts

      - name: Deploy PR stack
        env:
          PR_NUM: ${{ github.event.number }}
          SHA_TAG: ${{ github.sha }}
        run: |
          ssh ${{ secrets.SSH_USER_STAGING }}@${{ secrets.SSH_HOST_STAGING }} <<'EOF'
          set -euo pipefail
          export PR_NUM=${PR_NUM}
          export SHA_TAG=${SHA_TAG}
          export STACK_DIR=${{ secrets.COMPOSE_DIR_CANARY }}/pr-${PR_NUM}
          mkdir -p "$STACK_DIR"
          cat > "$STACK_DIR/docker-compose.yml" <<YML
          services:
            api:
              image: $REGISTRY/$IMAGE_API:${SHA_TAG}
              restart: unless-stopped
              env_file: .env
              ports:
                - "0"
              labels:
                # Exempel f√∂r Traefik (justera efter din proxy)
                - "traefik.enable=true"
                - "traefik.http.routers.api-pr${PR_NUM}.rule=Host(\`pr-${PR_NUM}.YOURDOMAIN\`)"
            worker:
              image: $REGISTRY/$IMAGE_WORKER:${SHA_TAG}
              restart: unless-stopped
              env_file: .env
          YML
          cd "$STACK_DIR"
          docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}
          docker compose pull
          COMPOSE_PROJECT_NAME=pr-${PR_NUM} docker compose up -d
          EOF

  down:
    if: github.event_name == 'pull_request_target' && github.event.action == 'closed'
    name: Down PR canary
    runs-on: ubuntu-latest
    steps:
      - name: Add SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_STAGING }}
      - name: Known hosts
        run: ssh-keyscan -H ${{ secrets.SSH_HOST_STAGING }} >> ~/.ssh/known_hosts
      - name: Remove PR stack
        env:
          PR_NUM: ${{ github.event.pull_request.number }}
        run: |
          ssh ${{ secrets.SSH_USER_STAGING }}@${{ secrets.SSH_HOST_STAGING }} <<'EOF'
          set -euo pipefail
          export PR_NUM=${PR_NUM}
          export STACK_DIR=${{ secrets.COMPOSE_DIR_CANARY }}/pr-${PR_NUM}
          COMPOSE_PROJECT_NAME=pr-${PR_NUM} docker compose -f "$STACK_DIR/docker-compose.yml" down -v || true
          rm -rf "$STACK_DIR"
          EOF


Vad h√§nder & verifiering

N√§r du √∂ppnar/uppdaterar PR byggs images i CI (ci.yml) och canary skapas med commit‚ÄëSHA.

Verifiera: n√• pr-<num>.<din-dom√§n> (justera proxyetiketter i filen).

Vid ‚ÄúClose PR‚Äù rivs milj√∂n.

6) Nightly selector regression mot syntetiska testsajter

Enkel f√∂rklaring
Nattetid k√∂r vi E2E/regression mot de lokala syntetiska sajterna (containeriserade) f√∂r att uppt√§cka selektor‚Äëdrift och brutna fl√∂den.

Skapa filen: .github/workflows/nightly_selector_regression.yml

Hela filen:

name: Nightly Selector Regression

on:
  schedule:
    - cron: "0 2 * * *"   # 02:00 UTC
  workflow_dispatch:

permissions:
  contents: read

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Start synthetic sites
        run: |
          docker compose -f docker/synthetic-sites/docker-compose.yml up -d
          sleep 10
          docker ps

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install test deps
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements_dev.txt ]; then pip install -r requirements_dev.txt; fi
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Run E2E tests
        env:
          SYN_BASE_STATIC: http://localhost:8081
          SYN_BASE_SCROLL: http://localhost:8082
          SYN_BASE_FORM:   http://localhost:8083
        run: |
          if [ -d tests/e2e ]; then pytest -q tests/e2e; else echo "No e2e dir"; fi

      - name: Collect logs
        if: always()
        run: |
          docker compose -f docker/synthetic-sites/docker-compose.yml logs > synthetic-logs.txt || true
          docker compose -f docker/synthetic-sites/docker-compose.yml down -v || true

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nightly-artifacts
          path: |
            synthetic-logs.txt
            .pytest_cache
            tests/**/report*.html


Vad h√§nder & verifiering

GH runner startar dina syntetiska sajter, k√∂r E2E, laddar upp loggar.

Verifiera i Actions att jobben √§r gr√∂na och √∂ppna artefakter.

7) SBOM (Software Bill of Materials)

Enkel f√∂rklaring
Vi genererar SBOM f√∂r backend‚Äëimage och frontend‚Äëbuild f√∂r insyn i beroenden.

Skapa filen: .github/workflows/sbom.yml

Hela filen:

name: SBOM

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  packages: read

env:
  REGISTRY: ghcr.io
  IMAGE_API: ${{ github.repository }}-api

jobs:
  sbom:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Generate SBOM for API image
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_API }}:staging
          artifact-name: sbom-api-spdx.json
          format: spdx-json

      - name: Generate SBOM for source tree
        uses: anchore/sbom-action@v0
        with:
          path: .
          artifact-name: sbom-source-spdx.json
          format: spdx-json


Vad h√§nder & verifiering
Artefakterna sbom-*.json laddas upp. Verifiera under Artifacts i jobbrun.

8) cosign verifiering av images

Enkel f√∂rklaring
N√§r image √§r signerad (t.ex. med keyless i ett separat steg) kan vi verifiera signaturen under build eller innan deploy. H√§r l√§gger vi en separat validerings‚Äëworkflow.

Skapa filen: .github/workflows/cosign_verify.yml

Hela filen:

name: Cosign Verify

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

permissions:
  contents: read
  packages: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_API: ${{ github.repository }}-api
  IMAGE_WORKER: ${{ github.repository }}-worker

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Verify API (keyless)
        continue-on-error: true
        run: |
          cosign verify $REGISTRY/$IMAGE_API:staging \
            --certificate-identity-regexp 'https://github.com/.+' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com'

      - name: Verify Worker (keyless)
        continue-on-error: true
        run: |
          cosign verify $REGISTRY/$IMAGE_WORKER:staging \
            --certificate-identity-regexp 'https://github.com/.+' \
            --certificate-oidc-issuer 'https://token.actions.githubusercontent.com'


Vad h√§nder & verifiering
Cosign f√∂rs√∂ker verifiera att images signerats via GitHub OIDC (keyless). Om du √§nnu inte signerar blir stegen ‚Äúskipped/failed‚Äù; koppla p√• signering i din build (se ‚ÄúExtra‚Äù l√§ngre ned) och k√∂r igen.

9) Serverns docker-compose.yml (staging) ‚Äì exempel

Enkel f√∂rklaring
Servern beh√∂ver en Compose‚Äëfil som pekar p√• images fr√•n GHCR med tag staging.

Kommandon ‚Äì p√• staging‚Äëservern

mkdir -p /srv/sparkling-owl-spin
nano /srv/sparkling-owl-spin/docker-compose.yml


Exempel‚Äëinneh√•ll (justera portar/dom√§n/volymer):

services:
  api:
    image: ghcr.io/OWNER/REPO-api:staging
    restart: unless-stopped
    env_file: .env
    ports:
      - "8080:8080"   # eller via proxy
  worker:
    image: ghcr.io/OWNER/REPO-worker:staging
    restart: unless-stopped
    env_file: .env


Verifiering

docker compose pull
docker compose up -d
curl http://localhost:8080/healthz


üìù Byt OWNER/REPO till ditt faktiska repo. L√§gg .env med n√∂dv√§ndiga variabler (Supabase URL/nycklar, DB‚ÄëURL osv.) ‚Äî inte incheckat i Git.

10) Lokalt k√∂rfl√∂de (Docker)

Enkel f√∂rklaring
Lokalt jobbar du mot Docker utan att g√• via Actions. Bra f√∂r snabb test av Compose.

Kommandon

# i repo-roten
docker compose -f docker/docker-compose.yml up -d
docker compose ps


Verifiering
√ñppna din lokala API‚ÄëURL, t.ex. http://localhost:8080/docs.
Stoppa:

docker compose down -v

11) Versions‚Äëtaggar f√∂r production (valfritt)

Enkel f√∂rklaring
Skapa en release med vX.Y.Z tagg. Vi kan ha separat prod‚Äëdeploy workflow som triggas p√• taggar. (Samma som staging men :prod eller :vX.Y.Z tags.)

Kort mall (om du vill l√§gga till senare)

on: push: tags: ["v*.*.*"]

Bygg & pusha :latest och :vX.Y.Z

SSH‚Äëdeploy till prod med COMPOSE_DIR_PROD.

12) Extra: L√§gg in signering av images i CI (frivilligt men rekommenderas)

Enkel f√∂rklaring
Med cosign keyless signerar du direkt i Actions (Fulcio/rekor) utan att hantera nycklar.

Hur
I ci.yml efter build‚Äëpush l√§gg:

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign API (keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cosign sign $REGISTRY/$IMAGE_API:staging

      - name: Sign Worker (keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          cosign sign $REGISTRY/$IMAGE_WORKER:staging


Verifiering
K√∂r Cosign Verify workflow eller lokalt:
cosign verify ghcr.io/owner/repo-api:staging

13) Caching & hastighet

Enkel f√∂rklaring
Pip och npm cacheas automatiskt via setup-python/setup-node. Du kan √§ven cacha Docker‚Äëlager.

Tips (valfritt) ‚Äî cacha Docker-lager
L√§gg till i build‚Äëstegen:

cache-from: type=gha
cache-to: type=gha,mode=max

14) Concurrency & skydd

Enkel f√∂rklaring
Vi f√∂rhindrar ‚Äút√•gkrasch‚Äù i deployer genom concurrency‚Äëgrupper.
S√§tt protected environments i GitHub ‚Üí Environments ‚Üí staging/production.

15) Fels√∂kning vanliga problem

Actions kan inte pusha till GHCR ‚Üí Repo settings ‚Üí Packages permissions ‚Üí ge GITHUB_TOKEN write‚Äëpackages (standard i org oftast OK).

SSH misslyckas ‚Üí kontrollera SSH_* secrets, att nyckeln g√§ller r√§tt anv√§ndare, och known_hosts steg.

Compose hittar inte images ‚Üí kontrollera fulla namnet: ghcr.io/<owner>/<repo>-api:staging.

E2E nightly startar ej synthetic sites ‚Üí testa lokalt docker compose -f docker/synthetic-sites/docker-compose.yml up -d.

Cosign verify fail ‚Üí du signerar inte √§n. L√§gg steg i CI (punkt 12).

16) S√• testar du allt utan att v√§nta p√• ‚Äúriktig‚Äù server

Enkel f√∂rklaring
K√∂r endast CI‚Äëdelen (bygg/test) p√• en branch/PR. F√∂r staging‚Äëdeploy beh√∂ver servern vara klar.
Lokalt kan du simulera fl√∂den genom att k√∂ra Compose.

Kommandon

# Skapa en test‚Äëbranch
git checkout -b ci-smoke
git commit --allow-empty -m "ci: smoke"
git push -u origin ci-smoke


Verifiering
Actions k√∂r ‚ÄúCI‚Äù. Gr√∂nt = bra.

Snabb checklista (daglig drift)

 PR ‚Üí CI (lint, test, build) ‚Üí gr√∂n?

 Merge till main ‚Üí images pushas ‚Üí staging‚Äëdeploy k√∂rs.

 Kolla staging h√§lso‚ÄëURL/loggar.

 Nightly E2E ‚Üí gr√∂n? l√§s artefakter om r√∂tt.

 (Vid release) skapa vX.Y.Z ‚Üí prod‚Äëdeploy (om p√•slaget).

 SBOM genereras p√• main.

 (Om signering) cosign verify OK.

Sammanfattning av nya filer

.github/workflows/ci.yml ‚Äì CI (lint, test, frontend build, docker build/push)

.github/workflows/deploy_staging.yml ‚Äì automatisk staging‚Äëdeploy via SSH + Compose

.github/workflows/deploy_canary.yml ‚Äì canary per PR (up & down)

.github/workflows/nightly_selector_regression.yml ‚Äì kl 02:00 UTC nattliga E2E mot syntetiska sajter

.github/workflows/sbom.yml ‚Äì genererar SBOM‚Äëartefakter

.github/workflows/cosign_verify.yml ‚Äì verifierar signaturer

Allt ovan √§r plug‚Äëand‚Äëplay med dina befintliga Dockerfiler (docker/Dockerfile.app/worker) och dina syntetiska sajter. Justera bara dom√§n/portar och serverkataloger i secrets & compose.

Vill du att jag √§ven l√§gger till prod‚Äëdeploy (tag‚Äëtriggad), reusable workflows (DRY), eller Kubernetes‚Äëdeploy (n√§sta steg), s√• skriver jag dem i samma stil.