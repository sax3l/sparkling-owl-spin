#!/usr/bin/env python3
"""
OSINT (Open Source Intelligence) Engine
Kombinerar funktionalitet från The_spy_job, rengine och andra OSINT-verktyg
för säker informationsinsamling
"""

import asyncio
import logging
import json
import requests
import dns.resolver
import whois
import socket
import ssl
import subprocess
import re
from typing import Dict, Any, Optional, List, Tuple, Set, Union
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
from pathlib import Path
import hashlib
import base64
from urllib.parse import urlparse, urljoin
import ipaddress
import concurrent.futures
from contextlib import contextmanager

logger = logging.getLogger(__name__)

class OSINTType(Enum):
    """Types of OSINT gathering"""
    DOMAIN_RECONNAISSANCE = "domain_reconnaissance"
    SUBDOMAIN_ENUMERATION = "subdomain_enumeration" 
    IP_RECONNAISSANCE = "ip_reconnaissance"
    PORT_SCANNING = "port_scanning"
    DNS_ENUMERATION = "dns_enumeration"
    WHOIS_LOOKUP = "whois_lookup"
    SSL_CERTIFICATE_ANALYSIS = "ssl_certificate_analysis"
    WEB_TECHNOLOGY_DETECTION = "web_technology_detection"
    EMAIL_HARVESTING = "email_harvesting"
    SOCIAL_MEDIA_RECONNAISSANCE = "social_media_reconnaissance"
    LEAKED_CREDENTIALS = "leaked_credentials"
    COMPANY_INFORMATION = "company_information"
    PERSON_INFORMATION = "person_information"
    NETWORK_MAPPING = "network_mapping"

class InformationSensitivity(Enum):
    """Sensitivity level of gathered information"""
    PUBLIC = "public"
    SENSITIVE = "sensitive"
    CONFIDENTIAL = "confidential"
    RESTRICTED = "restricted"

@dataclass
class OSINTTarget:
    """Target for OSINT gathering"""
    target_id: str
    target_type: str  # domain, ip, company, person, etc.
    value: str
    additional_info: Dict[str, Any] = field(default_factory=dict)
    scope_restrictions: List[str] = field(default_factory=list)

@dataclass
class OSINTResult:
    """Result from OSINT operation"""
    result_id: str
    target: OSINTTarget
    osint_type: OSINTType
    data: Dict[str, Any]
    sensitivity: InformationSensitivity
    sources: List[str] = field(default_factory=list)
    confidence_score: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)
    expires_at: Optional[datetime] = None

@dataclass 
class OSINTOperation:
    """OSINT operation tracking"""
    operation_id: str
    target: OSINTTarget
    osint_types: List[OSINTType]
    start_time: datetime
    end_time: Optional[datetime] = None
    results: List[OSINTResult] = field(default_factory=list)
    status: str = "running"
    error_message: str = ""

class EthicalOSINTConstraints:
    """Ethical constraints for OSINT operations"""
    
    FORBIDDEN_TARGETS = [
        "individuals",
        "private_persons",
        "non_public_figures"
    ]
    
    ALLOWED_SOURCES = [
        "public_dns",
        "public_whois",
        "public_websites",
        "search_engines",
        "certificate_transparency",
        "public_apis"
    ]
    
    @staticmethod
    def check_target_allowed(target: OSINTTarget) -> Tuple[bool, str]:
        """Check if target is ethically allowed for OSINT"""
        
        # Only allow organizational targets, not individuals
        if target.target_type in ['person', 'individual']:
            return False, "OSINT on individuals is not permitted"
        
        # Check scope restrictions
        if 'no_personal_info' in target.scope_restrictions:
            return True, "Target allowed with personal info restrictions"
        
        return True, "Target allowed for organizational OSINT"
    
    @staticmethod
    def sanitize_results(results: List[OSINTResult]) -> List[OSINTResult]:
        """Remove sensitive personal information from results"""
        sanitized = []
        
        for result in results:
            # Remove personal emails
            if 'emails' in result.data:
                result.data['emails'] = [
                    email for email in result.data['emails']
                    if not EthicalOSINTConstraints._is_personal_email(email)
                ]
            
            # Remove personal phone numbers
            if 'phones' in result.data:
                result.data['phones'] = []  # Remove all phone numbers to be safe
            
            # Remove personal addresses
            if 'addresses' in result.data:
                result.data['addresses'] = [
                    addr for addr in result.data['addresses']
                    if EthicalOSINTConstraints._is_business_address(addr)
                ]
            
            sanitized.append(result)
        
        return sanitized
    
    @staticmethod
    def _is_personal_email(email: str) -> bool:
        """Check if email appears to be personal"""
        personal_domains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com']
        domain = email.split('@')[-1].lower()
        return domain in personal_domains
    
    @staticmethod
    def _is_business_address(address: str) -> bool:
        """Check if address appears to be business-related"""
        # Simple heuristic - business addresses often contain business terms
        business_terms = ['office', 'building', 'suite', 'floor', 'business', 'corp']
        address_lower = address.lower()
        return any(term in address_lower for term in business_terms)

class OSINTEngine:
    """Advanced OSINT engine with ethical constraints"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.operations = {}
        self.results_cache = {}
        self.ethical_mode = self.config.get('ethical_mode', True)
        
        # Configure DNS resolver
        self.dns_resolver = dns.resolver.Resolver()
        self.dns_resolver.timeout = 5
        self.dns_resolver.lifetime = 10
        
        # Setup session for HTTP requests
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'OSINTEngine/1.0 (Ethical Research)'
        })
        
        logger.info("OSINT Engine initialized with ethical constraints")
    
    async def start_operation(self, 
                            target: OSINTTarget, 
                            osint_types: List[OSINTType] = None) -> OSINTOperation:
        """Start comprehensive OSINT operation"""
        
        # Ethical check
        if self.ethical_mode:
            allowed, reason = EthicalOSINTConstraints.check_target_allowed(target)
            if not allowed:
                raise ValueError(f"Target not allowed: {reason}")
        
        if osint_types is None:
            osint_types = [
                OSINTType.DOMAIN_RECONNAISSANCE,
                OSINTType.SUBDOMAIN_ENUMERATION,
                OSINTType.DNS_ENUMERATION,
                OSINTType.WHOIS_LOOKUP,
                OSINTType.SSL_CERTIFICATE_ANALYSIS
            ]
        
        operation_id = self._generate_operation_id(target)
        
        operation = OSINTOperation(
            operation_id=operation_id,
            target=target,
            osint_types=osint_types,
            start_time=datetime.now(),
            status="running"
        )
        
        self.operations[operation_id] = operation
        
        try:
            # Execute OSINT types in parallel where possible
            tasks = []
            for osint_type in osint_types:
                task = self._execute_osint_type(target, osint_type)
                tasks.append(task)
            
            # Wait for all tasks to complete
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Process results
            for result in results:
                if isinstance(result, Exception):
                    logger.warning(f"OSINT task failed: {result}")
                elif isinstance(result, list):
                    operation.results.extend(result)
                elif result is not None:
                    operation.results.append(result)
            
            # Apply ethical constraints
            if self.ethical_mode:
                operation.results = EthicalOSINTConstraints.sanitize_results(operation.results)
            
            operation.status = "completed"
            operation.end_time = datetime.now()
            
        except Exception as e:
            operation.status = "failed"
            operation.error_message = str(e)
            operation.end_time = datetime.now()
            logger.error(f"OSINT operation failed: {e}")
        
        return operation
    
    async def _execute_osint_type(self, target: OSINTTarget, osint_type: OSINTType) -> Union[OSINTResult, List[OSINTResult], None]:
        """Execute specific OSINT type"""
        
        try:
            if osint_type == OSINTType.DOMAIN_RECONNAISSANCE:
                return await self._domain_reconnaissance(target)
            elif osint_type == OSINTType.SUBDOMAIN_ENUMERATION:
                return await self._subdomain_enumeration(target)
            elif osint_type == OSINTType.DNS_ENUMERATION:
                return await self._dns_enumeration(target)
            elif osint_type == OSINTType.WHOIS_LOOKUP:
                return await self._whois_lookup(target)
            elif osint_type == OSINTType.SSL_CERTIFICATE_ANALYSIS:
                return await self._ssl_certificate_analysis(target)
            elif osint_type == OSINTType.WEB_TECHNOLOGY_DETECTION:
                return await self._web_technology_detection(target)
            elif osint_type == OSINTType.PORT_SCANNING:
                return await self._port_scanning(target)
            else:
                logger.warning(f"OSINT type {osint_type} not implemented")
                return None
                
        except Exception as e:
            logger.error(f"Error executing {osint_type}: {e}")
            return None
    
    async def _domain_reconnaissance(self, target: OSINTTarget) -> OSINTResult:
        """Perform domain reconnaissance"""
        
        domain = target.value
        data = {
            'domain': domain,
            'ip_addresses': [],
            'mx_records': [],
            'txt_records': [],
            'ns_records': [],
            'cname_records': []
        }
        
        try:
            # Get A records
            try:
                answers = self.dns_resolver.resolve(domain, 'A')
                data['ip_addresses'] = [str(answer) for answer in answers]
            except:
                pass
            
            # Get MX records
            try:
                answers = self.dns_resolver.resolve(domain, 'MX')
                data['mx_records'] = [str(answer) for answer in answers]
            except:
                pass
            
            # Get TXT records
            try:
                answers = self.dns_resolver.resolve(domain, 'TXT')
                data['txt_records'] = [str(answer) for answer in answers]
            except:
                pass
            
            # Get NS records
            try:
                answers = self.dns_resolver.resolve(domain, 'NS')
                data['ns_records'] = [str(answer) for answer in answers]
            except:
                pass
                
        except Exception as e:
            logger.warning(f"Domain reconnaissance error: {e}")
        
        return OSINTResult(
            result_id=self._generate_result_id(),
            target=target,
            osint_type=OSINTType.DOMAIN_RECONNAISSANCE,
            data=data,
            sensitivity=InformationSensitivity.PUBLIC,
            sources=['public_dns'],
            confidence_score=0.9
        )
    
    async def _subdomain_enumeration(self, target: OSINTTarget) -> List[OSINTResult]:
        """Enumerate subdomains"""
        
        domain = target.value
        subdomains = set()
        
        # Common subdomain wordlist
        common_subdomains = [
            'www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging', 'api',
            'app', 'web', 'secure', 'vpn', 'remote', 'blog', 'shop', 'store',
            'support', 'help', 'docs', 'cdn', 'static', 'assets', 'images',
            'downloads', 'files', 'upload', 'uploads', 'media', 'video',
            'mobile', 'm', 'wap', 'portal', 'gateway', 'proxy', 'firewall'
        ]
        
        # Test common subdomains
        for subdomain in common_subdomains:
            full_domain = f"{subdomain}.{domain}"
            try:
                answers = self.dns_resolver.resolve(full_domain, 'A')
                if answers:
                    subdomains.add(full_domain)
                    logger.info(f"Found subdomain: {full_domain}")
            except:
                pass
        
        # Certificate transparency logs (mock implementation)
        # In reality, this would query CT logs
        cert_subdomains = await self._query_certificate_transparency(domain)
        subdomains.update(cert_subdomains)
        
        results = []
        for subdomain in subdomains:
            result = OSINTResult(
                result_id=self._generate_result_id(),
                target=target,
                osint_type=OSINTType.SUBDOMAIN_ENUMERATION,
                data={'subdomain': subdomain, 'parent_domain': domain},
                sensitivity=InformationSensitivity.PUBLIC,
                sources=['dns_brute_force', 'certificate_transparency'],
                confidence_score=0.8
            )
            results.append(result)
        
        return results
    
    async def _query_certificate_transparency(self, domain: str) -> Set[str]:
        """Query certificate transparency logs for subdomains"""
        subdomains = set()
        
        try:
            # Mock CT log query - in reality would use crt.sh or similar
            ct_url = f"https://crt.sh/?q=%25.{domain}&output=json"
            response = requests.get(ct_url, timeout=10)
            
            if response.status_code == 200:
                certificates = response.json()
                for cert in certificates:
                    if 'name_value' in cert:
                        names = cert['name_value'].split('\n')
                        for name in names:
                            name = name.strip()
                            if name.endswith(f".{domain}") and name != domain:
                                subdomains.add(name)
                                
        except Exception as e:
            logger.warning(f"Certificate transparency query failed: {e}")
        
        return subdomains
    
    async def _dns_enumeration(self, target: OSINTTarget) -> List[OSINTResult]:
        """Enumerate DNS records"""
        
        domain = target.value
        results = []
        
        # DNS record types to query
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA', 'CNAME', 'PTR', 'SRV']
        
        for record_type in record_types:
            try:
                answers = self.dns_resolver.resolve(domain, record_type)
                records = [str(answer) for answer in answers]
                
                if records:
                    result = OSINTResult(
                        result_id=self._generate_result_id(),
                        target=target,
                        osint_type=OSINTType.DNS_ENUMERATION,
                        data={
                            'record_type': record_type,
                            'records': records,
                            'domain': domain
                        },
                        sensitivity=InformationSensitivity.PUBLIC,
                        sources=['public_dns'],
                        confidence_score=0.95
                    )
                    results.append(result)
                    
            except Exception:
                continue
        
        return results
    
    async def _whois_lookup(self, target: OSINTTarget) -> OSINTResult:
        """Perform WHOIS lookup"""
        
        domain = target.value
        data = {}
        
        try:
            # Perform WHOIS lookup
            whois_data = whois.whois(domain)
            
            if whois_data:
                # Extract relevant information
                data = {
                    'domain': domain,
                    'registrar': whois_data.registrar,
                    'creation_date': str(whois_data.creation_date) if whois_data.creation_date else None,
                    'expiration_date': str(whois_data.expiration_date) if whois_data.expiration_date else None,
                    'name_servers': whois_data.name_servers if whois_data.name_servers else [],
                    'status': whois_data.status if whois_data.status else [],
                    'organization': whois_data.org if hasattr(whois_data, 'org') else None
                }
                
                # Remove personal information in ethical mode
                if self.ethical_mode:
                    sensitive_fields = ['registrant_name', 'admin_name', 'tech_name', 
                                      'registrant_email', 'admin_email', 'tech_email',
                                      'registrant_phone', 'admin_phone', 'tech_phone']
                    for field in sensitive_fields:
                        if field in data:
                            del data[field]
                            
        except Exception as e:
            logger.warning(f"WHOIS lookup failed: {e}")
            data = {'domain': domain, 'error': str(e)}
        
        return OSINTResult(
            result_id=self._generate_result_id(),
            target=target,
            osint_type=OSINTType.WHOIS_LOOKUP,
            data=data,
            sensitivity=InformationSensitivity.SENSITIVE,
            sources=['public_whois'],
            confidence_score=0.9
        )
    
    async def _ssl_certificate_analysis(self, target: OSINTTarget) -> OSINTResult:
        """Analyze SSL certificate"""
        
        domain = target.value
        data = {}
        
        try:
            # Get SSL certificate
            context = ssl.create_default_context()
            with socket.create_connection((domain, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=domain) as ssock:
                    cert = ssock.getpeercert()
                    
                    data = {
                        'domain': domain,
                        'subject': dict(x[0] for x in cert['subject']),
                        'issuer': dict(x[0] for x in cert['issuer']),
                        'version': cert.get('version'),
                        'serial_number': cert.get('serialNumber'),
                        'not_before': cert.get('notBefore'),
                        'not_after': cert.get('notAfter'),
                        'signature_algorithm': cert.get('signatureAlgorithm'),
                        'alt_names': []
                    }
                    
                    # Extract Subject Alternative Names
                    if 'subjectAltName' in cert:
                        data['alt_names'] = [name[1] for name in cert['subjectAltName']]
                        
        except Exception as e:
            logger.warning(f"SSL certificate analysis failed: {e}")
            data = {'domain': domain, 'error': str(e)}
        
        return OSINTResult(
            result_id=self._generate_result_id(),
            target=target,
            osint_type=OSINTType.SSL_CERTIFICATE_ANALYSIS,
            data=data,
            sensitivity=InformationSensitivity.PUBLIC,
            sources=['ssl_certificate'],
            confidence_score=0.95
        )
    
    async def _web_technology_detection(self, target: OSINTTarget) -> OSINTResult:
        """Detect web technologies"""
        
        domain = target.value
        url = f"https://{domain}"
        data = {
            'domain': domain,
            'technologies': [],
            'headers': {},
            'status_code': None
        }
        
        try:
            response = self.session.get(url, timeout=10, allow_redirects=True)
            data['status_code'] = response.status_code
            data['headers'] = dict(response.headers)
            
            # Detect technologies from headers
            if 'server' in response.headers:
                data['technologies'].append({
                    'name': 'Server',
                    'value': response.headers['server'],
                    'confidence': 0.9
                })
            
            if 'x-powered-by' in response.headers:
                data['technologies'].append({
                    'name': 'Framework',
                    'value': response.headers['x-powered-by'],
                    'confidence': 0.9
                })
            
            # Detect from content
            content = response.text.lower()
            
            # Common technology signatures
            tech_signatures = {
                'WordPress': ['wp-content', 'wp-includes'],
                'Drupal': ['drupal', 'sites/default'],
                'Joomla': ['joomla', 'administrator'],
                'React': ['react', '__reactInternalInstance'],
                'Angular': ['ng-', 'angular'],
                'Vue.js': ['vue', 'v-if'],
                'jQuery': ['jquery', '$'],
                'Bootstrap': ['bootstrap', 'col-md'],
                'PHP': ['<?php', '.php']
            }
            
            for tech, signatures in tech_signatures.items():
                for signature in signatures:
                    if signature in content:
                        data['technologies'].append({
                            'name': tech,
                            'confidence': 0.7
                        })
                        break
                        
        except Exception as e:
            logger.warning(f"Web technology detection failed: {e}")
            data['error'] = str(e)
        
        return OSINTResult(
            result_id=self._generate_result_id(),
            target=target,
            osint_type=OSINTType.WEB_TECHNOLOGY_DETECTION,
            data=data,
            sensitivity=InformationSensitivity.PUBLIC,
            sources=['http_headers', 'html_content'],
            confidence_score=0.8
        )
    
    async def _port_scanning(self, target: OSINTTarget) -> List[OSINTResult]:
        """Basic port scanning (ethical - common ports only)"""
        
        if target.target_type != 'ip' and target.target_type != 'domain':
            return []
        
        host = target.value
        results = []
        
        # Only scan common ports for ethical reasons
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995]
        
        for port in common_ports:
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(3)
                    result_code = sock.connect_ex((host, port))
                    
                    if result_code == 0:  # Port is open
                        service_name = self._get_service_name(port)
                        
                        result = OSINTResult(
                            result_id=self._generate_result_id(),
                            target=target,
                            osint_type=OSINTType.PORT_SCANNING,
                            data={
                                'host': host,
                                'port': port,
                                'status': 'open',
                                'service': service_name
                            },
                            sensitivity=InformationSensitivity.PUBLIC,
                            sources=['tcp_connect'],
                            confidence_score=0.95
                        )
                        results.append(result)
                        
            except Exception as e:
                logger.debug(f"Port scan error for {host}:{port}: {e}")
                continue
        
        return results
    
    def _get_service_name(self, port: int) -> str:
        """Get common service name for port"""
        services = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            993: 'IMAPS',
            995: 'POP3S'
        }
        return services.get(port, 'Unknown')
    
    def get_operation(self, operation_id: str) -> Optional[OSINTOperation]:
        """Get operation by ID"""
        return self.operations.get(operation_id)
    
    def get_all_operations(self, target_value: str = None) -> List[OSINTOperation]:
        """Get all operations, optionally filtered by target"""
        operations = list(self.operations.values())
        
        if target_value:
            operations = [op for op in operations if op.target.value == target_value]
        
        return operations
    
    def generate_report(self, operation_id: str) -> Dict[str, Any]:
        """Generate comprehensive OSINT report"""
        
        operation = self.get_operation(operation_id)
        if not operation:
            return {'error': 'Operation not found'}
        
        report = {
            'operation_id': operation_id,
            'target': {
                'type': operation.target.target_type,
                'value': operation.target.value
            },
            'generated_at': datetime.now().isoformat(),
            'operation_status': operation.status,
            'duration': None,
            'total_results': len(operation.results),
            'results_by_type': {},
            'summary': {},
            'recommendations': []
        }
        
        if operation.end_time and operation.start_time:
            duration = operation.end_time - operation.start_time
            report['duration'] = str(duration)
        
        # Group results by type
        for result in operation.results:
            osint_type = result.osint_type.value
            if osint_type not in report['results_by_type']:
                report['results_by_type'][osint_type] = []
            report['results_by_type'][osint_type].append(result.data)
        
        # Generate summary
        if operation.target.target_type == 'domain':
            report['summary'] = self._generate_domain_summary(operation.results)
        
        # Generate recommendations
        report['recommendations'] = self._generate_security_recommendations(operation.results)
        
        return report
    
    def _generate_domain_summary(self, results: List[OSINTResult]) -> Dict[str, Any]:
        """Generate domain-specific summary"""
        summary = {
            'subdomains_found': 0,
            'ip_addresses': [],
            'technologies': [],
            'open_ports': [],
            'certificates': {}
        }
        
        for result in results:
            if result.osint_type == OSINTType.SUBDOMAIN_ENUMERATION:
                summary['subdomains_found'] += 1
            elif result.osint_type == OSINTType.DOMAIN_RECONNAISSANCE:
                if 'ip_addresses' in result.data:
                    summary['ip_addresses'].extend(result.data['ip_addresses'])
            elif result.osint_type == OSINTType.WEB_TECHNOLOGY_DETECTION:
                if 'technologies' in result.data:
                    summary['technologies'].extend(result.data['technologies'])
            elif result.osint_type == OSINTType.PORT_SCANNING:
                if result.data.get('status') == 'open':
                    summary['open_ports'].append(result.data['port'])
            elif result.osint_type == OSINTType.SSL_CERTIFICATE_ANALYSIS:
                summary['certificates'] = result.data
        
        return summary
    
    def _generate_security_recommendations(self, results: List[OSINTResult]) -> List[str]:
        """Generate security recommendations based on results"""
        recommendations = []
        
        for result in results:
            if result.osint_type == OSINTType.PORT_SCANNING:
                if result.data.get('status') == 'open':
                    port = result.data['port']
                    if port in [21, 23]:  # FTP, Telnet
                        recommendations.append(f"Consider securing or disabling service on port {port}")
            
            elif result.osint_type == OSINTType.WEB_TECHNOLOGY_DETECTION:
                if 'error' not in result.data:
                    recommendations.append("Review exposed technology stack information")
            
            elif result.osint_type == OSINTType.SUBDOMAIN_ENUMERATION:
                recommendations.append("Review subdomain exposure and access controls")
        
        return list(set(recommendations))  # Remove duplicates
    
    def _generate_operation_id(self, target: OSINTTarget) -> str:
        """Generate unique operation ID"""
        timestamp = datetime.now().isoformat()
        data = f"{target.target_type}_{target.value}_{timestamp}"
        return hashlib.md5(data.encode()).hexdigest()[:16]
    
    def _generate_result_id(self) -> str:
        """Generate unique result ID"""
        timestamp = datetime.now().isoformat()
        return hashlib.md5(timestamp.encode()).hexdigest()[:12]

# Convenience functions
async def quick_domain_osint(domain: str) -> OSINTOperation:
    """Quick OSINT scan for domain"""
    engine = OSINTEngine()
    
    target = OSINTTarget(
        target_id=domain,
        target_type='domain',
        value=domain,
        scope_restrictions=['no_personal_info']
    )
    
    return await engine.start_operation(target)

async def comprehensive_domain_osint(domain: str) -> OSINTOperation:
    """Comprehensive OSINT scan for domain"""
    engine = OSINTEngine()
    
    target = OSINTTarget(
        target_id=domain,
        target_type='domain',
        value=domain,
        scope_restrictions=['no_personal_info']
    )
    
    osint_types = [
        OSINTType.DOMAIN_RECONNAISSANCE,
        OSINTType.SUBDOMAIN_ENUMERATION,
        OSINTType.DNS_ENUMERATION,
        OSINTType.WHOIS_LOOKUP,
        OSINTType.SSL_CERTIFICATE_ANALYSIS,
        OSINTType.WEB_TECHNOLOGY_DETECTION,
        OSINTType.PORT_SCANNING
    ]
    
    return await engine.start_operation(target, osint_types)

if __name__ == "__main__":
    # Test OSINT engine
    async def test_osint_engine():
        engine = OSINTEngine()
        
        # Create test target
        target = OSINTTarget(
            target_id="test_domain",
            target_type='domain',
            value="example.com",
            scope_restrictions=['no_personal_info']
        )
        
        # Start operation
        operation = await engine.start_operation(target)
        
        print(f"Operation: {operation.operation_id}")
        print(f"Status: {operation.status}")
        print(f"Results: {len(operation.results)}")
        
        # Generate report
        report = engine.generate_report(operation.operation_id)
        print(f"Report generated with {report['total_results']} results")
    
    asyncio.run(test_osint_engine())
