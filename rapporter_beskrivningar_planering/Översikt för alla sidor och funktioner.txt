Översikt för alla sidor och dess funktioner


Onboarding Wizard – fullständig specifikation
A) Enkel förklaring (för icke‑tekniker)

Onboarding guiden hjälper dig att:

Ange ditt företagsnamn och e‑post för aviseringar.

Ansluta till lokal MySQL (eller annat DB‑val) och automatiskt skapa alla tabeller.

(Valfritt) Starta syntetiska testsajter i Docker så du kan öva utan risk.

Skapa ditt första projekt/källa så du kan börja crawla/scrapa direkt.
Guiden kör hälsokontroller, visar gröna bockar när något funkar, och skickar dig till Dashboard när allt är klart.

B) Detaljerad UI/UX‑spec
0. Förutsättningskontroll (pre‑flight)

Syfte: fångar problem innan du fyller i något.

Visuellt: Tunn “checklist‑banner” högst upp, med 4 punkter och ikon (⏳ → ✅/❌):

Python ≥ 3.11 (hittad/version)

Docker + Docker Compose (hittad/version, Compose V2)

Node.js LTS + npm (hittad/version)

MySQL klientbibliotek (drivrutin installerad server‑sidan)

Tillstånd & UX

Om något saknas: visa länk till snabbguide; “Fortsätt ändå” tillåts men “Testa databasanslutning” inaktiveras tills DB‑drivrutin finns.

Tooltip på varje punkt visar exakt krav och miniversion.

Tillgänglighet (a11y)

aria-live="polite" för uppdaterade statusar.

Ikoner har aria-label (“Python version OK”).

1. Organisationsuppgifter

Fält

Organisationsnamn (text, obligatorisk, max 80 tecken)

E‑post för aviseringar (valfri, valideras mot e‑postregex)

Samtycke till aviseringar (checkbox, valfri, default av)

Mikrokopi (hjälptext)

“E‑posten används för driftlarm (misslyckade jobb, låg proxyhälsa).”

Validering

Tomt orgnamn → röd kant + feltext: “Ange organisationsnamn”.

Felaktig e‑post → “Ogiltig e‑postadress”.

Knappar

Nästa (inaktiverad tills orgnamn giltigt)

Avbryt onboarding (öppnar dialog: bekräfta → återställs/kan återupptas senare)

2. Databasval & anslutning

Radioval

PostgreSQL / MySQL (lokal) / Annan

Default: MySQL (lokal) (enligt din inriktning)

Panel “MySQL‑anslutning” (visas vid MySQL)

Host (text, default 127.0.0.1)

Port (tal, default 3306)

Databas (text, default crawler)

Användare (text, ex root eller crawler)

Lösenord (password, med “visa/dölj”)

SSL (checkbox) → när på: visa SSL‑mode (drop‑down: DISABLED|PREFERRED|REQUIRED|VERIFY_CA|VERIFY_IDENTITY), CA‑cert (filuppladdning)

Avancerat (accordion):

Teckenuppsättning (default utf8mb4) + Collation (default utf8mb4_0900_ai_ci)

Tidszon (default “System/Europe/Stockholm”)

Poolstorlek (default 10) & Idle timeout (sek)

sql_mode (checkboxlista: STRICT_TRANS_TABLES, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSTITUTION – default på: STRICT_TRANS_TABLES, NO_ENGINE_SUBSTITUTION)

Automatiska migrationer (checkbox, default på)

Spara lösenord säkert (checkbox, default på; förklarar att servern krypterar med KMS/nyckel)

Knappar

Testa databasanslutning

Nästa (låst tills test lyckats eller man väljer “Hoppa över” – se policy nedan)

Hoppa över (tillåtet; varning popover: “Utan DB kan inga data sparas”)

Status & feedback

Vid “Testa…” → spinner i knappen + progressrad (“Pingar…”, “Läser version…”, “Testar rättigheter…”).

Positivt: Grön bock + text: “MySQL 8.0.3 upptäckt. Migration redo.”

Negativt: Röd banner över panelen + specifik orsak + åtgärdsförslag:

ECONNREFUSED: “Kontrollera host/port och att MySQL kör.”

AUTH_FAILED: “Fel användare/lösen. Testa “root” lokalt eller skapa dedikerad användare.”

NO_DB: “Databasen ‘crawler’ saknas. Markera ‘Skapa databas’ (checkbox dyker upp vid NO_DB) och testa igen.”

SSL_ERROR: “Ogiltigt certifikat. Välj ‘VERIFY_CA’ och ladda korrekt CA.”

Säkerhet

Lösenord maskeras i UI.

Serverlogg maskerar sekretessfält.

Inga hemligheter skrivs till browserkonsolen.

Tillgänglighet

Alla fält label‑kopplade; Enter triggar “Testa…” när fokus i formulär.

Fel inline med role="alert".

3. Syntetiska testsajter (Docker)

Checkbox: “Starta syntetiska testsajter i Docker” (default på)
Underpanel (visas om på):

Portar (editable):

Statisk lista: 8081

Oändlig scroll (JS): 8082

Formflöde: 8083

Docker nätverk (dropdown, default bridge)

Auto‑fix portar (checkbox): om port upptagen → välj närmaste lediga

Knappar

Starta testsajter

Visa status

Statuskort (3 kolumner, ett per sajt):

Badge: Stopped / Starting / Healthy

Länk: Öppna i ny flik (http://localhost:port)

Hälsoprob: visar senaste GET /healthz med tid + ms

Felhantering

Docker saknas → röd banner: “Docker ej hittad; följ guiden (länk).”

Compose v1 → varning: “Vi rekommenderar Compose V2; fortsätter ändå.”

Portupptaget → gul varning: “8081 upptagen, föreslår 8085” + knapp “Använd 8085”.

Tillgänglighet

Kortens status uppdateras i aria-live="polite".

4. Skapa första projektet (miniformulär)

Fält

Projektnamn (obligatoriskt)

Start‑URL (text; validera som URL)

Renderingspolicy (dropdown: Auto / HTTP / Browser)

Robots/ToS‑läge (checkbox: “Respektera robots.txt” – rekommenderat)

Rate limit (RPS) (nummer, default 1.5)

Geografi (dropdown: SE default)

Skapa crawl‑plan (checkbox; om på: visar miniregler för paginering: “nästa‑selektor” eller query‑param)

Knappar

Testa åtkomst (kör snabb diagnostik)

Skapa projekt

Feedback

Vid test: “200 OK, titel: …, laddtid 480ms” (grön).

Block/403: gul varning med tips (sänk rps, ändra headers, välj Browser).

5. Standardpolicy & sammandrag

Sektion “Defaultinställningar”

Accept‑Language (sv-SE,sv;q=0.9,en;q=0.7)

User‑Agent profil (Desktop/Chrome)

Politeness delay (ms, slumpjitter på)

Consent‑cookie strategi (auto/ignorera – upplysning om juridik)

Dataskydd (retention) (dagar, default 90)

Aviseringar (kritiska fel, ban‑rate tröskel)

Sammandrag

Lista över: Org, DB, Testsajter, Projekt, Policy.

Edit‑länkar till respektive steg.

Knappar

Slutför (primär)

Tillbaka

6. Körning & resultat

Progressvisning (sekventiellt, med retry‑ikon):

Skapa workspace

Verifiera DB‑anslutning

Köra migrationer

Starta testsajter (om valt)

Skapa projekt & crawl‑plan

Spara defaultpolicy

Skapa systemanvändare/API‑nyckel (om kryssat)

Varje delrad visar: ikon, tid, ev. länk till “visa logg”. Fel öppnar “Åtgärda & försök igen”.

Avslut

Stor grön panel: “Allt klart 🎉” + knappar:

Gå till Dashboard

Öppna Projektet

Starta ett första jobb nu

C) Exakta åtgärder, backend, verifiering & tester
Backend‑API (exempel, REST)

POST /api/onboarding/preflight → { python, docker, compose, node, mysql_driver }

POST /api/onboarding/test-db → body: { type, host, port, user, pass, db, ssl, advanced… }

svar: { ok, server: {version, tz, sql_mode}, can_migrate: bool, needs_db_create: bool }

POST /api/onboarding/apply → kör alla steg (idempotent)

svar: { steps: [{name, ok, took_ms, log_id}], final_status }

POST /api/synthetic/start → startar compose + healthcheck

GET /api/synthetic/health → status per sajt + URL

POST /api/projects → skapar projekt

POST /api/crawl-plans → skapar plan

POST /api/policies/defaults → sparar systempolicy

Säkerhet

Lösenord skickas över HTTPS; krypteras server‑sidigt (t.ex. AES‑GCM med server‑nyckel).

“Visa lösenord” i UI påverkar bara fältet, ej logg.

Databas – MySQL parkoppling (garanterad väg)

Driver: mysqlclient eller PyMySQL (rekommenderar mysqlclient för prestanda; fall tillbaka till PyMySQL).
DSN‑format: mysql+mysqlclient://user:pass@host:port/db?charset=utf8mb4
Init‑SQL (vid “Testa”):

SELECT VERSION()    AS server_version;
SELECT @@global.time_zone AS tz, @@sql_mode AS sql_mode;


Skapa DB vid behov:

CREATE DATABASE IF NOT EXISTS `crawler`
  /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */;


Migrationer (Alembic, MySQL‑dialekt):

Körs på “Slutför” om “Automatiska migrationer” är av.

Rollback: per steg; vid fel rullas endast den misslyckade delmigrationen tillbaka, och wizard visar “försök igen”.

Verksamhetsprov (efter körning):

-- 1) Alla kärntabeller ska finnas
SHOW TABLES LIKE 'jobs';
SHOW TABLES LIKE 'extracted_items';

-- 2) Skriv/läs runda
INSERT INTO health_check (ts, note) VALUES (NOW(), 'onboarding_ok');
SELECT COUNT(*) FROM health_check WHERE note='onboarding_ok';

Kommandon för användaren (valfria, för manuell verifiering)

Windows (PowerShell)

# Kolla MySQL server
mysql --host=127.0.0.1 --port=3306 -u root -p -e "SELECT VERSION();"

# Docker & Compose
docker --version
docker compose version

# Starta testsajter manuellt (om UI inte gjort det)
docker compose -f docker/synthetic-sites/docker-compose.yml up -d
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"


macOS/Linux (bash)

mysql -h 127.0.0.1 -P 3306 -u root -p -e "SELECT VERSION();"
docker --version && docker compose version
docker compose -f docker/synthetic-sites/docker-compose.yml up -d


Tolka svar

SELECT VERSION() ger en sträng t.ex. 8.0.34.

docker ps visar tre containrar “healthy”.

Webbläsare: öppna http://localhost:8081, 8082, 8083 → ser testsidor.

Felmatris & åtgärdsförslag (DB)
Felkod	Vad betyder det	UI‑meddelande	Föreslagen åtgärd
ECONNREFUSED	Port stängd / server nere	“Kunde inte ansluta till 127.0.0.1:3306”	Starta MySQL, kontrollera brandvägg, rätt port
ER_ACCESS_DENIED_ERROR	Fel användare/lösenord	“Autentisering misslyckades”	Verifiera creds; testa root lokalt
NO_DB	Databas saknas	“Databas ‘crawler’ saknas”	Bocka “Skapa databas” och försök igen
SSL_ERROR	Certifikatproblem	“SSL‑fel: verifiering misslyckades”	Byt SSL‑mode till VERIFY_CA och ladda korrekt CA
MODE_MISMATCH	sql_mode inkompatibel	“sql_mode saknar STRICT…”	Låt wizarden lägga till STRICT_TRANS_TABLES
UX‑detaljer som maximerar användbarhet

Autospara varje steg till servern (så onboarding kan återupptas).

Skelettladdning (shimmer) för statuskort; inga hopp i layout.

Primärknappen alltid på samma plats (höger) → “Nästa” → “Slutför”.

Klart‑signaler: Grön bock + kort sammanfattning per del.

Guidade fel: In‑place åtgärdsförslag + “Prova igen”.

Tillgänglighet: Fullt tangentbordsstöd (Tab‑ordning), aria-describedby för fel.

I18n: alla texter via i18n/sv-SE.yml; fallback en-US.

Acceptanskriterier (DoD)

Onboarding kan slutföras med MySQL lokalt → tabeller skapade, Dashboard laddas.

“Testa databasanslutning” visar exakt felorsak och förslag.

Syntetiska sajter kan startas/stoppas, och UI visar Healthy + klickbara länkar.

Första projektet skapas och syns i Projektlistan.

Avbryter man i steg 3 och återkommer, återupptas i rätt steg med sparade värden.

Inga hemligheter loggas i klientlogg; serverlogg maskerar.

Skärmläsare (NVDA/VoiceOver) kan annonsera fel och statusbyten.

E2E‑test (Playwright) täcker: lyckad väg, DB‑fel, Docker‑saknas, portkrock, återupptag.

E2E‑testfall (Playwright, kortfattat)

TC‑001 Lyckad onboarding MySQL + testsajter + projekt → landar på Dashboard, tre services Healthy.

TC‑002 Fel lösenord → UI visar AUTH_FAILED, åtgärd ger OK.

TC‑003 Docker ej installerat → varning, men onboarding kan slutföras utan testsajter.

TC‑004 Port 8081 upptagen → “Auto‑fix” väljer 8085; status Healthy.

TC‑005 Avbryt i steg 2, återöppna app → wizard hoppar direkt till steg 2 med värden kvar.

TC‑006 Migration fel (simulerad) → wizard erbjuder “Visa logg”, “Försök igen”; efter fix blir grön.

Minimal datamodell (server) för onboarding state

onboarding_state

id (singleton), step (int), org_name, notify_email,

db_config (json, krypterat password),

synthetic_config (json),

first_project (json),

created_at, updated_at, completed_at.

Loggning & spårbarhet

Audit event skrivs för: test‑db (utan hemligheter), kör migration, start synthetic, skapa projekt/policy.

Korrelation‑ID följer hela onboarding‑körningen i logg.

D) Snabb “hur kontrollerar jag att det fungerar?”

Efter “Testa databasanslutning”

Du ser “MySQL X.Y.Z” + grön bock.

Kör (frivilligt) i terminal:

mysql -h 127.0.0.1 -P 3306 -u <user> -p -e "SELECT VERSION();"


Efter “Starta testsajter”

Tre kort visar Healthy.

Öppna http://localhost:8081 (statisk), :8082 (infinite scroll), :8083 (formflöde).

Efter “Slutför”

Du landar på Dashboard.

I Inställningar → Databaser står: “Ansluten: MySQL … Migration: head”.

I DB:

SELECT COUNT(*) FROM jobs; -- ska ge ≥ 0 utan fel

E) Checklista (allt som nu finns med)

 Alla fält/knappar från din ursprungliga lista.

 Pre‑flight kontroller & versionskrav.

 Avancerade MySQL‑inställningar (charset, collation, sql_mode, pool).

 SSL‑lägen & certifikatuppladdning.

 Felhantering med konkreta åtgärdsförslag.

 Syntetiska sajter med hälso‑kort, port‑auto‑fix och direkta länkar.

 Första projektet med miniplan och åtkomsttest.

 Defaultpolicy (Accept‑Language, UA, politeness, retention, aviseringar).

 Sekventiell “apply” med per‑steg logg + retry.

 Säker sekretesshantering (maskning, kryptering).

 Återupptagbar onboarding (autospara).

 Tillgänglighet, i18n, keyboard‑navigering.

 Acceptanskriterier & e2e‑testfall.

 Garanterad parkoppling till lokal MySQL inkl. migrationsväg och manuella verifieringar.










2) Dashboard / Hem – komplett specifikation
A) Enkel förklaring (för icke‑tekniker)

Dashboarden är “hemmet” där du ser hur systemet mår just nu:

vilka jobb som kör,

hur många fel som skett nyligen,

hur mycket data som produceras,

hur proxypoolen mår (snabb/långsam, felprocent),

vilka scheman (planerade körningar) som snart startar,

och aviseringar som kräver din uppmärksamhet.

Du kan starta nya jobb, skapa mallar och källor, samt klicka vidare in på detaljer för att felsöka.

B) Detaljerad UI/UX‑spec
Layout & navigation

Filterrad (överst): Tidsspann, Team, Källa/Projekt, Jobbtyp, Status, Miljö (dev/stage/prod), snabbval (Senaste 15 min/1 h/24 h/7 d), manuellt datumintervall (med tidszon Europe/Stockholm).

Knapp: “Spara vy” (sparar val + widgetordning per användare), “Dela vy” (länk med query‑params).

Widget‑grid (12‑kolumn rutnät) med drag‑&‑släpp för att arrangera kort.

Alla kort har: titel, uppdaterad‑för‑X‑sek sedan, uppdatera‑ikon, “• • •” meny (export/öppna i ny flik/ta skärmdump).

Tomt tillstånd (om inget jobb/ingen data): vänliga CTA‑knappar “Nytt jobb”, “Skapa första mall”, “Lägg till datakälla”.

Realtidsuppdatering

WebSocket push (1–5 s).

Fallback till polling: sammanfattning cachead i 15–60 s (inställning).

Flik inaktiv > 60 s → autopaus av realtid (sänker nätverk/CPU), stor grå “Pausad” badge i varje kort; “Fortsätt uppdatera” återaktiverar.

Tillgänglighet (A11y)

Tangentbordsnavigering via Tab/Shift+Tab; Enter aktiverar primäråtgärd i fokus.

Live‑områden (aria-live="polite") för KPI‑nummer & statuschips.

Färg + ikon + text för status (inte enbart färg).

Alla grafer har tabell‑alternativ (”Visa som tabell”).

Widget 1: Aktiva jobb

Syfte: Se alla pågående jobb, deras progress, ETA, ägare samt agera snabbt.

Innehåll

Tabellkolumner:

Jobbnamn (länk → Jobbdetaljer)

Typ (Crawl / Crawl+Scrape / Scrape / Export)

Källa/Projekt (chips, fler‑val)

Statuschip (Pending/Running/Paused/Degraded/Retrying)

Progress (procent + “x/y URL:er”)

ETA (beräknad, t.ex. “12m”)

Startad (relativ + tooltip exakt tid)

Ägare (avatar + namn)

Workers (antal)

Renderingspolicy (Auto/HTTP/Browser)

Proxyprofil (Auto/Sticky/Geo‑SE …)

Radåtgärder (ikonknappar)

Pausa / Återuppta

Skala (‑1/+1 worker)

Öppna loggar (sidopanel med tail, filtrerbar)

Avsluta (med bekräftelse)

Öppna i Jobbdetaljer

Filter & sort

Sökfält över tabellen (namn, id).

Sortera på startad, ETA, progress, status.

Paginering med “visa 10/25/50”.

States

Loading (skeleton) 3 skelett‑rader.

Tomt: “Inga aktiva jobb” + “Starta nytt jobb”.

Fel: röd banderoll “Kunde inte läsa jobblistan” + “Försök igen”.

Widget 2: Feltrender (senaste 24 h)

Syfte: Snabb överblick av fel (per klass) över tid.

Innehåll

Mini‑linjediagram (stackad eller multi‑serie) med bucket‑storlek auto (1m/5m/15m).

Serier: Transient (tidsouts/nät), Policy (403/429 m.m.), Permanent (404/410).

Interaktioner

Hover → tooltip (tid, klass, antal)

Penselmarkering → zooma intervall

Klick på legendpunkt → visa/dölj serie

Länk: “Öppna felanalys” (leder till DQ/Analys‑sida med förfyllda filter)

States

Tom data → grå text: “Inga fel i valt intervall”.

Widget 3: Dataproduktion

Syfte: Mängd och takt på extraherad data.

Innehåll

KPI‑kort:

Totalt extraherat (i filterintervall)

Takt (1‑min medel) (items/min)

Validerade OK vs Karantän (med procent)

Mini‑barserie: items/min per 5 min bucket

Topp 5 mallar (lista): mallnamn, bidrag %, länk till mallversion

Interaktioner

Klick på mall → förfiltrera Datalager på den mallen i samma intervall.

Widget 4: Proxyhälsa

Syfte: Upstream‑nätverkets kondition.

Innehåll

Latency p50/p95 (ms)

Fail‑rate (%) (misslyckade förfrågningar p.g.a. nät/block)

Poolstatus: antal aktiva proxies / svartlistade senaste 1 h

Top 5 instabila endpoints: endpoint, geo, fail‑rate, senaste felkod

Åtgärder

Svartlista endpoint (med anledning)

Validera nu (kickar ett snabbtestjobb)

Öppna Proxy‑panel (full sida)

States

Grön/gul/röd färgkod baserat på trösklar (konfig i Policies).

Tooltip för tröskelvärden.

Widget 5: Kommande scheman

Syfte: Se vad som startar snart.

Innehåll

Lista (kommande 24–72 h):

Tid (lokal, Europe/Stockholm)

Jobbmall (preset), Källa, Typ

Nästa körning + repetition (CRON‑etikett)

Åtgärder

Kör nu

Skippa nästa

Redigera schema (öppnar Scheduler-sidan)

Pausa schema

Widget 6: Aviseringar

Syfte: Händelser som kräver uppmärksamhet.

Innehåll

Lista (senaste 50): tid, severity (Info/Warning/Critical), källa (job, proxy, policy), text, länk

Filter inne i kortet: severity, källa

Åtgärder

Kvittera (acknowledge)

Tysta (mute 1 h/24 h)

Skapa runbook (förifylld mall)

Globala komponenter

Snabbknappar (höger topp):

Nytt jobb → Job Launcher

Ny mall → Template Wizard

Ny datakälla → Projekt/Källor

Proxy‑panel → Proxy & Nätverk

Global sök (Cmd/Ctrl+K): jumpa till jobb/mall/projekt genom att skriva namn/id.

Export i varje kort: CSV/JSON och PNG (för grafer).

Microcopy & visuella riktlinjer

Konsistenta statuschips:

Running (blå), Paused (grå), Degraded (orange), Failed (röd), Completed (grön).

Alla tider visas relativt + tooltip absolut med datum/tid i Europe/Stockholm.

Tomt tillstånd beskriver vad du kan göra härnäst (CTA).

Prestanda & robusthet

Dashboard “time‑to‑interactive” ≤ 1.5 s på normalt dataset.

Datatabeller använder virtuell scroll vid > 200 rader.

WebSocket auto‑reconnect med jitter; fallback till polling.

Alla kort isolerar fel (ett korts fel får inte krascha hela sidan).

Säkerhet & roller

RBAC:

Läsare: ser allt, inga åtgärdsknappar.

Operatör: paus/återuppta/skalning på jobb.

Admin: alla åtgärder + schemaändringar.

Knappar visas/inaktiveras efter roll och context (t.ex. “Avsluta” döljs för Läsare).

C) Exakta kommandon & kontrakt (backend/API/SQL/Verifiering)

Jag antar en REST‑stil + WebSocket. Anropa med Authorization: Bearer <token> där relevant.

1. Sammanfattning (allt i ett)

Endpoint

GET /api/dashboard/summary?from=2025-08-21T08:00:00Z&to=2025-08-21T10:00:00Z
                       &team=core&project_id=123&env=dev


Svar (exempel)

{
  "filters": { "from":"2025-08-21T08:00:00Z","to":"2025-08-21T10:00:00Z","team":"core","project_id":123,"env":"dev" },
  "now":"2025-08-21T10:00:12Z",
  "active_jobs": [
    {"id":"job_901","name":"Crawl Volvo","type":"crawl","project":"Vehicles","status":"running","progress":0.42,"eta_sec":720,"started_at":"2025-08-21T09:40:00Z","owner":"elin","workers":3,"rendering":"auto","proxy_profile":"geo-se"},
    {"id":"job_902","name":"Scrape Owners","type":"scrape","project":"Owners","status":"paused","progress":0.77,"eta_sec":3600,"started_at":"2025-08-21T09:10:00Z","owner":"amir","workers":2,"rendering":"browser","proxy_profile":"sticky"}
  ],
  "errors_timeseries": {
    "bucket_sec": 300,
    "series": {
      "transient":[["2025-08-21T09:00:00Z",3],["2025-08-21T09:05:00Z",2]],
      "policy":[["2025-08-21T09:00:00Z",1],["2025-08-21T09:05:00Z",1]],
      "permanent":[["2025-08-21T09:00:00Z",0],["2025-08-21T09:05:00Z",1]]
    }
  },
  "production": {
    "total": 18420,
    "rate_per_min": 142,
    "validated_ok": 17850,
    "quarantine": 570,
    "by_template":[{"template":"vehicle_detail_v1","count":8200},{"template":"owner_v2","count":6200}]
  },
  "proxy_health":{
    "latency_ms":{"p50":220,"p95":840},
    "fail_rate":0.023,
    "active_endpoints":342,
    "blacklisted_last_hour":5,
    "top_unstable":[
      {"endpoint":"se.resi.12","geo":"SE","fail_rate":0.12,"last_error":"429"},
      {"endpoint":"fi.resi.07","geo":"FI","fail_rate":0.09,"last_error":"timeout"}
    ]
  },
  "upcoming_schedules":[
    {"id":"sched_77","name":"Nightly Crawl","when":"2025-08-21T22:00:00+02:00","job_preset":"crawl+scrape","project":"Vehicles","repeat":"0 22 * * *"},
    {"id":"sched_80","name":"Owners incremental","when":"2025-08-21T11:00:00+02:00","job_preset":"scrape","project":"Owners","repeat":"@hourly"}
  ],
  "alerts":[
    {"id":"al_1","ts":"2025-08-21T09:58:00Z","severity":"warning","source":"proxy","message":"Fail-rate > 5% on pool se-resi"},
    {"id":"al_2","ts":"2025-08-21T09:30:00Z","severity":"critical","source":"job:job_901","message":"Error spike (policy) > 20%"}
  ],
  "ttl_sec": 30
}


Kommandon (verifiera med curl)

# Hämta sammanfattning 1h bakåt:
SINCE=$(date -u +"%Y-%m-%dT%H:%M:00Z" -d "-1 hour")
NOW=$(date -u +"%Y-%m-%dT%H:%M:00Z")
curl -s "http://localhost:8000/api/dashboard/summary?from=$SINCE&to=$NOW" | jq .


Vad som ska hända

JSON returneras inom < 300 ms (med cache), nycklar enligt ovan.

UI visar siffror, grafer och listor baserat på svaret.

Hur du kontrollerar resultatet

Siffror i Dataproduktion matchar SQL‑räkning (se MySQL‑sektionen nedan).

“Aktiva jobb” matchar jobs.status IN ('running','paused','pending').

2. WebSocket för realtid

Endpoint

GET /ws/dashboard?project_id=123


Meddelanden (exempel)

{ "type":"job.updated", "job_id":"job_901", "status":"running", "progress":0.44, "eta_sec":690 }
{ "type":"metric.bump", "metric":"production.rate_per_min", "value":151, "ts":"2025-08-21T09:59:00Z" }
{ "type":"alert.new", "id":"al_3", "severity":"critical", "message":"p95 > 2s", "ts":"2025-08-21T09:59:10Z" }


Kommandon (snabbt test med websocat)

websocat ws://localhost:8000/ws/dashboard


Förväntat

Meddelanden kommer när jobb uppdateras/alerts skapas.

UI uppdaterar rader och KPI:er utan full reload.

3. Åtgärds‑endpoints (exempel)
POST /api/jobs/{id}/pause
POST /api/jobs/{id}/resume
POST /api/jobs/{id}/scale { "delta": +1 }
POST /api/proxies/{endpoint}/blacklist { "reason":"high fail rate" }
POST /api/schedules/{id}/run-now
POST /api/alerts/{id}/ack
POST /api/alerts/{id}/mute { "duration":"1h" }


Kommandon (curl)

curl -X POST http://localhost:8000/api/jobs/job_901/pause
curl -X POST http://localhost:8000/api/proxies/se.resi.12/blacklist -H "Content-Type: application/json" -d '{"reason":"error rate"}'


Verifiering

Jobbstatus ändras i Aktiva jobb på sekunder.

Proxy försvinner från listan “aktiva” och dyker upp i svartlist‑historik.

4. MySQL – vyer & frågor (garanterad koppling)

Nedan SQL fungerar mot lokal MySQL och stödjer dashboardens datapunkter.

Index (prestanda)

CREATE INDEX IF NOT EXISTS idx_jobs_status ON jobs(status);
CREATE INDEX IF NOT EXISTS idx_jobs_started_at ON jobs(started_at);
CREATE INDEX IF NOT EXISTS idx_items_created_at ON extracted_items(created_at);
CREATE INDEX IF NOT EXISTS idx_job_logs_ts ON job_logs(ts);
CREATE INDEX IF NOT EXISTS idx_job_logs_class ON job_logs(error_class);


Feltrender (aggregering i 5‑min buckets)

SELECT
  FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(ts)/300)*300) AS bucket,
  error_class,
  COUNT(*) AS cnt
FROM job_logs
WHERE ts BETWEEN @from AND @to
GROUP BY bucket, error_class
ORDER BY bucket ASC;


Dataproduktion (antal & takt)

-- total i intervallet
SELECT COUNT(*) AS total
FROM extracted_items
WHERE created_at BETWEEN @from AND @to;

-- takt per minut sista 5 min
SELECT COUNT(*)/5.0 AS rate_per_min
FROM extracted_items
WHERE created_at >= NOW() - INTERVAL 5 MINUTE;

-- validerade OK vs karantän
SELECT
  SUM(CASE WHEN dq_status='ok' THEN 1 ELSE 0 END) AS validated_ok,
  SUM(CASE WHEN dq_status='quarantine' THEN 1 ELSE 0 END) AS quarantine
FROM extracted_items
WHERE created_at BETWEEN @from AND @to;

-- toppmallar
SELECT template_id, COUNT(*) AS cnt
FROM extracted_items
WHERE created_at BETWEEN @from AND @to
GROUP BY template_id
ORDER BY cnt DESC
LIMIT 5;


Proxyhälsa

-- latency percentiler ungefärligt (MySQL 8: använd window functions om ni lagrar alla mätningar)
-- här exempelvis p95 via approx-tabell 'proxy_metrics' (preagg)
SELECT p50_ms, p95_ms, fail_rate, active_endpoints, blacklisted_last_hour
FROM proxy_metrics
WHERE ts = (SELECT MAX(ts) FROM proxy_metrics);

-- topp instabila
SELECT endpoint, geo, fail_rate, last_error
FROM proxy_endpoints
ORDER BY fail_rate DESC
LIMIT 5;


Kommande scheman

SELECT id, name, next_run_at, job_preset, project
FROM schedules
WHERE next_run_at BETWEEN NOW() AND NOW() + INTERVAL 3 DAY
ORDER BY next_run_at ASC
LIMIT 50;


Aviseringar

SELECT id, ts, severity, source, message
FROM alerts
WHERE ts >= NOW() - INTERVAL 24 HOUR
ORDER BY ts DESC
LIMIT 50;


Kommandon (kör och jämför med UI)

SET @from = NOW() - INTERVAL 1 HOUR;
SET @to   = NOW();
-- Kör frågorna ovan och jämför värden mot dashboarden.


Vad som ska hända

Siffror i UI ≈ resultat från SQL (små avvikelser kan finnas p.g.a. cache 15–60 s).

När nya poster skrivs till extracted_items ser du “Dataproduktion” ticka upp.

5. Export från widgets

Kommandon (curl)

# Exportera feltrender som CSV
curl -s "http://localhost:8000/api/metrics/errors.csv?from=$SINCE&to=$NOW&bucket=300" -o errors.csv

# Exportera aktiva jobb som JSON
curl -s "http://localhost:8000/api/jobs?status=running" -o active_jobs.json


Verifiering

Fil finns på disk, öppningsbar i Excel/valfri editor; rader matchar vyn.

D) Acceptanskriterier, testfall & edge cases
Definition of Done (funktionalitet)

Dashboard laddar < 1.5 s (kall cache < 2.5 s) med standarddata.

WebSocket uppdaterar Aktiva jobb, Dataproduktion och Aviseringar i realtid; polling fallback fungerar.

Varje widget har Loading, Tomt och Fel‑tillstånd.

Filterrad påverkar alla widgets konsekvent; “Spara vy” fungerar per användare; “Dela vy” återställer filtret.

RBAC gömmer/avaktiverar åtgärder som användaren ej får utföra.

Export (CSV/JSON/PNG) fungerar för alla widgets.

Alla tider visas i Europe/Stockholm i UI (tooltip visar UTC).

MySQL queries reproducerar dashboardvärden (± cache).

E2E‑testfall (Playwright)

TC‑DASH‑01: Ladda dashboard → skeleton → data visas; filter “Senaste 1 h” aktivt.

TC‑DASH‑02: Starta jobb (via Job Launcher) → Aktiva jobb visar raden inom 2 s.

TC‑DASH‑03: Stoppa webb‑socket server → dashboard växlar till polling; data fortsätter uppdateras.

TC‑DASH‑04: Roll “Läsare” ser inga åtgärdsknappar i “Aktiva jobb”.

TC‑DASH‑05: “Proxyhälsa” visar röd status när fail‑rate > tröskel; kvittera alert → försvinner från listan.

TC‑DASH‑06: “Spara vy” → logga ut/in → layout och filter återställs.

TC‑DASH‑07: Öppna “Feltrender” → klicka “Visa som tabell” → exportera CSV → fil innehåller rätt buckets.

TC‑DASH‑08: Filter “Projekt=Vehicles” påverkar alla widgets; “Kommande scheman” visar bara relevanta.

Edge cases

Massiva datamängder: tabell‑virtualisering, server‑paginering, tidsintervall begränsas.

Klockdrift: backend sätter now i svaret; UI beräknar relativa tider utifrån detta.

Partial failures: om Proxyhälsa‑API faller, bara det kortet visar fel; andra kort fungerar.

Inga proxies: Proxyhälsa kort → “Ingen proxypool konfigurerad” + länk “Skapa pool”.

Extra: UX‑polish som gör skillnad

Inline‑kommandon i “Aktiva jobb”: håll mus över “Workers”‐cellen → små +/‑ knappar visas.

Kopiera‑till‑urklipp ikon bredvid jobbid/templateid.

Animerad uppdatering: KPI‑tal räknar mjukt uppåt/nedåt.

Färgblindvänligt tema: alternativ färgpalett i profilmenyn.

Om‑layout på mobil: widgets staplas; aggregation minskar granulat.









3) Datalager / Katalog
A) Enkel förklaring (icke‑tekniker)

Här ser du alla extraherade dataposter. Du kan:

Söka och filtrera (t.ex. vilka poster som kom från en viss källa/mall eller skapades ett visst datum),

Förhandsvisa innehållet, se var det kom ifrån (jobb, URL, policy),

se datakvalitet (DQ), varför något hamnat i karantän,

exportera ett urval till fil eller annan destination,

och radera data enligt integritetspolicy.

B) Detaljerad UI/UX‑spec
B.1 Sidlayout & navigation

Toppfilterrad (left→right):

Sök (fri text; mot fältvärden, id, url)

Källa/Projekt (multi‑select)

Mall (multi‑select; visar namn (version) med pill‑badges)

Taggar (multi‑select; fritext + autosuggest)

Status (checkbox‑grupp): validerad, karantän, tombstone (raderad)

Datumintervall (snabbval 24h/7d/anpassat; lokaltid Europe/Stockholm)

Avancerat (accordion): “Har bilaga/snapshot”, “DQ‑regel matchar …”, “Minimal fältfyllnad %”

Återställ filter (ikon)

Huvudområde:

Resultattabell (vänster, responsiv) med server‑paginering

Sidofält (höger, två flikar): Linage/Proveniens och DQ

Verktygsrad ovan tabellen:

Bulk‑välj (checkbox i rubrik)

Exportera urval

Flagga/karantän (bulk)

Radera enligt policy (bulk)

Visa/ändra kolumner (kolumnväljare)

Visa som kort / tabell (toggle)

B.2 Resultattabell (server‑paginering)

Kolumner (default):

id (kort hash/nummer; kopiera‑ikon)

mall (namn + versionchip)

Fältpreview (de 3 viktigaste fälten enligt mallens prioritet; t.ex. title, reg_number, date)

status (chip: validerad = grön, karantän = orange, tombstone = grå)

skapad_tid (relativ tid + tooltip exakt)

Sortering: på skapad_tid (default desc), mall, status.

Paginering: 25 / 50 / 100 per sida + “Gå till sida …”.

Radhovring: visar quick‑actions:

Öppna post (detaljvy i modal eller ny sida)

Flagga/karantän

Radera (soft‑delete/tombstone; med bekräftelse)

Tomt tillstånd: “Inga poster matchar dina filter – prova att tömma sök eller ändra datum”.

B.3 Sidofält – “Linage/Proveniens”

Visas när en rad markeras:

Rubrik: “Proveniens för id”

Innehåll:

Jobb: id + länk till Jobbdetaljer + typ (Crawl/Scrape/…)

Källa/Projekt (namn)

URL (klickbar, öppnas i ny flik)

Mall (namn + version)

Policyprofil (namn + id)

Renderingsläge som användes (HTTP/Browser)

Proxyendpoint (om loggat), geo, UA‑profil

Snapshot:

“Visa HTML snapshot” (ny flik eller embedded viewer)

“Visa skärmdump” (om finns)

Tidslinje: skapad → validerad → ev. export → ev. radering

Åtgärder: “Kopiera härkomst som JSON”, “Öppna i Browserpanel” (för att återskapa vy, om möjligt)

B.4 Sidofält – “DQ (Data Quality)”

Valideringsregler som körts (lista; namn, regeltyp, resultat ✓/✗, tid)

Felorsaker (om karantän): regel → beskrivning → felvärde → förslag

Fälttäckning: % fält med data (progressbar)

Åtgärder:

“Markera som validerad” (om felet är manuellt åtgärdat)

“Lägg till kommentar/etikett”

“Öppna felposter med samma regel” (länk till förfiltrerad vy)

B.5 Detaljvy (modal eller separat sida)

Flikar:

Data (formatterad JSON + fältnamn som rubriker; kopiera/expandera)

Råkälla (HTML snapshot i viewer + “Hämta som .html”)

Bild(er) (om skärmdump/bilagor finns)

Härkomst (samma som sidofält, men större)

Ändringshistorik (statusbyten, kommentarer, exporthändelser)

Snabbknappar: “Exportera denna post”, “Radera (tombstone)”, “Öppna relaterade poster” (samma item_key i annan körning)

B.6 Statushantering

Validerad: passerat alla blockerande regler; exportbar.

Karantän: blockerande DQ‑regel slog; exkluderas från “OK” exportprofiler.

Tombstone: mjuk radering (behåller audit/diff), visas endast om “visa raderade” är på.

B.7 Exportflöde (urval)

Exportera urval öppnar dialog:

Format: CSV / JSON / Parquet / DB‑tabell / Webhook

Fältschema: välj kolumner, alias, ordning

Filuppdelning: max rader/fil

Destination: lokal fil (nedladdning) / lagring / DB‑tabell (MySQL)

Postfilter: endast validerad (default) / inkludera karantän (checkbox)

Starta export → skapar Export‑jobb (asynkront, länk till Exporthistorik)

Exportprogress: liten toaster + badge i toppnavigering.

B.8 Radera enligt policy (bulk)

Öppnar dialog: “Bekräfta radering” + visar policytext (retention, tombstone)

Alternativ: tombstone (soft), permanent (om policy tillåter, kräver Admin)

Kräver bekräftelse (“Skriv RADERA”)

Körs asynkront; progress i notifieringar.

B.9 Tillgänglighet & UX‑polish

Tab‑navigering genom tabell; Enter öppnar detalj.

“Visa som tabell/kort”: kortläge visar 6–8 nyckelfält per post.

“Visa som tabell” → “Visa som tabell (kompakt)” (täta rader).

Kolumnväljare sparas per användare/vy.

Snabbfilterchips under sök: status:karantän, mall:vehicle_detail_v1 etc.

C) Kommandon (curl/SQL) – körbara exempel
C.1 Lista poster (med server‑paginering)
# 25 senaste, endast validerade, mall=vehicle_detail_v1, projekt=12
curl -s "http://localhost:8000/api/items?project_id=12&template=vehicle_detail_v1&status=validated&limit=25&offset=0&sort=created_at:desc" | jq

C.2 Fri textsök
# Sök efter "Volvo" i fältvärden och url, 7 dagar bakåt
FROM=$(date -u -d "-7 days" +"%Y-%m-%dT%H:%M:%SZ")
TO=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
curl -s "http://localhost:8000/api/items/search?q=Volvo&from=$FROM&to=$TO" | jq

C.3 Öppna en post (detalj)
curl -s "http://localhost:8000/api/items/it_123456" | jq

C.4 Flagga/karantän (enstaka)
curl -s -X POST "http://localhost:8000/api/items/it_123456/quarantine" \
  -H "Content-Type: application/json" \
  -d '{"reason":"missing_reg_number","note":"manuell granskning"}' | jq

C.5 Exportera urval (starta exportjobb)
curl -s -X POST "http://localhost:8000/api/exports" \
  -H "Content-Type: application/json" \
  -d '{
    "format":"csv",
    "filter":{"project_id":12,"status":["validated"],"template":["vehicle_detail_v1"]},
    "columns":["id","payload.reg_number","payload.title","created_at"],
    "destination":{"type":"file","path":"exports/vehicles.csv"},
    "split":{"max_rows":500000}
  }' | jq

C.6 Radera enligt policy (bulk – tombstone)
curl -s -X POST "http://localhost:8000/api/items/bulk-delete" \
  -H "Content-Type: application/json" \
  -d '{"filter":{"project_id":12,"status":["quarantine"]}, "mode":"tombstone"}' | jq

D) Vad som händer (backend & DB)
D.1 Sök & filtrering

Server‑paginering: limit/offset (eller cursor) mot MySQL.

Fri text: fulltextsökning på uppmappade fält (payload_json → genererade “sök‑kolumner”), url, item_key.

Filter: byggs till SQL‑villkor; tidsfilter mot created_at.

D.2 MySQL‑schema (relevant)

extracted_items(id, job_id, project_id, template_id, template_version, item_key, payload_json, status ENUM('validated','quarantine','tombstone'), created_at, snapshot_path, screenshot_path, url, policy_id, render_mode, proxy_endpoint, ua_profile, tags JSON)

dq_violations(id, item_id, rule, message, field, created_at)

jobs(id, type, project_id, status, started_at, finished_at, …)

templates(id, name, version, …)

policies(id, name, …)

exports(id, filter_json, status, path, created_at, finished_at, …)

D.3 Index (prestanda)
CREATE INDEX IF NOT EXISTS idx_items_created ON extracted_items(created_at);
CREATE INDEX IF NOT EXISTS idx_items_status ON extracted_items(status);
CREATE INDEX IF NOT EXISTS idx_items_project ON extracted_items(project_id, created_at);
CREATE INDEX IF NOT EXISTS idx_items_template ON extracted_items(template_id, template_version, created_at);
CREATE INDEX IF NOT EXISTS idx_items_url ON extracted_items(url(191));
-- Valfritt: generera sökbara kolumner (t.ex. reg_number) och indexera dem

D.4 Exportjobb

Skapas i exports med status pending → worker plockar → skriver fil/DB → status completed + checksumma.

D.5 Radering

Tombstone: sätter status='tombstone' + skriver audit_event.

Permanent (om policy tillåter): raderar rad + skriver tombstone‑rad i audit (utan payload).

E) Verifiering (så kontrollerar du att allt stämmer)
E.1 Antal rader matchar filter
-- Räkna i DB vad UI visar
SELECT COUNT(*) 
FROM extracted_items 
WHERE project_id=12 AND status='validated'
  AND created_at BETWEEN NOW() - INTERVAL 7 DAY AND NOW();


Stäm av mot radsiffror i UI (ta hänsyn till vald paginering).

E.2 Export i Exporthistorik
SELECT id, status, path FROM exports ORDER BY created_at DESC LIMIT 5;


Förväntat: ditt exportjobb finns med completed, path pekar på filen; UI visar samma rad.

E.3 DQ‑orsak (karantän)
SELECT item_id, rule, message 
FROM dq_violations 
WHERE item_id='it_123456';


Förväntat: samma regel & text syns i sidofältet “DQ”.

F) Acceptanskriterier & E2E‑testfall
DoD – funktion

Sök/filtrering returnerar resultat på < 500 ms för 1M+ rader (med index).

Server‑paginering konsekvent; sortering stabil.

Öppna post visar data, snapshot/screenshot‑knappar och full proveniens.

DQ‑flik listar regler, orsak(er) och ger åtgärder.

Exportera urval startar jobb, visas i Exporthistorik, filen laddas ner/lagras.

Radera enligt policy uppdaterar status eller raderar; audit skrivs.

RBAC: Läsare kan inte radera/flagga; Operatör kan; Admin kan permanent‑radera.

Tillgänglighet: alla kontrollers etiketter, tab‑order korrekt; “Visa som tabell”.

E2E (Playwright – kort)

TC‑DATA‑01: Filtrera på projekt, mall, 24h → tabell visar rätt rader (stäm av counts).

TC‑DATA‑02: Öppna post → Data/Proveniens/DQ flikar laddar; snapshot kan öppnas.

TC‑DATA‑03: Sätt karantän → statuschip ändras; dq_violations får rad.

TC‑DATA‑04: Exportera urval → exportjobb “running → completed”; fil kan öppnas; radräkning stämmer.

TC‑DATA‑05: Tombstone bulk → status uppdateras; “visa raderade” krävs för att se dem.

TC‑DATA‑06: Läsare‑roll saknar raderingsknapp.

4) Källor / Projekt
A) Enkel förklaring (icke‑tekniker)

Här skapar och hanterar du dina datakällor (webbplatser). Du anger:

startadresser,

om inloggning krävs,

var i världen du vill framstå som (geografi),

hur fort vi får gå (rate‑limits),

och hur vi ska läsa sidorna (rendering, headers, språk, cookie‑samtycke).

Du kan testa åtkomst (diagnostik), generera en crawl‑plan/sitemap, och direkt starta ett jobb.

B) Detaljerad UI/UX‑spec
B.1 Formulärfält (med validering)

Projektnamn (text, obligatoriskt, unik per konto; max 100 tecken)

Beskrivning (långtext, valfri)

Domän(er) (lista med chip‑inmatning; normaliseras utan http(s)://; validering mot punycode)

Start‑URL:er (lista; måste vara http(s) och tillhöra angivna domäner; dedup)

Behörighet / Inloggning

Typ: ingen / sessionscookie / grundläggande

För sessionscookie: fält för cookie‑namn + värde; utgångstid; krypterad lagring

För grundläggande: användare/lösenord (maskeras; krypterad lagring)

Testa inloggning (knapp, visar 200/401 och ev. redirect)

Region/Geo‑preferens (dropdown; default SE; multi‑val OK med prioritet)

Robots/ToS‑läge

Respektera (default)

Kräv manuellt godkännande per domän (checkboxlista “jag har läst och förstått”)

Rate‑limit per domän (tabell: domän → RPS, burst, min_delay_ms, jitter_ms)

Förifyllt “default”‑rad som gäller alla listade domäner.

Crawl‑regler

Djup (heltal; -1 = obegränsat)

Max‑sidor (heltal; säkring)

Uppföljningsregler

Inkludera‑regex (lista)

Exkludera‑regex (lista)

Begränsa till subdomäner (checkbox)

Paginering: nästa‑selector (CSS/XPath) eller query‑param mönster (page=\d+)

Renderingspolicy

auto (heuristik) / http‑endast / browser

Timeout (ms), väntestrategi (load/networkidle/selector), blockera icke‑kritiska resurser (checkbox)

Headers‑profil

Klientprofil: desktop/mobil

Språk: sv-SE,sv;q=0.9,en;q=0.7 (default)

Referer‑policy: auto/explicit (fält)

Consent‑strategi

Cookie‑samtycke: tillåt/kräv (visa att cookie sätts innan hämtning om policy kräver)

Taggar (chiplista; används i filter/rapporter)

B.2 Knappar & åtgärder

Spara (primär) – skapar/uppdaterar projektet

Testa åtkomst – kör diagnostik mot 1–3 slumpade start‑URL:er

Generera sitemap – bygger ”Crawl Plan” (öppnar sida 6 med förifyllt)

Skapa jobb – öppnar Job Launcher (sida 7) med projekt valt

Klona projekt – duplicerar inställningar (utan hemligheter)

Arkivera projekt – sätter archived=true (döljs i listor)

B.3 Diagnostik (återkoppling i UI)

Ping varje domän (DNS + HTTPS) → statuschips (OK/Varning/Fel)

Hämta 1 start‑URL (HTTP)

Svarskod, laddtid, HTML‑längd, titeltagg

Heuristik: behov av browser (JS tung?)

Anti‑bot indikatorer (textmatch: “Access denied”, “Attention Required” etc.) → Informativa varningar (ingen bypass)

Robots.txt:

Laddad? tillåter User‑Agent: <vår UA>? block? → visa radutdrag

Sitemap.xml: hittad? URL:er funna? → länk till förhandsvisning

Sammanfattning: “Åtkomst OK / varningar” + rekommendationer (sänk RPS, öka delay, aktivera browser på listor eller detaljsidor)

B.4 Generera sitemap (Crawl Plan, kort i denna vy)

Preview: antal hittade länkar (unika), domänfördelning, detekterade pagineringslänkar

Knappar: “Använd som plan” (skapar plan) / “Justera regler” (går till sida 6)

B.5 Tillgänglighet & UX‑polish

Field‑level fel inline; “Spara” disabled tills kritiska fält giltiga.

Sektioner i accordion (kompakt).

Hjälp‑ikoner (i) med korta förklaringar (t.ex. vad burst betyder).

“Testa åtkomst” visar resultat i en kompakt loggpnl (kollapsbar).

Känsliga fält märkta med nyckelikon; “visa/dölj” lösenord.

C) Kommandon (curl/SQL) – körbara exempel
C.1 Skapa projekt
curl -s -X POST "http://localhost:8000/api/projects" \
  -H "Content-Type: application/json" \
  -d '{
    "name":"Vehicles SE",
    "description":"Svenska fordonslistor och detaljer",
    "domains":["example.se","foo.example.se"],
    "start_urls":["https://example.se/lista","https://foo.example.se/start"],
    "auth":{"type":"none"},
    "geo":["SE"],
    "robots_mode":"respect",
    "rate_limits":[{"domain":"default","rps":1.5,"burst":3,"min_delay_ms":300,"jitter_ms":250}],
    "crawl_rules":{
      "depth":3,"max_pages":5000,
      "include":["https://example.se/lista.*","https://example.se/detalj/.*"],
      "exclude":[".*\\?utm_.*"],
      "pagination":{"mode":"selector","value":"a.next"}
    },
    "rendering":{"mode":"auto","timeout_ms":15000,"wait":"networkidle","block_non_essential":true},
    "headers":{"profile":"desktop","accept_language":"sv-SE,sv;q=0.9,en;q=0.7","referer_policy":"auto"},
    "consent":{"mode":"allow"},
    "tags":["vehicles","se"]
  }' | jq

C.2 Testa åtkomst (diagnostik)
curl -s -X POST "http://localhost:8000/api/projects/proj_123/diagnose" | jq

C.3 Generera sitemap (plan)
curl -s -X POST "http://localhost:8000/api/projects/proj_123/generate-plan" \
  -H "Content-Type: application/json" \
  -d '{"sample_pages": 200, "follow_external": false}' | jq

C.4 Skapa jobb från projekt
curl -s -X POST "http://localhost:8000/api/jobs" \
  -H "Content-Type: application/json" \
  -d '{"type":"crawl+scrape","project_id":"proj_123","template_id":"tpl_vehicle_v1","plan_id":"plan_789","concurrency":4}' | jq

D) Vad som händer (backend & DB)
D.1 DB‑tabeller (MySQL)

projects(id, name, description, archived, created_at, updated_at)

project_domains(project_id, domain)

project_start_urls(project_id, url)

project_auth(project_id, type, user, password_enc, cookie_json, updated_at)

project_geo(project_id, country_code, priority)

project_rate_limits(project_id, domain, rps, burst, min_delay_ms, jitter_ms)

project_crawl_rules(project_id, depth, max_pages, include_json, exclude_json, pagination_json)

project_rendering(project_id, mode, timeout_ms, wait, block_non_essential)

project_headers(project_id, profile, accept_language, referer_policy)

project_consent(project_id, mode)

project_tags(project_id, tag)

diagnostics(project_id, ts, result_json) (senaste resultat för UI)

crawl_plans(id, project_id, rules_json, created_at)

D.2 Validering & normalisering

Domäner normaliseras (lowercase, utan schema).

Start‑URL måste matcha listade domäner (annars fel).

Auth lagras krypterat; servern visar aldrig klardata i API‑svar.

Robots/sitemap‑caches (TTL), med “invalidate” i UI.

D.3 Diagnostik

Hämtar robots.txt (om robots_mode=respect) → sparar utdrag.

Kör HEAD/GET mot 1–3 start‑URL:er med default headers → loggar kod, tid, ev. nyckelindikatorer.

Om rendering.mode=browser: kör en browser‑render på första URL:en och mäter “first contentful DOM length”.

E) Verifiering (så kontrollerar du att allt stämmer)
E.1 Projekt skapat?
SELECT id, name FROM projects WHERE name='Vehicles SE';
SELECT domain FROM project_domains WHERE project_id='proj_123';
SELECT url FROM project_start_urls WHERE project_id='proj_123';


Förväntat: rader finns; domäner/URL:er korrekta.

E.2 Diagnostikresultat
SELECT ts, JSON_EXTRACT(result_json, '$.summary.status') AS status
FROM diagnostics WHERE project_id='proj_123'
ORDER BY ts DESC LIMIT 1;


Förväntat: status = ok eller warnings.

E.3 Plan skapad?
SELECT id, created_at FROM crawl_plans WHERE project_id='proj_123' ORDER BY created_at DESC LIMIT 1;


Förväntat: en plan_id finns; UI pekar på samma.

F) Acceptanskriterier & E2E‑testfall
DoD – funktion

Spara skapar/uppdaterar projekt och alla underresurser (domäner, start‑URL, regler) i en transaktion.

Testa åtkomst visar status per domän & start‑URL med tydliga förslag (ingen bypass, enbart diagnos).

Generera sitemap producerar en plan som kan användas direkt i Job Launcher.

Skapa jobb öppnar Job Launcher med alla fält förifyllda.

RBAC: Läsare kan se projekt, inte ändra; Operatör kan testa/planera; Admin kan ändra auth & radera.

Känsliga fält (lösen/sessionscookie) visas aldrig i klartext i API‑loggar/UI (endast “uppdaterat för X min sedan”).

All tid i UI visas i Europe/Stockholm; API returnerar UTC.

E2E (Playwright – kort)

TC‑PROJ‑01: Skapa projekt (utan auth) → diagnostik OK → generera plan → skapa jobb → jobb startar.

TC‑PROJ‑02: Sätt sessionscookie → diagnostik visar 200 med cookie; logga XSS‑säker maskning.

TC‑PROJ‑03: Robots Disallow: /detalj/ → diagnostik varnar; UI visar utdrag; “respektera” läget hindrar plan från att innehålla detaljsidor.

TC‑PROJ‑04: Felaktig start‑URL domän → inline fel; spara avbryts.

TC‑PROJ‑05: Byt rendering till browser och blockera bilder → diagnostik visar kortare laddtid, men datafälten kvar.

TC‑PROJ‑06: Klona projekt → ny post utan hemligheter; domäner/URLer kopieras.

Snabb “hur‑du‑gör” (sammanhängande demo)

1) Skapa projekt → testa → plan → jobb

# Skapa
curl -s -X POST http://localhost:8000/api/projects -H "Content-Type: application/json" -d '{...}'

# Diagnostik
curl -s -X POST http://localhost:8000/api/projects/proj_123/diagnose | jq

# Generera plan
curl -s -X POST http://localhost:8000/api/projects/proj_123/generate-plan -d '{"sample_pages":200}' -H "Content-Type: application/json" | jq

# Starta jobb
curl -s -X POST http://localhost:8000/api/jobs -d '{"type":"crawl+scrape","project_id":"proj_123","plan_id":"plan_789","template_id":"tpl_vehicle_v1","concurrency":4}' -H "Content-Type: application/json" | jq


2) Se data i Datalager

curl -s "http://localhost:8000/api/items?project_id=proj_123&limit=25" | jq


3) Exportera 7 dagars validerade fordonsdetaljer

FROM=$(date -u -d "-7 days" +"%Y-%m-%dT%H:%M:%SZ")
TO=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
curl -s -X POST "http://localhost:8000/api/exports" -H "Content-Type: application/json" \
  -d "{\"format\":\"csv\",\"filter\":{\"project_id\":\"proj_123\",\"status\":[\"validated\"],\"from\":\"$FROM\",\"to\":\"$TO\"},\"columns\":[\"id\",\"payload.reg_number\",\"created_at\"],\"destination\":{\"type\":\"file\",\"path\":\"exports/last7d.csv\"}}" | jq

Extra UX‑förslag (gör det riktigt bra)

Autospara i Projekt‑formuläret sektion för sektion.

Guidade tips efter diagnos: “Vi rekommenderar att…” knappar som uppdaterar formuläret åt dig.

Kolumnprofiler i Datalager: “Analytiker‑läge” (fler fält), “Operatör‑läge” (färre fält, mer status).

Klipp & klistra selektorer/regex med exempel (för paginering/inkludera‑regler).

Undo snackbar efter karantän/radering (30 s återställningsfönster för misstag).




5) Template Wizard (Extraktionsmallar)
Mål & Scope

Skapa, testa och versionera extraktionsmallar (schema + selektorer + transformers + validering) för både list‑ och detaljsidor.

Snabb feedback via förhandsvisning (HTTP eller headless browser), selector‑overlay, och DQT.

Mallar används av jobb/körningar och är versionslåsta när de publiceras.

Informationsarkitektur & Layout

Vänster panel (Steg & Navigation):

Steg 1: Metadata

Steg 2: Måltyp & struktur

Steg 3: Lista/Detalj & Loop‑konfiguration

Steg 4: Fält & Selektorer

Steg 5: Transformers & Validering

Steg 6: Nycklar & Dubbletter

Steg 7: Renderingsläge & Prov‑URL

Steg 8: DQT & Regeltester

Steg 9: Förhandsvisa & Resultat

Steg 10: Spara & Publicera

Mitten (Primär arbetsyta): formulär/konfigurationer per steg, tabbar för Formulär | DSL‑vy (read‑only när mall är publicerad) | Historik.

Höger panel (Live‑hjälp & Status):

Tips (kontekstuell), Valideringsstatus (obligatoriska fält), Snabbkommandon, Missar/varningar, DQT‑summering.

Global header:

“Öppna Selector Overlay”, “Förhandsvisa resultat”, “Spara”, “Publicera”, “Regeltester (DQT)”.

Autosave‑indikator (utkast, offline‑queue).

Steg & Fält (med default, validering & UX‑detaljer)
Steg 1: Metadata

Mallnamn (text, obligatoriskt). Validering: 3–64 tecken, a‑z0‑9‑_‑blanksteg. Unikt i kombination med måltyp. Inline‑feedback.

Version (auto ökas vid publicering). UX: Visas som v1 (utkast), v2 (publicerad) osv.

Beskrivning (textarea, valfritt). För teamets kontext.

Taggar (chips, valfritt) — för filtrering/sök.

Steg 2: Måltyp & struktur

Måltyp (radio): Fordon | Person | Företag | Annat.

Output‑schema:

Root‑typ: object (default).

Fältlista (tabell + “Lägg till fält”):

Fältnamn (obligatoriskt, snakeCase/kebabCase auto‑förslag).

Typ (dropdown): string, number, integer, boolean, date, datetime, array<string|object>, object.

Beskrivning (valfritt).

Obligatorisk? (checkbox).

Exempelvärde (valfritt, används i DQT‑prober).

UX: Inline‑ikon när ett fältnamn kolliderar eller typincompatibel transformer valts.

Steg 3: Lista/Detalj & Loop‑konfiguration

Sidor:

List‑sida (checkbox) med fält:

Selector för list‑items (CSS/XPath).

Detaljlänk‑selector (CSS/XPath) — kan vara relativ/absolut; normaliseras.

Pagineringstyp: Nästa‑knapp | Query‑param | Infinite scroll.

Paginering‑selector/regel (beroende av typ).

Max items per sida (default 100).

Stop‑villkor (regex på URL/DOM, item count stagnation, tidsbudget).

Detalj‑sida (checkbox) med URL‑mönster (regex) och ev. “följ länkar från listor”.

Loop‑parametrar:

Max loopvarv (default 10) — skydd mot ändlöst scroll.

Delay mellan varv (ms, jitter möjlig).

UX: “Prova list‑selector” visar antal hittade noder + highlight i overlay.

Steg 4: Fält & Selektorer

Fältlista (utökad tabell):

Fältnamn (låst från Steg 2 men kan redigeras innan publicering).

Selector (CSS/XPath) — stöd för fallback‑kedja (t.ex. primär + alternativ).

Scope: listItem | detailPage | global (var hämtas).

Attr: text | innerHTML | @href | @src | data-* (dropdown).

Multiple? (array‑läge) ⇒ Join‑policy: concat | first | json.

Defaultvärde (om tomt).

Trim? (toggle), Normalize whitespace? (toggle).

Pre‑transformers (drar‑och‑släpper i pipeline).

UX:

In‑cell Testa selector → visar provvärde i tooltip + highlight i overlay.

Autocomplete för CSS/XPath (lär sig av tidigare mallar).

Steg 5: Transformers & Validering

Transformer‑bibliotek (byggblock som kan kedjas, med konfig):

text.trim, text.regex_extract(pattern, group), text.replace,
date.parse(locale,tz,formats[]), number.parse(locale),
currency.extract(iso?), string.slugify, string.upper/lower/title,
id.luhn_check (validerare eller transformer), json.parse,
url.normalize(base), phone.parse(region), plate.normalize, vin.normalize.

Validering per fält:

Typkontroll (från schema).

RegEx (custom), Enum (lista), Range (min/max), Length (min/max).

Luhn (toggle) för id‑liknande fält.

Korsfältsregler (t.ex. start_date <= end_date).

Felpolicy:

On fail: mark as null | drop field | drop record | warn.

Severity: info | warning | error | blocker (påverkar DQT).

UX: “Kör pipeline på provvärde” inline; visar varje steg före/efter.

Steg 6: Post‑unik nyckel & Duplicathantering

Primär nyckelpolicy:

Key spec: välj 1..N fält som ingår i nyckeln.

Hash‑algoritm: SHA‑256 (default) | SHA‑1 | MD5 (MD5 varnas).

Salt/Namespace (valfritt).

Normaliseringsregel: sortera fältnamn, |‑delim, unicode‑NFKC.

Dubblettpolicy:

Senaste vinner (timestampfält, default fetched_at).

Ignorera dubbletter (första vinner).

Merge (fältvis merge med prioritet: nyaste icke‑null).

UX: Snabb‑simulering på provdataset: hur många skulle kollidera?

Steg 7: Renderingsläge & Prov‑URL

Prov‑URL (obligatoriskt för förhandsvisning).

Renderingsläge:

Auto (heuristik: om script> X, fetch/ajax, cookies ⇒ Browser).

HTTP (snabb, billig; utan JS).

Browser (headless; Playwright):

Wait‑strategi: DOMContentLoaded | networkidle | selector('…').

Viewport (px), User‑Agent‑profil, Geolocation/Timezone (valfritt).

Anti‑bot‑profil (rotering, stealth), Cookie‑banner auto‑dismiss (toggle).

Screenshot (keep för DQT‑bilagor).

Cache (toggle) för lokala tests, TTL (minuter).

UX: Liten kostnadsindikator (estimerad ms/kr per körning).

Steg 8: DQT & Regeltester

Regeltyper:

Completeness: % ifyllda obligatoriska fält ≥ tröskel.

Uniqueness: ingen nyckelkollision på provmängd.

Validity: regex/enum/luhn pass rate ≥ tröskel.

Schema‑konformans: typmatchning, array/object form.

Anomali: outliers i numeriska fält (IQR/σ), oväntade kategorier.

Trösklar (per regel och globalt).

Blockerande fel: definierar publiceringsspärr.

Rapport: tabell + badges + länkar till konkreta poster, samt evidens (DOM‑snapshot, skärmdump, råpayload, felsteg i pipeline).

Steg 9: Förhandsvisning & Resultat

Kör vald renderingsmotor, applicera selektorer, transformers, validering.

Data‑grid:

Kolumn per fält, rad per hittad post.

Cellstatus: ✓ (OK), ! (varning), ✕ (fel), • (saknas).

Column profiler (hover): null‑rate, distinct‑count, toppvärden.

Exportera provdata (CSV/JSON) för offlinegranskning.

DOM‑overlay synk: klick på cell ⇒ highlight i DOM & selector.

Steg 10: Spara & Publicera

Spara mall: skapar/uppdaterar utkast; versionsnummer ändras inte.

Publicera:

Kör DQT (måste ha 0 blockerande fel och ✓ på alla obligatoriska fält).

Fryser DSL och skapar ny version (vN).

Release‑notes (kort text).

Referens‑ID att använda i jobb.

Rollback: tillåten till tidigare publicerad version (read‑only diffvisning).

Knappar & Interaktioner

Öppna Selector Overlay → öppnar sida i inbyggd BrowserPanel, injicerar överlägg för klick‑att‑kopiera CSS/XPath. Kan skickas tillbaka till fält via “send to…”.

Förhandsvisa resultat → triggar render + extraktion + tabellprofil.

Spara mall → lokal validering; autosave var 10:e sekund och vid blur.

Publicera → validering + DQT + versionslås + release‑notes.

Regeltester (DQT) → körs fristående och i publiceringsflöde.

DSL / Export (exempel, förankrat i UI‑fälten)
template:
  name: vehicle_detail
  version: 3
  target: vehicle
  render:
    mode: auto            # http|browser|auto
    wait_for: "networkidle"
    viewport: { width: 1366, height: 768 }
  pages:
    list:
      item_selector: "ul.results > li"
      detail_link: "a.result-link@href"
      pagination:
        type: next_button
        selector: "a.next"
        max_loops: 20
    detail:
      url_pattern: "example.com/vehicles/.*"
  fields:
    - name: vin
      scope: detailPage
      selector:
        anyOf:
          - "span#vin"
          - "//div[@class='vin']/text()"
      attr: text
      required: true
      transforms:
        - text.trim: {}
        - string.upper: {}
      validate:
        regex: "^[A-HJ-NPR-Z0-9]{17}$"
        luhn: false
    - name: price
      scope: detailPage
      selector: ".price"
      transforms:
        - text.trim: {}
        - currency.extract: { iso: "SEK" }
        - number.parse: { locale: "sv-SE" }
      validate:
        range: { min: 1000 }
  primary_key:
    fields: ["vin"]
    hash: { algo: "sha256", salt: "fleet" }
  dedup:
    policy: "latest_wins"
    timestamp_field: "fetched_at"
  dqt:
    thresholds:
      completeness: 0.98
      validity: 0.97
      uniqueness: 1.0

Edge cases & Skyddsräcken

Dynamiska DOM‑ändringar (MutationObserver i overlay).

Lazy‑load (scroll‑simulering i browser‑läge).

Relativa URL:er, canonical/redirect‑hantering.

Flerspråkiga datum/tal (locale/tz via render‑inställningar).

Anti‑bot (rate, headers, fingerprint, cookie‑banners).

Sessioner/login (stöd via Form Flows separat, men mall kan anta inloggat läge).

Strikt sandbox för regex (catastrophic backtracking‑guard).

Stora tabeller (virt. scroll i DataGrid, delta‑fetch).

Prestanda & Stabilitet

Förhandsvisning körs mot cache (TTL) där möjligt.

Browser‑instanser poolas (max samtidiga previews).

Selektor‑kompilation cacheas.

Tidsbudget per preview (t.ex. 15s) + tydliga timeouts.

Tillgänglighet & Snabbflöde

Fullt tangentbord:

⌘/Ctrl+S Spara, ⌘/Ctrl+Enter Förhandsvisa, ⌥/Alt+P Publicera.

F för att fokusera selector‑fältet, O för Overlay.

ARIA‑labels, kontrast, fokusringar, tab‑ordning.

Tooltips med exempel & “visa/snabbklistra” för regex.

Rättigheter & Spårbarhet

RBAC: “Editor” kan spara utkast, “Publisher” får publicera.

Audit log: vem ändrade vad + diff (fält, selektorer, regler).

Observability

Eventspårning: template.preview.start|end, template.publish, dqt.run.

Metrix: preview‑latens, error rate, selector‑träffgrad, DQT‑score.

Testfall & Acceptanskriterier (urval)

Obligatoriska fält: grön bock visas när alla req. fält extraheras.

DQT: 0 blockerande fel krävs för “Publicera” (knapp disabled annars).

Preview: dom‑overlay highlightar korrekt nod vid cell‑klick.

Dedup: kollisioner simuleras korrekt med vald hashpolicy.

Renderingsläge: Auto väljer Browser när DOM kräver JS (heuristik).

6) Crawl Plan / Sitemap‑studio
Mål & Scope

Definiera hur URL:er hittas, begränsas och schemaläggs för hämtning.

Simulera länkupptäckt, paginering och förväntad runtime/kostnad innan körning.

Spara plan och kör som jobb med valda resurspolicys (politeness).

Informationsarkitektur & Layout

Vänster: Planmetadata & regler grupperade i sektioner.

Mitten: Form + Simuleringsresultat (graf + tabell).

Höger: Policy‑sammanfattning (robots/hosts), Budgetar, Status.

Fält & Regler (med validering & UX)
Metadata

Namn (obligatoriskt), Beskrivning (valfritt), Taggar.

Start‑URL:er

Lista (min 1). Validera URL‑format, dubbletter och robots.txt‑status (förhandskoll i bakgrunden).

Länkregler

Inkludera (regexlista) — matchar normaliserade URL:er (lowercase host, strip tracking‑params enligt lista).

Exkludera (regexlista) — prioriterad före inkl.

Djup (max depth från start‑URL) — default 3.

Domänscope: intern (samma eTLD+1) | subdomäner ok | externa tillåtna.

Canonicals: följ/ignorera rel="canonical" (toggle).

NoFollow: följ nofollow? (default nej, men simulera konsekvens).

UX: Live‑chip med “% av hittade URL:er som skulle filtreras bort”.

Paginering

Nästa‑knapp: selector + max‑sidor.

Query‑param: page=N (start, step, stop‑villkor).

Infinite scroll: scroll‑loopar, sentinel‑selector, timeout/stop‑villkor.

UX: “Testa paginering” på en provsida → visar funnen nästa eller stopp.

Samtidighet & Politeness

Global samtidighet (default 16).

Per‑värd: samtidiga anslutningar / sekv. delay (ms, jitter).

Rate limits: req/s per värd och globalt.

Backoff: exponential på 429/5xx, max retry, retry‑budget.

Robots.txt respekt (user‑agent‑profil) + crawl‑delay.

Budgetar & Stopp

Max sidor (default 10k).

Time‑budget (t.ex. 2h).

Bytes‑budget (GB; för bilder/resurser om aktiverat).

Dupe‑budget (max andel duplicerade/canonicals innan stopp).

Återbesök & Refresh

Planerad körning: Cron (crontab‑syntax) eller interval (min/h/d).

Change detection: heuristik (Etag/Last‑Modified, hash av HTML).

Reseed: återanvänd förra frontier (optional).

Extra policies (avancerat)

URL‑normalisering: lower host, sort params, strip known trackers (utm_*, gclid, fbclid …).

Parampolicy: whitelist/blacklist specifika query‑params.

Session‑stöd: cookie‑jar per domän (valfritt).

HTTP‑headers: UA‑profil, accept‑lang, accept encoding.

Retry‑klass: på specifika statuskoder, timeouts.

Knappar & Flöden

Simulera:

Torrkörning med begränsande fetch (bara HTML head eller länkextrakt utan full rendering).

Visar antal hittade URL:er, unika per nivå, hur många skulle filtreras, beräknad runtime & kostnad, förväntad pagineringstäckning.

Graf: nod‑/kant‑graf (depth‑lager), samt distribution per värd.

Spara plan: lagrar versionerad plan (utkast/publicerad).

Kör som jobb: öppnar Job Launcher med plan‑ID för körning nu eller enligt schema.

Vad händer under huven (Simulering)

Link‑extractor:

Extraherar <a href>, <link>, meta refresh, samt JS‑genererade länkar via lätt browser‑probe om aktiverat.

Normaliserar & de‑duperar, följer base href, hanterar relative → absolute.

Regelutvärdering: apply exkludera före inkludera, djupfilter, domänscope.

Pagineringstest: kör 1–2 varv enligt val, rapporterar om “nästa” hittas.

Robots‑check: snabb HEAD/GET mot robots.txt, visar disallow‑träffar.

Estimering: nURLs / (req/s * parallellism * expected latency), med backofffaktor.

Verifiering & Acceptans

Antal unika URL:er (efter filter) visas.

Förväntad runtime och kostnad (om browser‑andel >0, visa separat).

Paginering: “Nästa hittad i X% av provsidor”.

Robots: inga blockerande disallow för kritiska paths (annars varning/block).

UX‑detaljer som minimerar friktion

Tom‑tillstånd: “Klistra in några start‑URL:er för att börja”.

Regex‑hjälp: snabbtest mot exempel‑URL:er, färgkodade matchgrupper.

Massredigering: klistra in 1‑per‑rad URL:er; dubblett‑auto‑rensning.

Undo/Redo i formulär.

Importera sitemap.xml (parsa, välj namespaces, seed:a start‑mängd).

Exportera URL‑lista (prov) som CSV.

Konfliktvarningar: om externa tillåtna + djup hög + snäv budget → badge.

Prestanda, Stabilitet & Säkerhet

Simulering körs med rate‑caps och tidsbudget (t.ex. max 200 sidor/host).

URL‑queue i minne med spill till lokalt lager för stabilitet.

Graceful cancel vid navigering bort/ny simulering.

Inbyggd loop‑detektor (URL‑parametrar som räknare → stopp).

Tillgänglighet & Tangentbord

⌘/Ctrl+Enter Simulera, ⌘/Ctrl+S Spara, J Kör som jobb.

Tabbar och tabeller med ARIA‑roller och live‑region för “Simulering klar”.

Rättigheter & Audit

RBAC: “Planner” kan skapa/spara, “Operator” kan “Kör som jobb”.

Audit‑logg: ändringar av regler, simuleringar (param + resultat).

Observability

Event: crawlplan.simulate.start|end, crawlplan.save, crawlplan.run.

Metrics: hittade URL/s, filtreringskvot, robots‑hits, estimerad vs faktisk runtime (post‑hoc).

Exempel (JSON‑export av plan)
{
  "name": "example_com_listings",
  "start_urls": ["https://example.com/cars"],
  "scope": {"domain": "same_etld1", "max_depth": 3, "externals": false},
  "include": ["^https://example\\.com/cars/.*$"],
  "exclude": ["\\?sort=", ".*(/login|/privacy|/terms).*"],
  "pagination": {"type": "next_button", "selector": "a.next", "max_pages": 20},
  "infinite_scroll": {"enabled": false},
  "concurrency": {"global": 16, "per_host": 4, "delay_ms": 500, "jitter": true},
  "rate_limits": {"global_rps": 8, "per_host_rps": 1.5, "backoff": {"on": [429, 503], "max_retry": 4}},
  "robots": {"respect": true, "user_agent": "CrawlerBot/1.0"},
  "budgets": {"max_pages": 10000, "time_minutes": 120, "bytes_gb": 2},
  "url_normalization": {"strip_params": ["utm_*", "gclid", "fbclid"], "sort_params": true},
  "headers": {"accept_language": "sv-SE,sv;q=0.9", "user_agent_profile": "desktop_chrome"},
  "schedule": {"cron": "0 3 * * *"},
  "estimation": {"enabled": true}
}

Testfall & Acceptanskriterier (urval)

Simulera visar >0 hittade URL:er för giltig start‑URL och lyder filter.

Pagineringstest markeras korrekt (nästa funnen/inte funnen).

Robots: disallow på /private syns i varningslistan.

Runtime: estimering ligger inom ±30% mot liten verklig provkörning.

“Kör som jobb” skapar jobb med referens till plan‑ID och låser snapshot av planen (immutabel i körningen).

Samspel mellan Template Wizard & Crawl Plan

Crawl Plan producerar URL‑frontier (list/detalj). Template Wizard definierar hur data extraheras på respektive sida.

Vid “Kör som jobb” kan man binda en publicerad mallversion. UI varnar om mall inte matchar måltyp eller om mallens DQT nyligen försämrats (driftdetektion).

Mikrodetaljer för optimal UX

Autosave på utkast (10 s) och vid fält‑blur; offline‑banner med återkö.

Konfliktlåsning (optimistisk): varna om annan redigerar samma mall/plan.

Snabbsök över fält/selektorer (/ för att söka).

Kopiera som DSL (clipboard) för snabb delning i PR/review.

Diff‑visning mellan versioner (fält‑nivå och regel‑nivå).

Guidade tomtillstånd med exempel (“Lägg till VIN‑fält…” / “Klistra in sitemap.xml”).


7) Job Launcher (Starta Crawl/Extraktion)
Mål

Starta körningar (crawl, scrape, export, analys) snabbt, säkert och återupprepbart med tydlig vägledning, minsta nödvändiga input, bra felmeddelanden och möjlighet till förinställningar och torrkörning.

UI‑anatomy & layout

Sidtitel + beskrivning: “Starta nytt jobb” + kort text om vad jobbläge gör.

Formulär i kort (2 kolumner desktop, 1 kolumn mobil):

Jobbtyp (required): radio eller segmenterade knappar

“Crawl”, “Crawl + Scrape”, “Scrape från URL‑lista”, “Export”, “Analys”.

Källa/Projekt (required, dropdown med sök): listade projekt/källor användaren har rättigheter till.

Tooltip: “Projekt används för policy, domäninställningar, krediter och etikettering.”

Mall (dropdown, krävs för Scrape & Crawl+Scrape): visar endast kompatibla mallar baserat på valt Projekt.

Badge för version och senast uppdaterad.

Preview‑länk öppnar modal med fält och test‑exempel.

Crawl‑plan (dropdown, krävs för Crawl & Crawl+Scrape): t.ex. sitemap/spider‑profil.

Visa planens scope (max djup, tillåtna domäner, robots‑läge).

Prioritet: “Låg”, “Normal” (default), “Hög”.

Tooltip för schemaläggnings‑SLA och kö‑position.

Samtidighet (workers): numeriskt steg (1…N med övre gräns från quota/roll).

Inline‑hint: “Rekommenderat: {förslag baserat på planens uppskattade volym}”.

Renderingsprofil: “Auto” (default), “HTTP”, “Browser”.

Auto väljer HTTP och eskalerar till Browser per policy (t.ex. JS‑tung).

Proxyprofil: “Auto”, “Sticky”, “Roterande”; valfri Geo (land/region).

UI visar aktuell pool‑hälsa (% ok), klick för detaljer.

Output‑mål: “Databas” (default), “Fil (CSV/JSON/Parquet)”, “Extern connector” (Sheets, BigQuery, Snowflake, Elastic, OpenSearch etc.).

Underalternativ exponerar nödvändiga fält (bucket/namn/tabell/credentials).

Taggar: chips‑input med kommatext, autokomplettering av tidigare använda.

URL‑lista (endast ‘Scrape från URL‑lista’ & ‘Torrkörning’):

Textarea (en per rad), eller “Ladda upp .csv/.txt”; visa räknare (# URL:er).

Avancerat (collapsible):

Rate‑limit overrides (req/s, parallel per domain),

Robots/TOS‑policy‑profil (läs/överstyr),

Retry‑policy (max attempts, backoff),

Deduplicering (idempotency window, hash‑strategi),

Content‑lagring (spara rå HTML? retention‑policy),

Max sidor/tidsbudget (hard‑stop),

Post‑processing hooks (t.ex. DQ‑checker, PII‑scanner, de‑identification),

Webhooks (on_start, on_batch, on_complete) med signerad HMAC.

Primära knappar:

Starta jobb (primary)

Torrkörning (secondary; kör 5–10 URL:er eller 1–2 sidor/branch i crawl‑plan)

Spara som förinställning (tertiary)

Sekundära element:

Förinställningar dropdown (vänster om knappar) för att snabbt ladda sparade presets.

Valideringspanel i sidfot som visar sammanfattning “3 saker kvar att fylla”.

Defaults & smarta förslag

Jobbtyp: förifyll baserat på senaste valet per Projekt.

Samtidighet: auto‑förslag = min(roll‑limit, proxy‑kapacitet, crawl‑planens uppskattning).

Renderingsprofil: “Auto” med heuristik (domänpolicy, historik, anti‑bot signaler).

Proxyprofil: “Auto” → roterande med hälsokontroll + geo nära måldomän.

Output: “Databas” till standard‑schema för Projekt; format/connector minns senaste.

Validering (synk & async)

Synk (on change/blur):

Jobbtyp valt (required).

Projekt valt (required, åtkomsträtt).

Mall krävs för Scrape & Crawl+Scrape.

Crawl‑plan krävs för Crawl & Crawl+Scrape.

Output‑mål uppfyller obligatoriska fält (ex: bucket, tabell, dataset).

Samtidighet inom [1, user/project quota].

URL‑lista: giltiga, unika, normaliserade (scheman, ingen mailto/tel).

Taggar: max 20, varje ≤ 40 tecken, a‑z0‑9‑_.

Async (på “Starta jobb”):

Policy‑check: robots/TOS‑policy, blocklist, domänwhite‑list.

Krediter/budget: finns tillgänglig quota/kostnadsbudget.

Connector‑hälsa: skrivbarhet/credentials.

Mallkompatibilitet: mall ↔ projekt ↔ renderingsprofil (ex: kräver DOM).

Idempotens: finns identiskt jobb i pending/running med samma nycklar?

Misslyckad async‑check visar tydlig banner + per‑fält markering + åtgärdsförslag.

“Spara som förinställning”

Modal: Namn, synlighet (Privat/Team/Org), valbar låsningsgrad per fält (ex: lås Renderingsprofil och Proxyprofil, låt Prioritet och Taggar vara öppna).

Spara: POST /api/jobs/presets → returnerar preset_id.

Ladda preset fyller formuläret, kör om valideringar, visar “Laddad: <namn>”.

“Torrkörning”

För Crawl/Crawl+Scrape: kör upp till 10 sidor enligt plan (per gren) eller tidsbudget 60 s, det som kommer först.

För Scrape från URL‑lista: tar första 5–10 URL:erna.

Output skrivs till temporär sandbox (ej långvarig retention), med logg‑tagg dry_run:true.

UI visar banner: “Torrkörning — inga data skrivs till produktionsmål (endast preview).”

Redirect till Jobbdetaljer med statuschip “Dry Run”.

Åtgärder & sidflöde

Starta jobb:

Skapar job i kö → status pending.

Publicerar händelse till scheduler.

Redirect till Jobbdetaljer (Sida 8) med live‑logg start.

Spara som förinställning: stannar kvar, toast “Förinställning sparad”.

Torrkörning: startar dry_run=true variant, redirect till Jobbdetaljer.

State‑maskin (översikt)

draft → pending → running → (paused) → completed | failed | canceled

paused endast när användaren pausat (eller auto‑throttle med “degraded” indikator).

“Crawl+Scrape” kör två pipelines med koordinerad backpressure.

Backend API‑kontrakt (exempel)
Start
POST /api/jobs
{
  "type": "crawl|crawl_scrape|scrape_list|export|analysis",
  "project_id": "prj_123",
  "template_id": "tpl_456",           // krävs för scrape/crawl_scrape
  "crawl_plan_id": "crp_789",         // krävs för crawl/crawl_scrape
  "priority": "low|normal|high",
  "concurrency": 8,
  "rendering": "auto|http|browser",
  "proxy": { "mode": "auto|sticky|rotate", "geo": "SE|EU|US|..." },
  "output": {
    "target": "db|file|connector",
    "format": "csv|json|parquet",
    "connector": "sheets|bigquery|snowflake|elastic|opensearch",
    "options": { "bucket": "...", "path": "...", "table": "...", "dataset": "..." }
  },
  "tags": ["q3", "ad_hoc"],
  "url_list": ["https://..."],        // endast scrape_list/dry_run
  "limits": { "max_pages": 5000, "time_budget_sec": 3600 },
  "policies": { "robots": "respect|ignore_if_allowed", "tos_profile": "default" },
  "retries": { "max": 3, "backoff": "exp", "cap_sec": 60 },
  "dedupe": { "strategy": "url_hash|content_hash", "window_hours": 24 },
  "webhooks": { "on_start": "...", "on_batch": "...", "on_complete": "..." },
  "dry_run": false,
  "idempotency_key": "hash(form_payload)"
}


Svar:

201 Created
{ "job_id": "job_abc", "status": "pending" }

Preset
POST /api/jobs/presets
{ "name":"SE Retail Crawl v2", "scope":"team", "locked_fields":["rendering","proxy"], "payload":{ ... } }

Telemetri & audit

Spårning: lägg trace_id på job + formularskick (OpenTelemetry).

Audit log: vem startade, med vilka fält, från vilken IP/klientversion.

Produktanalys: event job_start_clicked + utfall job_created_ok|failed_validation.

Åtkomst & begränsningar (RBAC/Quota)

Roll styr tillgång till Projekt, max samtida workers, geos, exportmål.

Varning/toast om användaren överskrider per‑projekt eller global daglig budget.

“Export” och “Extern connector” kräver scopes/credentials.

A11y & i18n

Alla kontroller har label + aria‑describedby (fel/hint).

Tangentbordsnavigering (Tab‑ordning), Enter = “Starta jobb”, Ctrl/Cmd+Enter = “Torrkörning”.

Tomtillstånd & fel

Tomt Projekt: CTA “Skapa projekt” (modal eller länk).

Mall saknas: CTA “Skapa mall i Template Wizard”.

Connector ogiltig: markera Output‑sektionen + länk till “Lägg till anslutning”.

8) Jobbdetaljer / Live Run Console
Mål

Ge en sann realtidsvy, full kontroll och tydlig återkoppling. Allt viktat för snabb diagnostik (vad händer nu, funkar det, hur bra, vad ska jag göra om det inte funkar?).

Layout

Header:

Jobbtitel (typ + projekt + kort id), Statuschip (Pending/Running/Failed/Completed/Paused/Dry Run).

Primära actions: “Pausa/Återuppta”, “Avsluta jobb”, “Skala workers ±”, “Byt proxyprofil”, “Exportera logg”.

Sekundära: “Öppna prov‑URL i Browserpanel”, “Kopiera trace_id”, “Kopiera API‑curl”.

Övre KPI‑rad (4–5 kort):

Sidor/minut (med minitrend 15 min)

Lyckade % (2xx/OK)

Fel % (klassad: transient/policy/permanent, klick öppnar felpanel)

p95‑latens (ms)

Genomflöde ut (rader/min) om Scrape/Export aktivt

Huvudpaneler (tabs):

Live‑logg (default)

Streamad text i virtuellt list‑fönster, filterchips (INFO/WARN/ERROR/DEBUG), sök, “Only errors”, “Only policy events”.

“Pin latest” toggle; “Copy selection”; “Download snapshot”.

Kö‑status

Gauge för väntande/bearbetas/klara, ETA, backpressure‑indikator.

Per‑partition/domän brytning, hot‑spots (värst fel).

Senaste fel

Tabbad lista: Transient (t.ex. timeouts), Policy (robots/TOS/block), Permanent (404/410/parse fail).

Varje rad: URL, felklass, kod, första/senaste, count, suggested action.

CTA “Skicka prov‑URL till Browserpanel”.

Resurser

Realtime CPU/RAM för jobbkapslar/containers + Network I/O, Proxy‑hälsa.

Visa “degraded” strax före throttling.

Output

Räknare inskrivna rader, schema preview, senaste batch‑ID, länk till destination (ex. Sheets/BigQuery‑job).

Inställningar (read‑only)

Renderingsprofil, Proxyprofil, Limits, Retries, Dedupe, Policy, Webhooks.

Historik

Milstolpar: pending→running, 10%/50%/90% progress, paus/återupplivning, slutfört/avslutat.

Realtid & websocket‑protokoll

Kanal: ws /jobs/{job_id}/stream

Eventtyper:

job.status {status, reason?}

metrics.kpi {pages_per_min, success_rate, error_rate, p95_ms, rows_per_min?}

log.entry {ts, level, source(worker|scheduler|exporter), message, url?, code?, fields?}

queue.update {pending, processing, completed, eta_sec}

errors.aggregate {class: transient|policy|permanent, items:[…]}

resources.update {cpu_pct, mem_pct, net_in/out, proxy_ok_pct}

output.update {rows_total, last_batch_id, destination_ref}

control.ack {action: pause|resume|scale|proxy_switch|terminate, ok:bool, msg?}

UI‑fallback: om WS bryts → backoff + poll GET /api/jobs/{id}/snapshot var 5 s; banner “Återansluter…”.

Åtgärder & semantik

Pausa/Återuppta:

Skickar POST /api/jobs/{id}/pause eller /resume.

Pausa sätter queue på hold; workers avslutar pågående enheter (graceful) och slutar hämta nya. Status → paused när alla workers är säkra.

Återuppta öppnar kö och fortsätter.

Skala workers ±:

POST /api/jobs/{id}/scale { delta: +N|-N } (scheduler orchestrerar).

Begränsas av projekt/roll kvoter och proxy‑kapacitet.

Byt proxyprofil:

POST /api/jobs/{id}/proxy { mode, geo } → hot‑swap i nästkommande fetch‑cykel; logg entry “Proxy profile switched”.

Avsluta jobb:

POST /api/jobs/{id}/terminate { reason } → graceful stop (timeout → hard kill). Status → canceled.

Öppna prov‑URL i Browserpanel:

Skickar POST /api/tools/browser_preview { url, job_id, worker_context? } → öppnar sida 9 i ny panel/flik med riktig header/cookie‑profil.

Exportera logg:

GET /api/jobs/{id}/logs?format=ndjson|txt&level>=INFO&since=… → laddar fil.

State & förväntat beteende

Statuschip uppdateras omedelbart via job.status.

Throughput reagerar inom sekunder på scale eller proxybyte.

Felpanel visar top‑orsaker (Pareto) med länkar till runbooks (“429 spike”, “Captcha‑storm”).

Kö‑panel visar ETA baserat på glidande medel + per‑domän begränsningar.

Felklassificering

Transient: timeouts, 5xx, reset, rate limit (429), proxy fail — auto‑retry.

Policy: robots disallow, TOS block, geofencing — ingen retry, rekommendera policyjustering.

Permanent: 404/410, ogiltig mallselektor, irreparabel parse — skippa.

Observability

Trace‑länkar till APM för job_id och trace_id.

Graf‑kort: små inline‑sparklines; click‑through till full Grafana/Explore.

Kostnadsmätare (valbar): est. kostnad/1000 sidor, budget‑varningar.

Åtkomst, säkerhet, integritet

RBAC: endast ägare/rollen med jobs:control får pausa/skala/terminera/byt proxy.

PII‑skydd: live‑logg maskar PII med policy (e‑post, pers.nr).

Audit: varje kontrollåtgärd loggas (vem, när, från var).

Prestanda & UX‑finlir

Virtuella listor för logg (10k+ rader utan lagg).

Intelligent autoscroll (stannar när användaren scrollar upp).

Skelettladdare för KPI‑rutor första 1–2 sek.

Keyboard: P pausa/återuppta, +/- skala, / fokus på sök i loggen.

Sticky action‑rad vid scroll.

Mörkt/ljust tema, färgkodning:

Grön throughput/OK, Gul transient, Blå policy info, Röd permanent fel.

Snapshot & export

“Spara körnings‑snapshot” (JSON) med config + senaste KPI + fel‑topplista.

Exportera output‑prov (första 100 rader) till CSV för snabb delning.

Edge‑cases & hur UI ska bete sig

WS av: visa banner och degradera till polling; behåll kontroller aktiva.

Zero progress: om 0 sidor efter X min → visa diagnosförslag (DNS/Proxy/Policy).

Hög fel%: CTA “Sänk concurrency” och “Byt proxyprofil” (one‑click actions).

Mall‑drift: upptäckt selector‑drift → badge “Drift detected”, länk till selector‑verktyg.

Output full/skrivfel: markera Output‑tab röd; föreslå växel till temporär fil.

Quota slut: banner “Budget nådd — pausat”; knapp “Begär extra kvot”.

Backend API‑kontrakt (exempel)
Läs snapshot
GET /api/jobs/{id}/snapshot
{
  "status":"running",
  "kpi":{"ppm":320,"success_rate":0.92,"error_rate":0.08,"p95_ms":840,"rows_per_min":190},
  "queue":{"pending":18200,"processing":64,"completed":7400,"eta_sec":2880},
  "errors":{"transient":{...},"policy":{...},"permanent":{...}},
  "resources":{"cpu_pct":71,"mem_pct":63,"net_in":...,"net_out":...,"proxy_ok_pct":88},
  "output":{"rows_total":154200,"dest_ref":"bq://project.dataset.table"},
  "config":{ ... } // read-only
}

Kontrollåtgärder
POST /api/jobs/{id}/pause            -> 202 { "accepted": true }
POST /api/jobs/{id}/resume           -> 202 { "accepted": true }
POST /api/jobs/{id}/scale            -> 202 { "accepted": true, "target_workers": 24 }
POST /api/jobs/{id}/proxy            -> 202 { "accepted": true, "mode":"rotate","geo":"EU" }
POST /api/jobs/{id}/terminate        -> 202 { "accepted": true }
GET  /api/jobs/{id}/logs?level=warn  -> 200 text/plain (stream/snapshot)

Datamodell (kort)

Job: id, type, project_id, template_id?, crawl_plan_id?, priority, concurrency, rendering, proxy(mode, geo), output(target, connector, options), tags[], limits, policies, retries, dedupe, webhooks, dry_run, idempotency_key, created_by, status, created_at, started_at, finished_at.

JobMetrics (time‑series): job_id, ts, pages, ok, errors (klass), p95_ms, rows_out, cpu, mem, proxy_ok_pct.

JobLog: job_id, ts, level, source, message, url?, code?, fields(jsonb).

JobControlEvent: job_id, ts, action, actor, result.

Kvalitets‑ & testchecklista (UI/UX)

Formulärblockerande fel innan “Starta jobb” blir klickbar.

Alla required‑fält har inline‑fel + fokusflytt.

Torrkörning alltid sandboxad och tydligt uppmärkt.

WS‑strömmar återansluter; inga dubletter i logg.

Sidor/min och p95 reagerar mätbart inom 2–5 s vid scale/proxybyte.

Export av logg fungerar även för långa körningar (paginering/chunk).

A11y: kontrast, fokus, live region för uppdaterande KPI.

Sammanlänkning 7 → 8

När ett jobb skapas (eller torrkörs) sker omedelbar redirect till Jobbdetaljer med:

Statuschip initialt Pending, KPI‑kort som skelett tills första metrics.kpi.

Notifiering “Jobb skapat: job_abc” + länk “kopiera id”.

Om validering i backend misslyckas efter skapande (t.ex. connector‑fel) → status Failed med prominent orsak och “Återöppna i launcher med samma parametrar” (prefill).


9) Browserpanel & Selector Tool
A) Enkel förklaring (för icke‑tekniker)

Det här är en inbyggd webbläsare (osynlig/headless) som laddar sidor “som en människa” för att kunna se det som JavaScript renderar. Du kan:

Besöka en URL, byta webbläsarprofil (User‑Agent), språk och tidszon,

se DOM, nätverkstrafik och cookies,

använda en overlay för att peka på ett element och få en stabil CSS/XPath‑selector som klistras in i din mall,

spela in interaktioner (t.ex. fylla formulär, klicka), spara cookies, blockera tunga resurser, ta skärmdump och köra eget script i en kontrollerad sandbox.

B) Detaljerad UI/UX‑spec
B.1 Översikt & layouter

Adressrad: URL‑fält + Gå till (↩︎), Ladda om, Stopp.

Profilfält (i samma rad):

User‑Agent‑profil (desktop/mobil; Chrome/Firefox/Safari vardera 2–3 moderna versioner).

Språk (sv-SE,sv;q=0.9,en;q=0.7) och Tidszon (Europe/Stockholm som default).

Geo‑emulering (valfritt land/lat‑lon, kopplas till proxyprofiler).

Paneler (flikar):

DOM (inspektör, sök, snabb‑copy av selector, “rulla till element”)

Nätverk (waterfall, request/response, headers, cookies, storlekar, status)

Lagring (cookies, localStorage, sessionStorage; import/export cookies)

Konsol (console.log, varningar, fel, utskrift från “Kör script”)

Overlay‑läge: togglas på/av; visar highlight + föreslagna CSS/XPath, fallback‑kedja, kopiera till mall.

Sidokolumn (åtgärder):

Spela in interaktion (start/stop)

Spara cookies i session

Blockera resurser (bilder/video/annons/3:e part; toggles)

Ta skärmdump (viewport/hel sida/element)

Kör script (JS‑editor med sandbox & tidsgräns)

B.2 Overlay – selector‑upplevelse

Hover på element → overlay visar:

Primär CSS (preferera data-*, id, stabila klasser, undvik index)

Fallback CSS (mer generell)

XPath (med contains() på stabila attribut/text vid behov)

Exempelvärde (innerText/attr) + “Testa nu” → extraherar och visar resultat i sidofoten.

Regel om “robusthet” (automatiskt):

Använd id om det inte ser ut som dynamiskt (regex på slumpsträngar).

Använd data-testid|data-qa|data-* om finns.

Minimerad klasslista (slopa BEM‑suffix/dynamiska hashklasser).

Kliv uppåt till närmaste stabila container med tydlig roll/tagg.

Som sista utväg: nth-of-type() endast om unikhet inte uppnås annars.

Kvalitetspoäng (0–100) per selector; overlay färgar grön >80, gul 50–80, röd <50.

“Kopiera in i mall”:

Välj fält (dropdown med dina fältnamn) → lägger in i Template Wizard aktiva fältet.

Kan skicka primary + fallback (lista).

B.3 Spela in interaktion (formflöde)

Starta inspelning → overlay loggar:

click(selector), fill(selector, value), selectOption(...), press(...), waitForNavigation(...), waitForSelector(...), scroll(...).

Heuristik för selectors under inspelning (samma robusthetsregler).

Resultat: ett flöde du kan:

Köra om (play), stega, exportera som Playwright‑script (read‑only), eller spara som “Form Flow” (kan bindas till en mall/plan).

Maskning: värden i fält som ser ut som lösenord/PII maskas innan lagring.

B.4 Spara cookies i session

Cookie‑jar namngiven efter Projekt + Användarprofil + Proxy‑geo.

Knappar: “Spara”, “Rensa”, “Exportera (.json)”, “Importera”.

Persistens: krypterad lagring. TTL styrs av projektpolicy.

Isolering: cookies från ett projekt/geo återanvänds inte i annat projekt/geo.

B.5 Blockera resurskategorier

Togglechips: Bilder, Video, Typsnitt, Spårare, Annonser, 3:e part.

Mappas till request‑interception (mönsterlistor/URL‑kategorier).

Visar “spara X% bandbredd” estimat efter laddning.

B.6 Ta skärmdump

Typ: Viewport | Hel sida | Element (via vald selector).

Format: PNG (default) / JPEG (kvalitet slider).

Lagring: filsystem (med pad), samt referens in i extracted_items.attachments.

UI: thumbnail + “Öppna större”, “Kopiera bild‑URL”.

B.7 Kör script (custom JS)

Editor (monaco), read‑only globaler: document, window, ingen nätverksåtkomst via fetch (sandboxpolicy), tidsgräns (t.ex. 2 s).

Console fångas till “Konsol”‑flik.

Security: script körs i isolat (t.ex. Playwright evaluate med kapsling), inga Node‑API:er, inga OS‑anrop.

Registrering: script + output kan sparas i diagnostic_runs.

C) Backend‑kontrakt & kommandon
C.1 API (REST)
POST /api/browser/open
{ "url":"https://example.com", "ua_profile":"desktop_chrome_125", "accept_language":"sv-SE,sv;q=0.9,en;q=0.7", "timezone":"Europe/Stockholm", "geo":{"country":"SE"}, "proxy":{"mode":"sticky","geo":"SE"}, "block":{"images":true,"video":true}, "cookie_jar":"proj_12__SE" }

POST /api/browser/overlay/selector
{ "at_point": {"x": 420, "y": 380}, "return":"css|xpath|both" }

POST /api/browser/recording/start
{ "mask_fields": ["password","ssn","card"] }

POST /api/browser/recording/stop
{}

POST /api/browser/screenshot
{ "type":"full|viewport|element", "selector":"...", "format":"png|jpeg", "quality":80 }

POST /api/browser/run-script
{ "code":"/* JS */", "timeout_ms":2000 }

POST /api/browser/cookies/save
{ "cookie_jar":"proj_12__SE" }

POST /api/browser/cookies/export
{ "cookie_jar":"proj_12__SE" }

POST /api/browser/cookies/import
{ "cookie_jar":"proj_12__SE", "cookies":[ ... ] }

C.2 Verifieringskommandon (curl)
# Öppna sida med svensk profil + sticky SE-proxy
curl -s -X POST http://localhost:8000/api/browser/open \
  -H "Content-Type: application/json" \
  -d '{"url":"https://example.com","ua_profile":"desktop_chrome_125","accept_language":"sv-SE,sv;q=0.9","timezone":"Europe/Stockholm","proxy":{"mode":"sticky","geo":"SE"},"block":{"images":true}}' | jq

# Ta helsideskärmdump
curl -s -X POST http://localhost:8000/api/browser/screenshot \
  -H "Content-Type: application/json" \
  -d '{"type":"full","format":"png"}' > /tmp/snap.png

# Kör kort JS och hämta console-loggar i svaret
curl -s -X POST http://localhost:8000/api/browser/run-script \
  -H "Content-Type: application/json" \
  -d '{"code":"console.log(document.title); return document.querySelector(\"h1\")?.textContent || null;"}' | jq


Förväntat:

open svarar med session_id + “loaded:true/false”, latens m.m.

Skärmdump sparas, filen går att öppna.

run-script returnerar console‑loggar + result.

D) MySQL‑schema & verifiering
D.1 Tabeller
-- Sessions & cookies
CREATE TABLE IF NOT EXISTS browser_sessions (
  id            BIGINT PRIMARY KEY AUTO_INCREMENT,
  project_id    BIGINT NOT NULL,
  session_key   VARCHAR(64) NOT NULL UNIQUE,
  ua_profile    VARCHAR(64),
  language      VARCHAR(64),
  timezone      VARCHAR(64),
  geo_country   CHAR(2),
  proxy_mode    ENUM('auto','sticky','rotate'),
  proxy_geo     VARCHAR(8),
  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS cookie_jars (
  id            BIGINT PRIMARY KEY AUTO_INCREMENT,
  jar_key       VARCHAR(128) NOT NULL UNIQUE,
  project_id    BIGINT NOT NULL,
  data_encrypted LONGBLOB NOT NULL,
  updated_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Diagnostic runs (overlay/script/recorder)
CREATE TABLE IF NOT EXISTS diagnostic_runs (
  id            BIGINT PRIMARY KEY AUTO_INCREMENT,
  project_id    BIGINT NOT NULL,
  session_key   VARCHAR(64),
  kind          ENUM('overlay','recording','screenshot','script'),
  request_json  JSON,
  result_json   JSON,
  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

D.2 Kontrollera att session & cookies sparades
SELECT session_key, ua_profile, language, timezone FROM browser_sessions ORDER BY created_at DESC LIMIT 3;
SELECT jar_key, OCTET_LENGTH(data_encrypted) size_bytes FROM cookie_jars ORDER BY updated_at DESC LIMIT 3;


Förväntat: poster finns, storlek > 0 på cookies.

E) Robust selector‑algoritm (översikt)

Målsättning: generera stabila selectors som överlever små DOM‑ändringar.

Heuristik (förenklad pseudokod):

if element.id && !looks_dynamic(element.id): return '#'+id
if has_data_testid(element): return `[data-testid="${val}"]`
if has_unique_attribute(['data-qa','itemprop','name','aria-label']): return `[attr="val"]`
path = build_path_upwards(element, prefer_tag_names=['main','article','section'])
path = minimize_classes(path, drop_dynamic_hashes=true)
if uniqueness(path) < 1: path = add_nth_of_type_conservatively(path)
return path


Verifiering i UI: “Testa nu” ska returnera exakt samma text/attributvärde som du markerade.

F) A11y, prestanda & säkerhet

A11y: Full tangentbordsstyrning; overlay kan togglas via O; fokus syns starkt.

Prestanda: Browserpool (5–10 instanser), återanvänd sticky‑session under panelen, stäng inaktiva sessioner efter 5 min.

Säkerhet: JS‑sandbox tidsgräns, inga nätverksanrop, script & cookies auditeras (loggas) för spårbarhet.

G) Acceptanskriterier & E2E

Overlay producerar ≥1 selector med kvalitetspoäng > 80 för typiska element.

“Spela in interaktion” kan reproducera ett enkelt formulärflöde (sök → klicka resultat → öppna detalj).

“Spara cookies i session” gör att nästa sidladdning inte visar cookie‑banner (om consent sattes).

Blockera “Bilder” minskar total nedladdad bytes (visa i Nätverk).

Skärmdump hamnar i filsystemet och refereras från diagnostic_runs.result_json.

10) Proxy & Nätverk
A) Enkel förklaring (för icke‑tekniker)

Här styr du IP‑adresserna och nätverkskvalitet. Du kan:

lägga till proxyleverantörer, se hälsa (latens/fel),

välja geografi (t.ex. Sverige),

bestämma sticky‑fönster (hur länge samma IP behålls),

svartlista dåliga IPs, validera nu, och exportera rapporter.

B) Detaljerad UI/UX‑spec
B.1 Pool & leverantörer

Pooler: Residential, Datacenter, Mobile (kort med badges: aktiva, p95 latens, fail‑rate).

Leverantörer (per pool): lista med API‑nyckelstatus, kvoter, kostnadsindikator.

Knappar:

Lägg till proxykälla (modal: namn, API‑endpoint, auth, pool, geo‑stöd).

Validera nu (triggar health‑run).

Tvinga rotation (flippar alla sticky → nya IP).

Exportera hälsorapport (CSV/JSON).

B.2 Geo‑fördelning (värmekarta)

Heatmap per land/region: antal aktiva IP, fail‑rate, latensp95.

Filterchips: visa endast SE|Nordics|EU.

Klick i karta → tabell “Top endpoints i [land]”.

B.3 Sticky‑fönster & policys

Sticky window (minuter): 0 (= aldrig sticky), 5, 10, 30, custom.

Per‑jobb policy (overrideable i Job Launcher).

Per‑domän policy (ex: car.info: sticky=10 min, geo=SE, RPS=1).

B.4 Hälsa & kvalitetsfilter

Hälsokort: p50/p95 latens (ms), fail‑rate (%) senaste 1 h, svartlistade noder (antal).

Tabell “Endpoints”: endpoint, pool, geo, hälsopoäng (0–100), senaste felkod, svartlistad tills.

Kvalitetsfilter:

Min krav: p95 < X ms, fail‑rate < Y%.

Handling: degradera (lägre vikt), svartlista (TTL), uteslut geon.

Åtgärder per rad: “Svartlista (TTL)”, “Vitlista”, “Testa igen”, “Visa historik”.

C) Tilldelningsalgoritm (urval)

Mål: för varje request/session välj en endpoint som maximerar sannolikheten för OK svar och minimerar block/fel.

Viktningsmodell (ex): EWMA av (latens, fail‑rate), + geo‑match, + leverantörskostnad.

Circuit breaker: om endpoint ger 3× fel inom kort fönster → öppet läge (svartlistas TTL=10 min).

Sticky: håll samma endpoint för en session inom sticky‑fönstret; annars rotera (round‑robin viktad).

Per‑domän caps: per‑IP RPS och global RPS.

D) Backend‑kontrakt & kommandon
D.1 API (för UI/Jobs)
GET  /api/proxy/pools
GET  /api/proxy/providers
POST /api/proxy/providers          { "name":"...", "pool":"residential", "auth":{"key":"..."},"geos":["SE","NO"] }
POST /api/proxy/validate-now       { "pool":"residential" }
POST /api/proxy/rotate             { "pool":"residential", "scope":"all|job|session", "job_id":"optional" }
POST /api/proxy/blacklist          { "endpoint":"res://se-123", "ttl_min":60, "reason":"429 storm" }
POST /api/proxy/whitelist          { "endpoint":"res://se-123" }
POST /api/proxy/quality-filter     { "pool":"residential","min_score":70,"max_p95_ms":1200,"max_fail_rate":0.05 }
GET  /api/proxy/health-report.csv?pool=residential

D.2 “Allocate/Release” (internt API för workers)
POST /api/proxy/allocate
{ "pool":"residential","geo":"SE","sticky":"session|request","session_key":"job_123__worker7" }

POST /api/proxy/release
{ "endpoint":"res://se-123", "session_key":"job_123__worker7", "result":"ok|fail", "status_code":200, "latency_ms":380 }

D.3 Verifieringskommandon (curl)
# Lägg till leverantör
curl -s -X POST http://localhost:8000/api/proxy/providers \
  -H "Content-Type: application/json" \
  -d '{"name":"AcmeResi","pool":"residential","auth":{"key":"acme-xyz"},"geos":["SE","FI","NO"]}' | jq

# Validera nu (starta health-run)
curl -s -X POST http://localhost:8000/api/proxy/validate-now -H "Content-Type: application/json" -d '{"pool":"residential"}' | jq

# Svartlista endpoint 60 min
curl -s -X POST http://localhost:8000/api/proxy/blacklist -H "Content-Type: application/json" \
  -d '{"endpoint":"res://se-123","ttl_min":60,"reason":"p95>2000ms"}' | jq

# Hämta hälsorapport CSV
curl -s "http://localhost:8000/api/proxy/health-report.csv?pool=residential" -o health.csv


Förväntat:

Provider skapas; Validera nu startar job (se i “Hälsokort”).

Endpoints med hög latens/fail‑rate degraderas/svartlistas; hälsorapport innehåller p50/p95/fail‑rate.

E) MySQL‑schema, index & kvalitet
E.1 Tabeller
CREATE TABLE IF NOT EXISTS proxy_providers (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  name         VARCHAR(64) UNIQUE,
  pool         ENUM('residential','datacenter','mobile') NOT NULL,
  auth_json    JSON NOT NULL,
  geos_json    JSON,
  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS proxy_endpoints (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  provider_id  BIGINT NOT NULL,
  endpoint     VARCHAR(128) UNIQUE,
  pool         ENUM('residential','datacenter','mobile') NOT NULL,
  geo_country  CHAR(2),
  score        FLOAT DEFAULT 50,       -- 0-100
  p50_ms       INT,
  p95_ms       INT,
  fail_rate    FLOAT,                  -- 0..1
  blacklisted_until DATETIME NULL,
  last_error   VARCHAR(32),
  updated_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX (pool, geo_country),
  INDEX (blacklisted_until)
);

CREATE TABLE IF NOT EXISTS proxy_allocations (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  endpoint_id  BIGINT NOT NULL,
  session_key  VARCHAR(128) NOT NULL,
  allocated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  released_at  DATETIME NULL,
  result       ENUM('ok','fail') NULL,
  status_code  INT NULL,
  latency_ms   INT NULL,
  INDEX (session_key),
  INDEX (allocated_at)
);

CREATE TABLE IF NOT EXISTS proxy_health_events (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  endpoint_id  BIGINT NOT NULL,
  ts           DATETIME NOT NULL,
  latency_ms   INT,
  ok           TINYINT(1),
  error_code   VARCHAR(16),
  INDEX (endpoint_id, ts)
);

E.2 Index‑verifiering
EXPLAIN SELECT endpoint, p95_ms, fail_rate FROM proxy_endpoints WHERE pool='residential' AND geo_country='SE' ORDER BY score DESC LIMIT 50;


Förväntat: index på (pool, geo_country) används.

E.3 Hälsoberäkning (exempel)

Score = 100 − z(latens_p95) − 100·fail_rate, klippt till [0,100].

Körs periodiskt (t.ex. var 5:e minut) och uppdaterar proxy_endpoints.score.

F) Health‑validator & prioritering (vad som händer)

Validera nu → skapar health‑jobb som:

för varje endpoint: gör 1–2 snabba HEAD/GET mot känd “hälsosida”.

mäter latens & svarskod; loggar proxy_health_events.

Aggregerar p50/p95, fail‑rate, uppdaterar score.

Om score < min_score → degradera (lägre vikt) eller svartlista (TTL), enligt kvalitetsfilter.

Tilldelningsalgoritm använder den uppdaterade vikten på nästa allokering.

Verifiering i UI: endpoints med hög fail‑rate “sjunker” i tabellen (lägre vikt/score), nya jobb väljer andra IPs (kolla i Jobbdetaljer → Resurser → Proxy‑hälsa).

G) Acceptanskriterier & E2E
DoD (funktion)

“Lägg till proxykälla” sparar provider, verifierar auth, och fyller på endpoints (om provider API stödjer det).

“Validera nu” uppdaterar p50/p95/fail‑rate och score i ≤ 2 min för ≥ 100 endpoints.

Kvalitetsfilter påverkar urvalet (synligt i “Nya jobb → proxyval”).

Svartlista tar effekt direkt (endpoint återanvänds inte inom TTL).

Exportera hälsorapport inkluderar alla fält och går att öppna i Excel.

Sticky‑fönster efterlevs (logg visar samma endpoint för session upp till X min).

E2E‑testfall (urval)

TC‑PX‑01: Lägg till provider → endpoints syns → validera → hälsosiffror uppdateras.

TC‑PX‑02: Svartlista ett endpoint → starta jobb → endpointen används inte (kontrollera logg).

TC‑PX‑03: Höj min krav (p95/fail‑rate) → många endpoints degraderas; nya jobb får lägre latens men ev. färre geon.

TC‑PX‑04: Sticky=10m → samma endpoint i flera requests inom intervallet; därefter rotation.

TC‑PX‑05: Exportera CSV → öppna externt och verifiera p95/fail‑rate matchar UI.

H) Snabbkommandon & kontroll (praktiskt)

Hämta SE‑residential topp 10 efter score

SELECT endpoint, p95_ms, fail_rate, score
FROM proxy_endpoints
WHERE pool='residential' AND geo_country='SE' AND (blacklisted_until IS NULL OR blacklisted_until < NOW())
ORDER BY score DESC
LIMIT 10;


Kolla sticky‑allokeringar senaste 15 min

SELECT session_key, COUNT(*) cnt, MIN(allocated_at) first, MAX(allocated_at) last
FROM proxy_allocations
WHERE allocated_at > NOW() - INTERVAL 15 MINUTE
GROUP BY session_key
ORDER BY cnt DESC
LIMIT 20;


Förväntat: sticky‑sessioner återanvänder samma endpoint (se i proxy_allocations per session_key).

I) A11y, prestanda & säkerhet

A11y: tabbfokus på tabellrader, “space” för att öppna radåtgärder, aria‑labels på kartan (får tabbar “land/antal/endpoints”).

Prestanda: tabeller med virtuell scroll, server‑paginering; värmekartan förenklad för >100 länder.

Säkerhet: API‑nycklar i providers lagras krypterat; endast Admin kan uppdatera; audit log för läsningar/ändringar. 







11) Exporter
A) Enkel förklaring (för icke‑tekniker)

Här skapar du exportjobb av dina data: till filer (CSV/JSON/Excel/Parquet), kalkylark (Google Sheets), sökmotorer (Elastic/OpenSearch) och datavaror (BigQuery/Snowflake). Du väljer vad som ska med (filter), hur fälten ska heta (mappning), hur stora filer ska bli (uppdelning), vart det ska hamna, och om schemavalidering krävs. Du kan spara exportprofiler, köra igen, ladda ner senaste filen och få webhook när det är klart.

B) Detaljerad UI/UX‑spec
B.1 Layout

Filterpanel (vänster): “Datakälla (query‑builder)”, tidsspann, status, mall, taggar.

Konfigpanel (mitt): Exporttyp, Schema‑mappning, Filuppdelning, Destination, Schemavalidering.

Sidopanel (höger): Förhands‑antal (estimat), kostnadsindikator (valfritt), senaste körningar.

Åtgärdsrad: “Kör export”, “Torrkörning 1%”, “Spara exportprofil”, “Ladda ned senaste”, “Skicka test‑webhook”.

B.2 Rutor & fält

Exporttyp (dropdown):

Fil: CSV, JSON Lines, Excel (.xlsx), Parquet (komprimering valbar)

SaaS/DB: Google Sheets, Elastic/OpenSearch (bulk), BigQuery, Snowflake

Datakälla (query‑builder):

Projekt/Källa (multi‑select)

Mall(er) (multi‑select + versionfilter)

Status: validerad (default), karantän, tombstone

Datumintervall: skapad_tid (snabbval + custom)

Fältfilter (avancerat): “fält OP värde” (t.ex. payload.price > 100000)

Limit/Offset eller Cursor (för streaming‑exporter)

Preview‑knapp: visar uppskattat radantal och 20 exempelrader

Schema‑mappning (fältalias):

Dra‑och‑släpp lista över valda fält → målkolumner (med alias)

Konverteringar: string/number/date/datetime/boolean

Null‑policy: “tillåt null”/“ersätt med default”

Flatten JSON (för nested payloads)

Konfliktvarningar (dubbel alias, typkrock)

Filuppdelning:

Max rader/fil (t.ex. 500k)

Max filstorlek (MB/GB) (valfritt)

Rullande filnamn (index 00001…)

Destination:

Lokal fil (path + “öppna mapp”)

Moln (S3‑kompatibel: endpoint, bucket, path, server‑side‑encryption val)

DB‑tabell (MySQL mål, UPSERT‑policy)

Google Sheets (sheet‑id, tab‑namn, write‑mode: replace/append)

Elastic/OpenSearch (URL, index, auth, bulk‑storlek)

BigQuery (dataset, tabell, load‑mode: truncate/append)

Snowflake (stage, tabell, COPY INTO‑options)

Schemavalidering (on/off):

ON ⇒ validera rad mot måltyp (missmatch → karantänfil / error‑log)

Webhook (valfritt):

URL, metod (POST), HMAC‑hemlighet (signerar payload)

“Skicka prov” (testknapp)

B.3 Historik & status

Historiklista: jobb, typ, filtrat (komprimerad sträng), radantal, filer, destination, status (Pending/Running/Completed/Failed), tid, varningar.

Radåtgärder: “Ladda ner fil(er)”, “Öppna logg”, “Kör igen”, “Öppna mål (t.ex. Elastic index)”.

B.4 States & a11y

Skeleton vid laddning, tomt tillstånd (“Skapa din första export”).

Tangentbord: Tab ordning, Enter på “Kör export”, länkar har aria-labels.

Färg + text för status (gröna ✓ Completed, röda ✕ Failed).

C) Kommandon (curl) & API‑kontrakt
C.1 Starta export
curl -s -X POST http://localhost:8000/api/exports \
  -H "Content-Type: application/json" \
  -d '{
    "type":"file",
    "format":"csv",
    "query":{
      "project_ids":[12],
      "templates":["vehicle_detail_v1"],
      "status":["validated"],
      "from":"2025-08-01T00:00:00Z",
      "to":"2025-08-21T23:59:59Z",
      "filters":[{"field":"payload.price","op":">=","value":100000}]
    },
    "schema":{
      "columns":[
        {"source":"id","alias":"id","type":"string"},
        {"source":"payload.reg_number","alias":"reg","type":"string"},
        {"source":"payload.title","alias":"title","type":"string"},
        {"source":"payload.price","alias":"price","type":"number"}
      ],
      "null_policy":"allow",
      "flatten":true
    },
    "split":{"max_rows":500000},
    "destination":{"kind":"local","path":"exports/vehicles_%Y%m%d"},
    "validate_schema":true,
    "webhook":{"url":"https://example.ngrok.app/export-done","hmac_secret":"shhhhh"},
    "idempotency_key":"exp_vehicles_aug"
  }' | jq


Svar (ex):

{ "export_id":"exp_001", "status":"pending" }

C.2 Hämta status & filer
curl -s http://localhost:8000/api/exports/exp_001 | jq
curl -s http://localhost:8000/api/exports/exp_001/files | jq
curl -s -L http://localhost:8000/api/exports/exp_001/download?file=vehicles_00001.csv.gz -o vehicles_00001.csv.gz

C.3 Lista historik
curl -s "http://localhost:8000/api/exports?limit=20&status=completed" | jq

C.4 Skicka test‑webhook
curl -s -X POST "http://localhost:8000/api/exports/exp_001/test-webhook" | jq

D) Vad som händer (pipeline)

Planner

Räknar total rows (estimat + exakt när möjligt).

Skapar manifest:

{"export_id":"exp_001","created_at":"...","format":"csv","split":{"max_rows":500000},
 "columns":[{"source":"payload.reg_number","alias":"reg","type":"string"},...],
 "destination":{"kind":"local","path":"exports/vehicles_%Y%m%d"}}


Reader

Strömmar rader från extracted_items enligt query (indexerade kolumner).

Chunkar i batchar (t.ex. 10k rader).

Transformer/Validator

Applicerar schema‑mappning/typer, flatten, null‑policy.

Vid validate_schema=true: rad med typfel → error‑sink (.err log).

Writer

CSV/JSONL/Parquet/Excel:

Komprimering: gzip (opt‑in), filrotation vid max_rows / max_size.

Checksumma (SHA‑256) per fil + uppdaterad manifest (.sha256).

Sheets: chunkad batch‑skrivning (Append/Replace).

Elastic/OpenSearch: _bulk i 5–10 MB chunkar, id från primary_key.

BigQuery: skriv GCS/S3‑like staging + LOAD JOB (eller direkt streaming insert).

Snowflake: PUT till stage + COPY INTO <table> med schema/format.

Completer

Status → completed, skriv radantal per fil, total rows, kostnadslogg (valfritt).

Skicka webhook (HMAC‑signerad) med payload (export_id, status, filer).

E) MySQL‑schema (exporter) & index
CREATE TABLE IF NOT EXISTS exports (
  id              BIGINT PRIMARY KEY AUTO_INCREMENT,
  export_id       VARCHAR(32) UNIQUE NOT NULL,
  type            ENUM('file','sheets','elastic','bigquery','snowflake','opensearch','mysql') NOT NULL,
  format          ENUM('csv','jsonl','xlsx','parquet') NULL,
  query_json      JSON NOT NULL,
  schema_json     JSON NOT NULL,
  split_json      JSON,
  destination_json JSON NOT NULL,
  validate_schema TINYINT(1) NOT NULL DEFAULT 1,
  status          ENUM('pending','running','completed','failed','canceled') NOT NULL DEFAULT 'pending',
  row_count       BIGINT DEFAULT 0,
  file_count      INT DEFAULT 0,
  manifest_path   VARCHAR(512),
  started_at      DATETIME,
  finished_at     DATETIME,
  error_message   TEXT,
  webhook_json    JSON,
  idempotency_key VARCHAR(64),
  created_by      VARCHAR(64),
  created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX (status, created_at),
  INDEX (idempotency_key)
);

CREATE TABLE IF NOT EXISTS export_files (
  id            BIGINT PRIMARY KEY AUTO_INCREMENT,
  export_id     VARCHAR(32) NOT NULL,
  file_name     VARCHAR(512) NOT NULL,
  storage_path  VARCHAR(1024),
  rows          BIGINT,
  bytes         BIGINT,
  checksum_sha256 CHAR(64),
  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX (export_id)
);

CREATE TABLE IF NOT EXISTS export_errors (
  id            BIGINT PRIMARY KEY AUTO_INCREMENT,
  export_id     VARCHAR(32) NOT NULL,
  line_no       BIGINT,
  error_type    VARCHAR(64),
  message       TEXT,
  sample_json   JSON,
  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX (export_id)
);

F) Filstruktur & namngivning

Baspath: exports/<project_name>/<YYYY>/<MM>/<DD>/<export_id>/

Filnamn: <alias>_<YYYYMMDD>_<NNNNN>.<ext>[.gz]

Manifest: manifest.json + manifest.sha256

Error‑log: errors.ndjson (endast om fel förekom)

Signerad nedladdning (valfritt): GET /api/exports/{id}/download?... med tidsbegränsad token.

G) Verifiering (så kontrollerar du att det stämmer)
G.1 Radantal
-- Förväntat antal rader i exporten:
SET @from='2025-08-01 00:00:00'; SET @to='2025-08-21 23:59:59';
SELECT COUNT(*) AS expected
FROM extracted_items
WHERE project_id=12
  AND template_id=(SELECT id FROM templates WHERE name='vehicle_detail_v1' LIMIT 1)
  AND status='validated'
  AND created_at BETWEEN @from AND @to;


Jämför expected med exports.row_count och summering av export_files.rows.

G.2 Checksummor
sha256sum vehicles_00001.csv.gz
# jämför med export_files.checksum_sha256

G.3 Webhook

Kontrollera mottagande server‑logg: HMAC‑header X‑Export‑Signature matchar hmac(secret, body).

H) DoD & E2E‑testfall
Definition of Done

“Kör export” skapar exportjobb (pending→running→completed/failed).

Manifest + checksumma skapas och går att verifiera lokalt.

Schemavalidering ON stoppar typfel till error‑log utan att stoppa hela jobbet (om inte “blockerande” valts).

Filuppdelning respekteras (rader/fil och/eller storlek).

Destination skriver korrekt (lokal/S3/DB/Sheets/Elastic/BQ/Snowflake) och returnerar referenser.

Ladda ner senaste fungerar och ger senaste completed för aktuell profil/filtrering.

Exportprofil kan sparas/återanvändas.

RBAC: endast rättigheter kan skapa/exportera till externa mål.

E2E (Playwright/pytest)

TC‑EXP‑01: Starta CSV‑export (7 dagar, validated). Resultat: Completed, 2 filer, checksummor OK, row_count matchar SQL.

TC‑EXP‑02: Schema‑mappning typkrock → errors.ndjson innehåller felrader; manifest flaggar error_count>0.

TC‑EXP‑03: Elastic bulk (10MB chunk) → index count ökar; felhantering på bulk‑fail (retry delmängd).

TC‑EXP‑04: BigQuery → load job green; tabell innehåller kolumner enligt alias.

TC‑EXP‑05: Webhook mottagen (HMAC verifierad) med status=completed.

I) Edge‑cases, prestanda, säkerhet

Stora exporter: stream‑skrivning, backpressure, --compress, minne < 300 MB.

Excel: max ~1M rader/ark → auto‑rulla till flera ark.

JSON Lines: en rad per post; säkert för strömmar.

Parquet: kolumnärt + snabba nedströmsjobb.

Idempotens: idempotency_key hindrar dubbelkörning av samma parameterset.

Återuppta: vid avbrott fortsätt från senaste kompletta filindex.

Säkerhet: masking av PII i loggar, krypterad lagring av målcredentials, åtkomstlogg för filnedladdning.

A11y: alla knappar har tydliga aria-label, fokus, tangentbordsstöd.

12) Privacy Center (Integritet & Radering)
A) Enkel förklaring (för icke‑tekniker)

Här styr du personuppgifter (PII) och dataskydd:

Skanna data för PII (e‑post, telefon, personnummer, registreringsnummer m.m.).

Sätt retentionspolicy (hur länge sparas data).

Gör radering på begäran (med spårbar logg).

Se åtkomstlogg (vem hämtade vad, när).
Detta hjälper dig att jobba laglydigt och kontrollerat.

B) Detaljerad UI/UX‑spec
B.1 Rutor & fält

PII‑skanningsregler:

Regler (tabell): namn, typ (email|phone|personnummer|license_plate|address|ip|cookie_id|custom_regex), mål (fältlista eller “hela payload”), regex (för custom), validerare (ex. Luhn), severity (info/warn/block), masking (on/off).

Knapp: “Kör PII‑skanning nu” (väljer scope: projekt, mall, tidsspann).

Retentionspolicy:

Per mall: dagar (t.ex. vehicle_detail_v1: 180 dagar), åtgärd efter tid: tombstone | anonymize | permanent delete.

Undantag/Legal hold: flagga poster/nycklar som “skyddade” (ej raderas).

Planera rensning (schemaläggning: dagligt kl 03:00).

Raderingsflöde:

ID/nyckel (sök: item_id, primary_key/hash, e‑post/telefon m.fl.)

Matchningsmetod: exakt | normaliserad | fuzz (levenshtein ≤ 1)

Förhandsvisning: lista kandidater, riskbedömning (hur säker match), relationer (proveniens/derivat).

Åtgärd: tombstone | anonymize | permanent delete, kräver två‑stegs bekräftelse (“Skriv RADERA”).

Starta radering (skapar raderingsjobb).

Åtkomstlogg:

Tabell: vem (användare/service), vad (dataset/export), hur (UI/API), när, var (IP), ändamål (fri text), resultat.

Filter (tid, användare, projekt, export_id).

B.2 Hjälprutor & hintar

Statuskort: senaste skanning, antal flaggade, antal raderade senaste 30 d.

Runbooks: “Så bedömer du personuppgiftsrisk” (in‑app text).

C) Kommandon (curl) & API‑kontrakt
C.1 Skanna PII
curl -s -X POST http://localhost:8000/api/privacy/scan \
  -H "Content-Type: application/json" \
  -d '{
    "project_id": 12,
    "templates": ["vehicle_detail_v1"],
    "from":"2025-08-01T00:00:00Z","to":"2025-08-21T23:59:59Z",
    "rules":["email","phone","license_plate","personnummer"]
  }' | jq


Svar (ex):

{ "scan_id":"psc_101","status":"running","estimated":320000 }

C.2 Sätta retention
curl -s -X POST http://localhost:8000/api/privacy/retention \
  -H "Content-Type: application/json" \
  -d '{
    "policies":[
      {"template":"vehicle_detail_v1","days":180,"action":"tombstone"},
      {"template":"owner_v1","days":90,"action":"anonymize"}
    ]
  }' | jq

C.3 Starta radering (DSR)
# Exakt item-id
curl -s -X POST http://localhost:8000/api/privacy/erase \
  -H "Content-Type: application/json" \
  -d '{"match":{"item_id":"it_123456"}, "action":"tombstone","reason":"DSR-REQ-2025-08-21"}' | jq

# Matchning via primär nyckel (ex. reg_number)
curl -s -X POST http://localhost:8000/api/privacy/erase \
  -H "Content-Type: application/json" \
  -d '{"match":{"field":"payload.reg_number","value":"ABC123","normalize":"upper"}, "action":"permanent"}' | jq

C.4 Visa åtkomstlogg
curl -s "http://localhost:8000/api/privacy/access-log?from=2025-08-01T00:00:00Z&to=2025-08-21T23:59:59Z&user=elin" | jq

D) Vad som händer (motorik)
D.1 PII‑skanning

Körs batch‑vis mot extracted_items.payload_json (via sökbara projekterade kolumner när möjligt).

Detektorer (inbyggda):

email: robust regex + domänkontroll

phone: landsprofil (SE/EU), normalisering

personnummer (SE): format YYMMDD-XXXX eller YYYYMMDDXXXX, mod11/Luhn‑liknande kontroll

license_plate (SE): ^[A-ZÅÄÖ]{3}\s?\d{2,3}[A-ZÅÄÖ]?$ (exempel), normalisering (mellanslag/streck)

ip, mac, cookie_id (uuid4/ulid), vin

custom_regex (admin tillåten)

Policy:

severity=block → items → karantän (uppdatera status + dq_violations)

masking=on → maskera i loggar/exporter (om exportpolicy kräver)

Resultat:

privacy_findings (tabell) + DQ‑poster; dashboards uppdateras.

D.2 Retention

Schemalagd rensare läser retention_policies:

Poster äldre än days → utför action

tombstone: status→tombstone, strippar payload (sparar minsta audit)

anonymize: maskerar fält (hash/supprimera); bevarar icke‑PII

permanent delete: DELETE i primära tabeller + tombstone‑kvitto i audit

Legal hold flagg: hoppa över poster med hold.

D.3 Raderingsflöde (DSR)

Matchning (exakt/normaliserad/fuzz) genererar raderingsmanifest:

Lista av item_id + referenser (bilagor, snapshots, härkomst)

Genomför åtgärd:

Uppdaterar/tejpar bort primärdata

Tar bort attachmentfiler (skärmdumpar/HTML) eller ersätter med “redacted”

Lägger block‑list entry i do_not_process för ny insamling på samma nyckel (om policy kräver)

Kvitto:

Genereras receipt_id med signatur + sammanfattning (antal poster, tabeller, tidsstämpel).

D.4 Åtkomstlogg

Interception i API/UI/Export: varje läsning/export av data loggas:

who (user/service), what (dataset/export_id), why (purpose), when, where (ip/user-agent), result.

Append‑only (inte raderbar), WORM‑flagga (write‑once‑read‑many) om stöds.

E) MySQL‑schema (privacy)
CREATE TABLE IF NOT EXISTS privacy_rules (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  name       VARCHAR(64) UNIQUE,
  type       ENUM('email','phone','personnummer','license_plate','ip','cookie_id','vin','custom_regex') NOT NULL,
  target     JSON NOT NULL,       -- fältlista eller ["*"] för payload
  regex      TEXT,
  severity   ENUM('info','warn','block') DEFAULT 'warn',
  masking    TINYINT(1) DEFAULT 1,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS privacy_findings (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  item_id    VARCHAR(32) NOT NULL,
  rule_id    BIGINT NOT NULL,
  field      VARCHAR(128) NULL,
  snippet    VARCHAR(256) NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX (item_id), INDEX (rule_id), INDEX (created_at)
);

CREATE TABLE IF NOT EXISTS retention_policies (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  template   VARCHAR(128) NOT NULL,
  days       INT NOT NULL,
  action     ENUM('tombstone','anonymize','delete') NOT NULL,
  exceptions JSON,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY (template)
);

CREATE TABLE IF NOT EXISTS erase_requests (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  request_id   VARCHAR(40) UNIQUE,
  match_json   JSON NOT NULL,
  action       ENUM('tombstone','anonymize','delete') NOT NULL,
  reason       VARCHAR(256),
  status       ENUM('pending','running','completed','failed') DEFAULT 'pending',
  actor        VARCHAR(64),
  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  finished_at  DATETIME
);

CREATE TABLE IF NOT EXISTS erase_manifests (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  request_id   VARCHAR(40) NOT NULL,
  item_id      VARCHAR(32) NOT NULL,
  action       ENUM('tombstone','anonymize','delete') NOT NULL,
  status       ENUM('planned','done','skipped','failed') DEFAULT 'planned',
  message      TEXT,
  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX (request_id), INDEX (item_id)
);

CREATE TABLE IF NOT EXISTS do_not_process (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  key_field  VARCHAR(128) NOT NULL,    -- t.ex. payload.reg_number
  key_value  VARCHAR(256) NOT NULL,    -- normaliserad
  reason     VARCHAR(256),
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY (key_field, key_value)
);

CREATE TABLE IF NOT EXISTS access_log (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  ts         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  actor      VARCHAR(64) NOT NULL,
  action     ENUM('read','export','download','query') NOT NULL,
  resource   VARCHAR(128) NOT NULL,
  resource_id VARCHAR(64),
  purpose    VARCHAR(256),
  ip         VARCHAR(64),
  user_agent VARCHAR(256),
  result     ENUM('ok','denied','error') DEFAULT 'ok',
  INDEX (ts), INDEX (actor), INDEX (resource)
);

F) Verifiering (praktiska kontroller)
F.1 PII‑skanning gav karantän?
SELECT COUNT(*) FROM privacy_findings WHERE created_at > NOW() - INTERVAL 1 DAY;
SELECT COUNT(*) FROM extracted_items WHERE status='quarantine' AND created_at > NOW() - INTERVAL 1 DAY;


Förväntat: findings ökar; items i karantän speglar blockerande regler.

F.2 Retention rensade?
SELECT COUNT(*) FROM extracted_items
WHERE template_id=(SELECT id FROM templates WHERE name='vehicle_detail_v1' LIMIT 1)
  AND created_at < NOW() - INTERVAL 180 DAY;


Förväntat: 0 (om action=tombstone/delete).
Kontrollera även audit/tombstone‑kvitton (om implementerat separat).

F.3 Radering (DSR)
SELECT status FROM erase_requests WHERE request_id='REQ123';
SELECT status, COUNT(*) FROM erase_manifests WHERE request_id='REQ123' GROUP BY status;
SELECT COUNT(*) FROM do_not_process WHERE key_field='payload.reg_number' AND key_value='ABC123';


Förväntat: completed, planned=0, done>0, blocklist har posten.

F.4 Åtkomstlogg
SELECT actor, action, resource, ts 
FROM access_log 
WHERE actor='elin' AND ts > NOW() - INTERVAL 1 DAY;


Förväntat: rader som motsvarar dina UI/API‑läsningar och exporter.

G) DoD & E2E‑testfall
Definition of Done

PII‑regler kan sparas/köras; findings skapas; blockerande regler sätter karantän.

Retention kör enligt schema och utför tombstone/anonymize/delete korrekt.

Radering (DSR) matchar enligt vald metod, två‑stegs bekräftelse, skapar manifest, genomför åtgärd och skriver kvitto.

Åtkomstlogg fångar UI/API‑läsningar, exporter och nedladdningar.

RBAC: Endast Admin/Privacy Officer får skapa/ändra regler och radering; Läsare kan se policys och findings men inte agera.

Maskning i loggar och exporter enligt policy (vid “masking=on”).

Block‑list hindrar återinsaml-ing av raderade nycklar (om policy aktiv).

E2E (urval)

TC‑PRIV‑01: Lägg till “email” + “personnummer” regler; kör skanning 7 dagar; items flaggas; karantän ökar.

TC‑PRIV‑02: Sätt vehicle_detail_v1: 180 dagar → tombstone; kör rensare; gamla poster får status tombstone.

TC‑PRIV‑03: DSR via payload.reg_number=ABC123 → delete; manifest visar 3 poster; attachments raderas; do_not_process innehåller regnumret.

TC‑PRIV‑04: Export efter maskpolicy → känsliga fält maskade (****/hash).

TC‑PRIV‑05: Access‑log visar “export” och “download” med korrekt aktör och resultat.

H) Edge‑cases, prestanda, säkerhet

Falska positiver i PII: stöd för whitelist (fält/regex) och “acknowledge finding”.

Anonymisering: stöder hash (saltad), mask (delvis), generalisering (k‑anon, binning) för numeriska fält.

Backups: vid “permanent delete” – skapa “proof‑of‑delete”‑kvitto; säkerställ att återställning inte återuppstår raderade poster (policy: “selective restore” eller “legal tombstone”).

Prestanda skanning: kör i batchar med index; använd projekterade kolumner (t.ex. payload_reg_number) om ofta efterfrågat.

A11y: tydliga varningar/etiketter; tangentbord genom hela flödet; “radera” kräver textbekräftelse.

Säkerhet: alla privacy‑åtgärder kräver step‑up auth (t.ex. OTP/U2F); audit‑logg är append‑only.

Snabb “hur‑du‑gör” (sammanhållet exempel)

1) Skanna PII (senaste 30 dagar)

FROM=$(date -u -d "-30 days" +"%Y-%m-%dT%H:%M:%SZ")
TO=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
curl -s -X POST http://localhost:8000/api/privacy/scan \
  -H "Content-Type: application/json" \
  -d "{\"project_id\":12,\"from\":\"$FROM\",\"to\":\"$TO\",\"rules\":[\"email\",\"personnummer\"]}" | jq


2) Sätt retention & kör rensning nu

curl -s -X POST http://localhost:8000/api/privacy/retention -H "Content-Type: application/json" \
  -d '{"policies":[{"template":"vehicle_detail_v1","days":180,"action":"tombstone"}]}' | jq
curl -s -X POST http://localhost:8000/api/privacy/run-retention | jq


3) Radera på begäran (regnummer)

curl -s -X POST http://localhost:8000/api/privacy/erase -H "Content-Type: application/json" \
  -d '{"match":{"field":"payload.reg_number","value":"ABC123","normalize":"upper"}, "action":"delete","reason":"DSR-REQ-2025-08-21"}' | jq


4) Visa access‑logg för dagens exporter

curl -s "http://localhost:8000/api/privacy/access-log?from=$(date -u +"%Y-%m-%d")T00:00:00Z&action=export" | jq


Med detta har vi Exporter och Privacy Center definierade in i minsta detalj:

komplett UI/UX,

API‑kontrakt och körbara kommandon,

MySQL‑scheman och index,

pipelines (planerare/reader/validator/writer),

verifieringssteg, DoD, E2E‑testfall, samt prestanda‑, A11y‑ och säkerhetskrav.









13) Policies (Policystudion)
A) Enkel förklaring

Det här är kontrollrummet för hur vi beter oss mot en domän: hastighet, renderingsläge, headers/Referer, cookie‑consent, robots/ToS, och felreaktioner (circuit breakers). Du sparar en policy för exempel.se (eller mönster som *.exempel.se) och alla jobb mot den domänen följer samma regler — konsekvent, säkert och lätt att ändra. Du kan också simulera “hur skulle en fetch se ut?” och utrulla ändringar live till pågående jobb.

B) UI/UX – sidor, rutor, knappar
B.1 Översiktssida “Policystudion”

Sök + filter: domän, taggar, status (utkast/publicerad), uppdaterad av, ändrat senaste X dagar.

Tabell: domänmönster, version, sammanfattning (RPS/render/headers), senast ändrad, “påverkar N jobb”.

Radåtgärder: Öppna / Duplicera / Arkivera / Historik (diff mellan versioner).

Knappar: “Ny policy”, “Importera från YAML/JSON”, “Exportera vald”.

B.2 Redigerare för en policy

Sektioner (accordion):

Bas

Domänmönster (text, req): t.ex. car.info eller *.car.info

Beskrivning (text)

Taggar (chips)

Hastighet & Politeness

RPS (Requests/sek) (tal, ex 1.2)

Burst (tal)

Jitterintervall (ms, ex 200–1200)

Per‑värd samtidighet (tal)

Crawl‑delay (ms)

Time budget per request (ms, timeout)

Retrypolicy (max, backoff: linjär/exponentiell med cap)

Renderingsstrategi

Strategi: Auto / HTTP / Browser

Auto‑heuristik (toggles): “JS‑indikatorer”, “AJAX‑signaler”, “tom DOM”

Browser‑detaljer:

Wait: domcontentloaded | networkidle | selector(...)

Viewport (px), UA‑profil, Timezone, Geo

Stealth‑nivå (bas | avancerad)

Blockera resurser (bilder/video/annons/3:e part)

Sticky session (minuter)

Headers & Referer

Header‑profil: desktop/sv-SE | mobil/sv-SE | custom

Accept‑Language (ex sv-SE,sv;q=0.9,en;q=0.7)

Accept/Cache‑Control/Upgrade‑Insecure‑Requests (templates)

Referer‑policy:

Auto (sätter föregående URL)

Explicit (textfält)

Ingen (tom)

DNT/SEC‑CH toggles (slumpad per session valbart)

Consent & Cookies

Consent‑strategi:

Klicka “Godkänn” via selector (CSS)

Försök sätta consent‑cookie före load (nyckel=värde; TTL)

Hoppa över (om inte visad)

Cookie‑jar per domän (återanvänd/persistens)

SameSite/secure enforcement (valfritt)

Robots/ToS

Robots‑läge:

Respektera (default)

Respektera + Crawl‑delay

Ignorera (kräver manuellt godkännande med checkbox)

ToS‑krav:

“Kräv granskning & godkännande före körning” (med länkfält)

“Visa varning i Job Launcher”

Felbeteende (Circuit breakers)

Trösklar:

429‑frekvens > X% (fönster N min) ⇒ sänk RPS 50%, byt proxy

403/5xx > Y% ⇒ paus domän i Z min

CAPTCHA detekterad ⇒ eskalera till Browser + Sticky + längre väntan

P95‑latens > T ms ⇒ minska samtidighet

Åtgärdstabell: villkor → åtgärder (ordnade, första träff vinner)

Poison queue: ﬂytta URL vid >M misslyckade försök

Knappar (top‑bar):

Spara policy (utkast → publicerad)

Simulera mot URL

Applicera på befintliga jobb (modal med lista över påverkade jobb)

Policy‑hälsa (visar varningsregler, senaste triggers)

Micro‑UX:

Inbyggd validering (t.ex. domänmönster, rimlig RPS).

Konfliktvarningar (om flera policies matchar samma domän – se prioritet nedan).

Diff‑visning mellan versioner (“vad ändrades?”).

Tangentbord: Ctrl/Cmd+S Spara, Ctrl/Cmd+Enter Simulera.

C) Policymodell – arv, prioritet, versioner

Hierarki & arv (högst → lägst):

Explicit domänpolicy (sub.domain.tld)

Wildcard (*.domain.tld)

Projektpolicy (default för projektet)

Global default

Prioritet: mest specifik match vinner; vid lika specifik:

högst version vinner (om båda publicerade)

annars senast uppdaterad vinner

Versionering:

Utkast → Publicera (skapar vN)

Rollback till tidigare publicerad version

Audit‑logg: vem ändrade vad

Räckvidd:

Policy binds till domän och subdomäner enligt mönster

Kan även bindas till scheman (http/https) om behov

D) Backend‑API (kontrakt)
POST /api/policies
{ "domain_pattern":"*.car.info","description":"SE profile",
  "tags":["se","cars"],
  "speed":{"rps":1.5,"burst":3,"jitter_ms":[200,1200],"per_host_concurrency":2,"crawl_delay_ms":800,"timeout_ms":15000,
           "retry":{"max":3,"backoff":"exp","cap_ms":60000}},
  "render":{"mode":"auto","wait_for":"networkidle","viewport":{"w":1366,"h":768},
            "ua_profile":"desktop_chrome_125","timezone":"Europe/Stockholm","geo":"SE",
            "stealth":"advanced","block":{"images":true,"video":true},"sticky_minutes":10},
  "headers":{"profile":"desktop_sv","accept_language":"sv-SE,sv;q=0.9,en;q=0.7","referer":"auto","dnt":"random"},
  "consent":{"mode":"click","selector":"button#accept","pre_cookie":{"name":"consent","value":"yes","ttl_days":365}},
  "robots":{"mode":"respect","crawl_delay_ms":800},
  "tos":{"require_approval":true,"link":"https://car.info/terms"},
  "failover":{"rules":[
      {"if":{"code":"429","rate_gt":0.05,"window_min":5},"then":{"rps_factor":0.5,"proxy":"rotate"}},
      {"if":{"code":"403|503","rate_gt":0.1},"then":{"pause_domain_min":10}},
      {"if":{"captcha":true},"then":{"render":"browser","sticky_minutes":15,"delay_ms":1500}}
  ]},
  "status":"draft"
}

POST /api/policies/{id}/publish         -> {version: 3}
POST /api/policies/{id}/simulate
{ "url":"https://www.car.info/sv-se/license-plate/S/GDT620" }

POST /api/policies/{id}/apply-to-jobs
{ "job_ids":["job_abc","job_def"] }    -> 202 accepted

GET  /api/policies?domain=car.info
GET  /api/policies/{id}
GET  /api/policies/{id}/history


Pub/Sub utrullning till workers

POST /api/policies/broadcast
{ "policy_id":123, "version":3, "op":"update" } -> workers lyssnar och laddar ny profil

E) MySQL‑schema (policies)
CREATE TABLE IF NOT EXISTS policies (
  id              BIGINT PRIMARY KEY AUTO_INCREMENT,
  domain_pattern  VARCHAR(255) NOT NULL, -- ex *.car.info
  description     VARCHAR(255),
  tags            JSON,
  speed_json      JSON NOT NULL,
  render_json     JSON NOT NULL,
  headers_json    JSON NOT NULL,
  consent_json    JSON,
  robots_json     JSON,
  tos_json        JSON,
  failover_json   JSON,
  status          ENUM('draft','published','archived') NOT NULL DEFAULT 'draft',
  current_version INT NOT NULL DEFAULT 0,
  priority        INT NOT NULL DEFAULT 100, -- lägre = viktigare (override)
  created_by      VARCHAR(64),
  updated_by      VARCHAR(64),
  created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY (domain_pattern, status, priority)
);

CREATE TABLE IF NOT EXISTS policy_versions (
  id             BIGINT PRIMARY KEY AUTO_INCREMENT,
  policy_id      BIGINT NOT NULL,
  version        INT NOT NULL,
  snapshot_json  JSON NOT NULL,
  published_by   VARCHAR(64),
  published_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY (policy_id, version),
  INDEX (published_at)
);

CREATE TABLE IF NOT EXISTS policy_applied (
  id             BIGINT PRIMARY KEY AUTO_INCREMENT,
  job_id         VARCHAR(32) NOT NULL,
  domain         VARCHAR(255) NOT NULL,
  policy_id      BIGINT NOT NULL,
  version        INT NOT NULL,
  applied_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX (job_id), INDEX (domain), INDEX (applied_at)
);


Index‑verifiering

EXPLAIN SELECT * FROM policies WHERE domain_pattern='*.car.info' AND status='published' ORDER BY priority ASC LIMIT 1;

F) Kommandon & Verifiering

Skapa och publicera policy

# Skapa
curl -s -X POST http://localhost:8000/api/policies \
  -H "Content-Type: application/json" \
  -d @policy_car_info.json | jq

# Publicera
curl -s -X POST http://localhost:8000/api/policies/123/publish | jq


Förväntat: version: 1, status i DB published.

Simulera mot URL

curl -s -X POST http://localhost:8000/api/policies/123/simulate \
  -H "Content-Type: application/json" \
  -d '{"url":"https://www.car.info/sv-se/license-plate/S/GDT620"}' | jq


Förväntat i svar: vilken renderingsstrategi, headers, proxy/geo, RPS, consent‑åtgärd som skulle gälla, plus “hur en request skulle se ut”.

Applicera på jobb

curl -s -X POST http://localhost:8000/api/policies/123/apply-to-jobs \
  -H "Content-Type: application/json" \
  -d '{"job_ids":["job_abc"]}' | jq


Förväntat: accepted:true, och i Jobbdetaljer → Inställningar syns policy: car.info v1.

SQL‑kontroll

SELECT job_id, domain, policy_id, version, applied_at
FROM policy_applied
ORDER BY applied_at DESC LIMIT 5;


Förväntat: nya rader efter utrullning.

G) Vad händer i systemet

Spara policy: skrivs som utkast. “Publicera” → snapshot i policy_versions, status published, current_version++.

Broadcast: UI kallar /broadcast; workers laddar ny policy i minne; pågående jobb uppdaterar per‑domän kontext innan nästa request.

Simulera: kör http‑headless torr‑hämtning (ej full fetch) + heuristik → returnerar vilken väg som skulle väljas.

Applicera på befintliga jobb: skriv control‑meddelande till scheduler → varje worker “hot‑swapar” policy för matchande domäner.

H) Acceptanskriterier (DoD) & E2E

DoD

Mest specifik policy matchar (wildcard/explicit) och visas i Jobbdetaljer.

RPS/jitter/render/header/consent/robots tillämpas i realtid (nästa request).

Circuit‑breakers triggar och syns som event i Jobbdetaljer (med åtgärd).

Simulering visar samma beslut som verklig körning (för en test‑URL).

Audit & versioner är fullständiga (diff & rollback fungerar).

E2E‑fall (urval)

POL‑01: Skapa *.car.info, publish → starta jobb → Jobbdetaljer visar policy v1.

POL‑02: Sänk RPS i policy → broadcast → throughput minskar inom 10s.

POL‑03: 429‑spike → circuit breaker sänker RPS och byter proxy; logg visar åtgärd.

POL‑04: Simulera car.info‑URL → render=browser; kör torrjobb → verklig körning använder browser.

Edge‑cases

Konflikt mellan två wildcard → lägre priority vinner.

Manuellt godkännande krävs för robots: ignore → Job Launcher varnar och blockerar utan checkbox.

Hög latens + sticky → fallback: minska samtidighet, förläng timeout.

14) DQ & Analys (Data Quality)
A) Enkel förklaring

Det här är hälsokollen för dina data. Du ser:

Fyllnadsgrad (hur ofta fält är ifyllda),

Valideringsfel (regex/typ/Luhn m.m.),

Selector‑drift (när en malls selektorer slutar träffa),

Trender över tid.
Du kan skapa varningsregler (t.ex. “om VIN‑fyllnad < 98% i 1h → skicka avisering”), öppna felposter och lägga till regressionstester som körs automatiskt på mallar.

B) UI/UX – sidor, widgets, interaktion
B.1 Översikt “Data Quality”

Filterrad: Projekt, Mall (version), Tidsintervall, Status, Taggar.

Widgets:

Fyllnadsgrad per fält (top‑N, staplar)

Valideringsfel per regel (donut/heatmap)

Selector‑drift‑score per mall (0–100)

Jämförelse över tid (sparkline: completeness/validity/uniqueness)

DQ‑hälsa trafikljus (grön/gul/röd) med sammanlagd score

Tabbar: “Översikt” | “Fält” | “Regler” | “Drift” | “Historik”

B.2 Flik “Fält”

Tabell: fält, typ, completeness %, null‑rate, distinct, exempelvärden, trend (upp/ner), senaste ändring (mallversion).

Klick öppnar fält‑detalj (distribution, boxplot/outliers, exempelposter, export felprov).

B.3 Flik “Regler”

Valideringsregler: regex/enum/range/luhn/relationsregler.

Heatmap över fail‑rate per regel över tid.

Radåtgärder: “Visa felposter”, “Justera regel”, “Skapa varningsregel”.

B.4 Flik “Drift”

Selector‑drift (per selector i mall):

Drift‑score 0–100 (100 = stabil) baserat på:

Match‑rate‑ändring (Δ träffar/100 sidor)

DOM‑hash‑skillnad kring element (SimHash/ssdeep)

Textlängds‑/mönsterförändring

Tidsserie + “Senaste DOM‑snapshot” & skärmdump vid drift.

Åtgärdsknappar: “Öppna i Selector Tool”, “Skapa regressionstest”.

B.5 Flik “Historik”

DQ‑milstolpar: publiceringar, regressionsinföranden, regeländringar, incidenter (larm).

B.6 Åtgärdsknappar (globalt)

Skapa varningsregel (modal)

Öppna felposter (tar dig direkt till Datalager med filtrering)

Lägg till regressionstest (binder test‑URL:er till mall/selector)

A11y & microcopy: varningar har tydlig text + ikon + länk “Läs mer”. Kortkommandon: / för att söka fält/regler, R för att skapa varningsregel.

C) DQ‑motor – vad mäts och hur
C.1 Mått & definitioner

Completeness (per fält) = 1 − null_rate

Validity (per regel) = giltiga / kontrollerade

Uniqueness (per nyckel) = 1 − (dubbletter / totala)

Freshness = andel nya poster senaste X timmar

Selector match‑rate = träffade noder / förväntade

Drift‑score = 100 − w1·Δmatch_rate − w2·DOM_diff − w3·text_diff (klippt [0,100])

C.2 Aggregering

Batching (var 1–5 min): sammanställ senaste körningar (Jobbdetaljer → Output).

Retention: behåll DQ‑tidsserier 90–365 dagar.

C.3 Larm/Regler

Villkor: trösklar över tidsfönster (t.ex. “VIN completeness < 0.98 under 30 min”).

Notifieringar: e‑post, webhook (HMAC), Slack/Teams.

Hysteresis: undvik “fladdrande” larm (kräv 2–3 datapunkter).

D) Backend‑API (kontrakt)
GET  /api/dq/overview?project=12&template=vehicle_detail_v1&from=...&to=...
GET  /api/dq/fields?template=vehicle_detail_v1
GET  /api/dq/rules?template=vehicle_detail_v1
GET  /api/dq/drift?template=vehicle_detail_v1
POST /api/dq/alerts
{ "name":"VIN under 98%","project_id":12,"template":"vehicle_detail_v1",
  "condition":{"metric":"completeness","field":"vin","op":"<","value":0.98,"window_min":30},
  "notify":{"email":["dq@company.se"],"webhook":{"url":"https://...","hmac":"secret"}},
  "enabled":true }

POST /api/dq/regression-tests
{ "template":"vehicle_detail_v1","urls":["https://.../car1","https://.../car2"], "expected":{"vin":"regex:^[A-HJ-NPR-Z0-9]{17}$"} }

POST /api/dq/run-regression
{ "template":"vehicle_detail_v1","test_id":"rt_123" }

E) MySQL‑schema (DQ)
CREATE TABLE IF NOT EXISTS dq_metrics (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  project_id   BIGINT NOT NULL,
  template     VARCHAR(128) NOT NULL,
  field        VARCHAR(128) NULL,
  metric       ENUM('completeness','validity','uniqueness','freshness','match_rate','drift_score') NOT NULL,
  value        DOUBLE NOT NULL,
  window_min   INT NOT NULL,
  ts           DATETIME NOT NULL,
  INDEX (project_id, template, metric, ts),
  INDEX (template, field, metric, ts)
);

CREATE TABLE IF NOT EXISTS dq_rules (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  template   VARCHAR(128) NOT NULL,
  rule_type  ENUM('regex','enum','range','luhn','relation') NOT NULL,
  field      VARCHAR(128),
  config     JSON NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS dq_alerts (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  name       VARCHAR(128) NOT NULL,
  project_id BIGINT NOT NULL,
  template   VARCHAR(128),
  condition  JSON NOT NULL,    -- metric/op/value/window
  notify     JSON NOT NULL,    -- email/webhook/slack
  enabled    TINYINT(1) DEFAULT 1,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS dq_alert_events (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  alert_id   BIGINT NOT NULL,
  triggered_at DATETIME NOT NULL,
  status     ENUM('firing','resolved') NOT NULL,
  snapshot   JSON NOT NULL,    -- värden som orsakade larmet
  INDEX (alert_id, triggered_at)
);

CREATE TABLE IF NOT EXISTS selector_drift (
  id           BIGINT PRIMARY KEY AUTO_INCREMENT,
  template     VARCHAR(128) NOT NULL,
  selector_key VARCHAR(128) NOT NULL, -- t.ex. field_name eller path-id
  match_rate   DOUBLE NOT NULL,
  dom_simhash  BIGINT NOT NULL,
  text_simhash BIGINT NOT NULL,
  drift_score  DOUBLE NOT NULL,
  ts           DATETIME NOT NULL,
  INDEX (template, selector_key, ts)
);

CREATE TABLE IF NOT EXISTS dq_regressions (
  id          BIGINT PRIMARY KEY AUTO_INCREMENT,
  test_id     VARCHAR(32) UNIQUE NOT NULL,
  template    VARCHAR(128) NOT NULL,
  urls_json   JSON NOT NULL,
  expected_json JSON,
  created_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS dq_regression_runs (
  id          BIGINT PRIMARY KEY AUTO_INCREMENT,
  test_id     VARCHAR(32) NOT NULL,
  run_id      VARCHAR(32) NOT NULL,
  status      ENUM('running','passed','failed') NOT NULL,
  result_json JSON,
  started_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  finished_at DATETIME,
  INDEX (test_id, started_at)
);


Index‑verifiering

EXPLAIN SELECT * FROM dq_metrics WHERE template='vehicle_detail_v1' AND metric='completeness' AND ts BETWEEN NOW()-INTERVAL 7 DAY AND NOW();

F) Kommandon & Verifiering

Skapa varningsregel

curl -s -X POST http://localhost:8000/api/dq/alerts \
  -H "Content-Type: application/json" \
  -d '{
    "name":"VIN completeness < 98%",
    "project_id":12,"template":"vehicle_detail_v1",
    "condition":{"metric":"completeness","field":"vin","op":"<","value":0.98,"window_min":60},
    "notify":{"email":["dq@acme.se"],"webhook":{"url":"https://example.ngrok.app/dq","hmac":"shhhhh"}},
    "enabled":true
  }' | jq


Förväntat: svar med id, syns i UI under “Varningsregler”.

Lägga regressionstest

curl -s -X POST http://localhost:8000/api/dq/regression-tests \
  -H "Content-Type: application/json" \
  -d '{"template":"vehicle_detail_v1","urls":["https://site/car/1","https://site/car/2"],"expected":{"vin":"regex:^[A-HJ-NPR-Z0-9]{17}$"}}' | jq


Förväntat: test_id, syns under “Regressionstester”.

Köra regression

curl -s -X POST http://localhost:8000/api/dq/run-regression \
  -H "Content-Type: application/json" \
  -d '{"template":"vehicle_detail_v1","test_id":"rt_123"}' | jq


Förväntat: run_id, senare status=passed|failed.

SQL‑kontroller

-- Se completeness för VIN senaste dygnet
SELECT AVG(value) avg_comp
FROM dq_metrics
WHERE template='vehicle_detail_v1' AND field='vin' AND metric='completeness'
  AND ts > NOW() - INTERVAL 1 DAY;

-- Senaste drift-score per selector
SELECT selector_key, drift_score
FROM selector_drift
WHERE template='vehicle_detail_v1'
ORDER BY ts DESC LIMIT 20;

-- Larm som utlösts
SELECT a.name, e.triggered_at, e.status
FROM dq_alert_events e JOIN dq_alerts a ON a.id=e.alert_id
ORDER BY e.triggered_at DESC LIMIT 20;

G) Algoritmer – selector‑drift (förenklad)

Match‑rate‑Δ: jämför senaste 100 sidor vs tidigare 100 (z‑score)

DOM‑hash: bygg text av föräldranoder (taggar/klasser) ±2 nivåer, SimHash → Hamming‑distans

Text‑hash: normaliserad innerText, SimHash → Hamming‑distans

Drift‑score:
100 − (w1*scaledΔ + w2*dom_dist + w3*text_dist) (klipp [0,100])
T.ex. w1=0.5, w2=0.3, w3=0.2

Trösklar (förslag):

Varning om score < 80 (2 datapunkter i rad)

Kritisk om score < 60 → autoskapa rekommendation att kontrollera mallen

H) Vad händer (händelseflöde)

Ingest: Efter varje batch extraktion skickas rå statistik → DQ‑aggregator.

Aggregera: Räkna completeness/validity/uniqueness; beräkna drift per selector.

Skriv: dq_metrics, selector_drift.

Larmmotor: utvärderar regler var 1–5 min; skickar notifieringar; loggar i dq_alert_events.

UI: Widgets pollar (eller via WS) DQ‑serierna; drill‑down öppnar Datalager.

I) Acceptanskriterier (DoD) & E2E

DoD

Widgets visar korrekta mått; filtrering påverkar direkt.

“Skapa varningsregel” utlöser notiser när villkor uppfylls.

“Öppna felposter” landar i Datalager med rätt filter.

“Lägg till regressionstest” körs i CI (kan köras manuellt) och spärrar publicering om test fallerar (valbar spärr).

Selector‑drift markerar verkliga DOM‑ändringar (visar snapshot/screenshot).

E2E‑fall

DQ‑01: Sänk medvetet VIN‑träff → completeness < tröskel → larm inom 5 min.

DQ‑02: DOM‑ändring på target‑site → drift‑score faller → varning → öppna Selector Tool.

DQ‑03: Lägg regression → ändra mallen (introducera fel) → regression “failed” → publicering blockeras (om spärr aktiv).

DQ‑04: Öka valideringsfel (regex) → “Öppna felposter” visar exakta rader.

Edge‑cases

Små datamängder → visa konfidensintervall och undertryck larm om n<50.

Batch‑ryckighet → använd glidande medel och hysteresis.

Multi‑version mall → segmentera metrik per version.

J) Snabb “hur‑du‑gör”

1) Skapa policy för car.info och publicera

Enkelt: Vi sätter låg RPS, browser‑läge, svensk UA, SE‑geo, consent‑klick.

Kommandon: (se “Policy‑API” ovan)

Vad händer: policy publiceras, broadcastas; workers laddar ny profil.

Verifiera: Jobbdetaljer → Inställningar visar policy car.info v1; throughput sjunker till vald RPS.

2) Skapa DQ‑varning för VIN

Enkelt: Larma om VIN saknas i >2% av posterna i en timme.

Kommandon: (alert POST ovan)

Vad händer: larm triggas när villkor uppfylls, mail/webhook går ut.

Verifiera: dq_alert_events innehåller firing, och UI visar banner.


15) Scheduler & Aviseringar
Mål & principer

Mål: Tillförlitlig, förutsägbar körning av jobb med tydlig kalenderöversikt, smart prioritering och brusfria aviseringar.

Principer: UTC i backend, lokaltid i UI; idempotens i alla körningar; “safe by default” (ingen överlappning om inte uttryckligen tillåtet); observability först.

Domänobjekt (översikt)

Job: definition (typ, parametrar, versions‑hash, ägare).

Schedule: cron‑liknande uttryck eller intervall + start/stop + tidszon.

Window: off‑peak (uppmuntra körning) / blackout (förbjud) / maintenance (begränsa).

PriorityRule: vikt, SLA, könamn, fairness‑policy.

Dependency: requires (DAG), mutex (ömsesidig uteslutning), throttle (rate limit per nyckel).

Run: en körning med status, attempts, tidsstämplar, worker, cost, loggreferenser.

NotificationRule: villkor (on_success|on_failure|on_sla_breach|on_queue_delay|digest), kanal(er), mall.

Channel: e‑post, Slack, webhook (signerad), + ev. MS Teams.

RetryPolicy: max försök, backoff (exponentiell med jitter), timeouts, dead‑letter.

CalendarException: helgdagar, DST‑policy, lokala undantag.

UI/UX
Rutor

1) Jobbkalender

Vy-lägen: Dag, Vecka, Månad, “Lista” (kommande 100 körningar), samt “Heatmap” (belastning per timme).

Färgkoder:

Grön = planerad/ok, Blå = körs, Orange = väntar p.g.a. fönster/beroenden, Röd = misslyckad/sla-breach, Grå = pausad.

Detaljpanel (höger): när du klickar en händelse visas: jobbnamn, schema, nästa 10 körningar, uppskattad körtid/kostnad, senaste 5 utfall, aktiva fönster och regler som påverkar.

Drag‑&‑drop: justera en enskild körning (skapar override), eller dra ett schema‑block (uppdaterar Schedule). “Ångra” direkt i toast.

Överlägg: Visa off‑peak (grönt skimmer), blackout (skraffering), maintenance (gul kant). Tooltip för orsak.

Konfliktindikatorer: icon‑chips (⚠️) där körning skulle bryta mot fönster/konkurrens/beroende. Klick öppnar “lös konflikt”-guiden.

2) Prioritetsregler

Rule builder: IF (kö == X/label == Y/SLA < N/ägare == teamZ/avg runtime > T/… ) THEN set priority = N; queue = K; preemption = true/false; concurrency cap = M; fairness = weighted round‑robin( vikt ).

Simulering: mata in “syntetiskt dygn” → se kö‑latens och starttider före/efter regel.

Ordning & Ärftlighet: visa staplad utvärderingsordning; konfliktdetektion (“regel A skuggar regel B”).

3) Fönster (off‑peak)

Typer: Off‑peak (rekommenderad körning), Blackout (blockera), Maintenance (tillåt endast jobb med tag maintenance_ok).

Tidszon: definieras per fönster (org‑default förslag). UI varnar om DST‑övergång påverkar nästa körning.

Undantag: “tillåt trots fönster” för specifika jobb eller datumspann. Loggas och kräver motivering.

Förhandsvisning: overlay i kalender + lista med “påverkade körningar”.

4) Aviseringskanaler

Kanaler: E‑post (SMTP/SES), Slack (webhook/app), Webhook (HMAC‑signering), valbar Teams.

Mall‑editor: Markdown + variabler ({{job.name}}, {{run.id}}, {{error.summary}}, {{metrics.runtime_ms}}, länk till loggar).

Bruskontroll: hysteresis (t.ex. max 1 felnotis per 15 min), digest (sammanfattning varje timme), eskalering efter N fel (till on‑call).

Tyst läge: tysta notiser under definierade timmar, men tagga allvarliga SLA‑brott som “genombrytande”.

Knappar & flöden

“Schemalägg”

Öppnar wizard (3–5 steg):

Välj jobbtyp (med parameterform + validering),

Välj schema (cron builder med “exempel” + next 5 runs),

Regler (prioritet, concurrency, retry policy),

Aviseringar (regler + kanaler + mall),

Sammanfattning (diff + kostnadsestimat + konflikter).

Valideringar: cron giltig; tidszon satt; kollisioner med blackout; concurrency ≤ kapacitet; beroenden acykliska.

Resultat: skapar/uppdaterar Schedule, genererar nästa körningar, triggar “torrkörning” (simulerad queuing).

“Pausa fönster”

Snabb‑toggle per fönster eller “global paus” (med TTL).

Banner i kalender (“Paus aktiv till 14:00”) + lista över vilka jobb som hålls tillbaka.

Kräv motivering & auditlogga.

“Testa avisering”

Välj kanal(er) + mall → skicka syntetisk run med standardpayload.

UI visar leveransstatus (200/ok, bounce, timeout), signatur‑verifiering för webhook och Slack response‑text.

Länka till “Rå JSON‑payload”.

Vad händer (systembeteende)
Triggers & köer

Cron-/intervall‑triggers beräknas i UTC. För varje “due” → publicera meddelande till scheduler.jobs.due med idempotency‑nyckel (job_id + scheduled_at).

En arbetsplanerare översätter regler/fönster/dependencies → placerar i rätt kö (queue.standard, queue.high, queue.maintenance), respekterar fairness och concurrency‑token per key (t.ex. domän).

Workers tar jobb, kör, rapporterar Run‑status och metrik. Misslyckanden går via RetryPolicy; uttömda försök → dlq.jobs.

Prioritering & preemption

Weighted round‑robin över köer. Preemption stoppar ej pågående run men hindrar nya lägre‑prio start tills SLA‑kritiska köer är tömda.

Fönster

Vid due‑time: om i blackout → deferral (nästa tillåtna slot) med orsak. Off‑peak flaggar som “grön tid” för packning.

Aviseringar

Eventdrivet: run.succeeded|failed|sla_breach|queue_delayed.

NotificationService tillämpar brusregler, renderar mall, signerar webhook (HMAC‑SHA256 på body + X-Signature), skickar, loggar “outcome” och latens.

Datamodell (kort)

jobs(id, name, type, params_json, owner, labels[], created_at, updated_at, active)

schedules(id, job_id, cron|interval_seconds, tz, start_at, end_at, overlap_policy, enabled)

windows(id, type, tz, rrule|cron, applies_to=[job_id|label|*], reason, enabled)

priority_rules(id, match_expr, priority, queue, concurrency_cap, fairness_weight, enabled)

dependencies(from_job_id, to_job_id, type=require|mutex|throttle, key, rate_limit_per_min)

runs(id, job_id, scheduled_at, started_at, finished_at, status, attempts, worker_id, cost, error, metrics_json)

notification_rules(id, job_id|label|*, on_events[], channels[], template_id, noise_policy, enabled)

channels(id, type, config_json{smtp/slack/webhook_url, secret}, owner)

audit_log(id, actor, action, target_type, target_id, before, after, ip, ua, ts)

API (exempel)

POST /api/schedules – skapa/uppdatera schema
Body: { job_id, cron, tz, start_at?, end_at?, overlap_policy, retry_policy{max, backoff, jitter}, notification_rule_ids[] }

GET /api/calendar?from=&to=&tz= – genererad kalender (inkl. overlay‑fönster, konflikter)

POST /api/windows – skapa fönster

POST /api/notifications/test – testa kanal/mall

POST /api/jobs/{id}/run – manuell omkörning (respekt för mutex/deps)

GET /api/runs?job_id=&status=&from=&to= – lista historik

POST /api/schedules/{id}/pause (TTL, reason) / /resume

Fel & validering

409 vid cykliska beroenden; 422 vid ogiltig cron; 429 om concurrency‑cap nådd; 423 vid blackout (med next_allowed_at i respons).

Tillgänglighet & UX‑detaljer

Fullt tangentbordsstöd: fokusramar, ARIA‑labels för kalenderhändelser.

Tidzon‑selector “pinnar” den som är senast använd. Tooltips med nästa 5 körningar.

Tom‑state med “Skapa ditt första schema” + mini‑guide (60 sek).

Säkerhet

RBAC‑vakt runt alla POST/PUT/DELETE.

Hemliga fält i kanal‑config lagras krypterat; webhook signeras; Slack OAuth‑token förvaras i secrets‑valv.

PII i payload maskas enligt policy; auditlogg för alla ändringar/körningar/override.

Observability

Metrics: scheduler.due.count, queue.latency.p95, run.duration.p95, failure.rate, sla.breach.count, notify.delivery.latency, notify.error.rate.

Loggar: korrelerade med run_id, job_id, trace‑id.

Larm: “Queue latency > SLA X min”, “Failure rate > Y% 15min”, “Notifier errors > Z/min”.

Kantfall (checklista)

DST “spring forward” (hoppar över timmar) och “fall back” (dubbel timme) – policy: “run nearest future” respektive “dedupe”.

Missad körning p.g.a. driftstopp → “misfire policy” (kör en, kör alla, eller skippa).

Överlappningspolicy: blockera/queua/”cancel previous” för samma key.

Backpressure: växla till degraded mode (sänk concurrency, paus icke‑kritiska köer).

Delvis lyckade batchjobb – skicka success with warnings (och trigga digest).

Aviserings‑loopar: dedupe på run_id + event.

Verifiering (acceptanskriterier & test)

Acceptans

Kommande körning syns i kalendern (alla vyer) inom ≤1s efter skapad schedule.

“Testa avisering” ger leveransstatus i UI inom 3s; webhook signerad och verifierbar.

Blackout hindrar start; tooltip visar orsak och “nästa tillåtna”.

Prioritetsregel påverkar köordning – visat i simuleringsgrafen.

Tester

Enhet: cron‑parser, next‑runs, DST, retry/backoff, HMAC‑signatur.

Integration: schemaläggning → kö → worker → notifier; DLQ‑flöde; fönster/beroenden.

E2E: skapa schema, dra i kalender, paus globalt, simulera misslyckande → avisering.

Last: 10k samtidiga planerade körningar → kölatens < SLA.

Chaos: döda worker‑pool, se recovery; sabotera Slack‑webhook (5xx) → backoff + larm.

16) Användare & Roller
Mål & principer

Mål: Enkel hantering av åtkomst med minsta möjliga privilegium, bra spårbarhet och smidig integration (API‑nycklar/SSO).

Principer: Roll‑baserat (RBAC) + scopes; “view as” för att prova rättigheter; allt loggas och kan exporteras.

Roller (förslag, kan utökas)

Admin: Full hantering (systeminställningar, roller, användare, nycklar, kanaler).

Operatör: Skapa/ändra jobb, scheman, fönster; köra om; se loggar/metrics; hantera notifieringar.

Läsare: Läsrätt i UI & API; exportera rapporter; ej ändra.

Integrations‑konto (Service Account): Headless, styrs av API‑nycklors scopes.

Auditor (valfritt): Läs + full auditlogg + export.

Rättighetsmatris (exempel)
Modul/Aktion	Admin	Operatör	Läsare	SA (via scope)
Jobb (CRUD)	✓	create/update	read	jobs:read/write
Schemaläggning	✓	create/update/pause	read	schedules:*
Fönster	✓	create/update/pause	read	windows:*
Aviseringskanaler	✓	manage templates	read	notifications:*
Körningar (retry/cancel)	✓	retry/cancel	read	runs:retry
Användare/roller	✓	–	–	–
API‑nycklar	✓	create own	view own	apikeys:*
Integritet/Privacy	✓	manage	read	privacy:*
Proxy/Inställningar	✓	manage – delmängd	read	scope‑styrt

UI visar “låst‑ikon” istället för disabled; hover ger microcopy: “Kräver Operatör eller scope schedules:write”.

UI/UX
Rutor

1) Användarlista

Kolumner: Namn, E‑post, Roller (chips), Senast aktiv, 2FA‑status, SSO‑status, Status (Aktiv/Inaktiverad).

Filter & sort: roll, team, status, senaste aktivitet, saknar 2FA/SSO.

Radmeny: Visa, “View as”, Ändra roller, Inaktivera/Återaktivera, Återställ 2FA, Skicka om inbjudan.

Detaljsida: profil, grupp/organisation, sessions (aktiva med device/IP), riskhändelser, auditspår.

2) Roller (checkbox per modul)

Förinställningar: Admin/Operatör/Läsare/Auditor.

Custom‑roll builder: checkboxar för read/create/update/delete/execute/manage per modul + scopes för API.

Konfliktvarning: “Denna roll har både deny och allow – deny vinner”.

Förhandsgranskning: “View as denna roll” öppnar UI i read‑only sandbox‑läge.

3) API‑nycklar (nyckel, scope, utgång)

Nyckellista: namn, scope‑chips, skapad, senast använd, utgång, IP‑villkor, status (aktiv/revokerad).

Skapa wizard: namn, scopes (multiselect med förklaringar), giltighet (datum eller “tillfällig 24h”), IP‑whitelist (CIDR), miljö (dev/stage/prod), rate‑limit per nyckel, tags.

Visning: nyckel visas endast en gång; copy‑knapp, “lägg till i .env” och “Skapa test‑anrop” (curl).

Rotation: skapa ny → grace‑period → auto‑revokera gammal; exportera påverkningslista (webhooks, CI).

Knappar & flöden

“Lägg till användare”:

Val av metod: E‑postinbjudan / SSO‑provision (SCIM) / Manuell.

Tilldela roll(er), team, kräva 2FA vid första inloggning.

Microcopy: “Inbjudan är giltig i 7 dagar”.

“Skapa API‑nyckel”:

Wizard ovan + “Testa i API‑konsol” (gör ett /whoami‑anrop).

“Inaktivera”:

Bekräftelsemodal med konsekvenser (sessioner spärras, nycklar revokeras? valbart), orsak, TTL för tillfällig spärr.

Banner på profilsidan: “Inaktiverad till … (orsak)”.

Backend & säkerhet
Autentisering

OIDC/OAuth2 (Google, Azure AD, Okta), lokalt konto (valbart) + 2FA (TOTP/WebAuthn).

Sessioner i säkra cookies (HttpOnly, Secure, SameSite=Lax), rotering av refresh‑token.

Magic link för engångsinlogg (begränsa till säkra domäner).

Auktorisering

RBAC‑middleware som härleder rättigheter från roller och API‑scopes.

Finkornig row/field‑level kontroll för multi‑tenant (org_id).

“Break‑glass” administratör: tidsbegränsad elevation med tvingad motivering + notis till säkerhetskanal.

API‑nycklar

Genereras som prefix_live_xxx…; prefix sparas i klartext, hemlig del hashas (Argon2id).

Scopes i JWT‑liknande struktur (signeras) eller i DB m. cachning.

Revokering omedelbar via cache‑invalidation.

Throttling & IP‑filter per nyckel; “last_used_at” för hälsa.

Provisionering

SCIM (om tillgängligt): automatisk skapning/inaktivering vid ändring i IdP.

SSO‑grupp → rollmappning (policyfiler).

Audit & regelefterlevnad

Full auditlogg (append‑only, hashkedja) för: rolländring, nyckel‑skapa/visa/revoke, inloggningar, misslyckade försök, policyändringar.

Export (CSV/JSON) med tidsfilter; retention‑policy (t.ex. 12 månader).

Kantfall (checklista)

Inaktiverad användare med aktiva sessioner → omedelbar token‑revokering.

SSO‑användare utan mappad roll → fallback till “Läsare” eller blockera (konfigurerbart).

API‑nyckel utgången mitt i lång körning → pågående anrop fullföljs, nya nekas (410).

“View as” kan ej användas för att eskalera sig själv; sparar inga ändringar.

Rolländring under session → policy version i token; trigger “policy refresh” i UI.

Verifiering (acceptanskriterier & test)

Acceptans

Inlogg/åtkomst följer roller/scopes omedelbart (policyversion uppdateras utan omstart).

“Lägg till användare” skickar inbjudan och auditlogg registreras.

“Skapa API‑nyckel” visar nyckeln en gång; testanrop lyckas/nekas enligt scope.

“Inaktivera” spärrar sessioner och API‑nycklar enligt valt alternativ; UI visar status.

Tester

Enhet: policyutvärdering per modul/åtgärd, scope‑matchning, 2FA‑flöde, nyckelhash & validering.

Integration: SSO inloggning + grupp→roll‑mappning; SCIM deprovision; rate‑limit per nyckel.

E2E: skapa användare, byt roll, “view as”, försök otillåten åtgärd (förväntat 403), skapa nyckel, testa API‑anrop med/utan rätt scope.

Säkerhet: brute force‑skydd, session fixation, CSRF på känsliga POST (anti‑CSRF‑token), CORS policy.

Compliance: export av auditlogg, verifiera hashkedja.

Microcopy (exempel)

Pausad fönster‑banner: “Planerade körningar hålls tillbaka p.g.a. underhållsfönster. [Visa detaljer]”

Deny‑tooltip: “Behörighet saknas. Be en Admin om rollen Operatör eller API‑scope schedules:write.”

API‑nyckel visning: “Visa och spara nyckeln nu — den går inte att visa igen.”

Prestanda & skalning (sammanfattning)

Scheduler kör “next due” beräkning inkrementellt (per minut), partitionerat per organisation.

Köer med back‑pressure‑signaler; autoskala workers via kö‑djup och p95‑latens.

Indexering: runs(job_id, scheduled_at), schedules(job_id, enabled), audit_log(ts).

Caching av policy/roller (TTL 60s, event‑driven invalidation).

17) Inställningar (System)
A) Enkel förklaring (för icke‑tekniker)

Här ställer du in allt som är gemensamt för systemet: vilken databas som används (vi stöder MySQL fullt ut), var filer ska sparas, hur man kopplar externa system (Elastic, BigQuery, Snowflake, Google Sheets), hur loggar & mätvärden exponeras och grundläggande säkerhet (CORS, rate‑limits). Du kan testa anslutningar och köra migrationer här så att databasen får rätt tabeller.

B) UI/UX – sektioner & rutor (allt som ska finnas)
B.1 Databaser

Primär lagring (radio): PostgreSQL / MySQL (default: MySQL)

MySQL‑fält (visas när MySQL är valt):

Host (text, default 127.0.0.1)

Port (tal, default 3306)

Databas (text, ex crawler)

Användare (text)

Lösenord (password, “visa/dölj”)

SSL (checkbox) → SSL‑mode (dropdown: DISABLED|PREFERRED|REQUIRED)

Extra params (text, t.ex. charset=utf8mb4&connect_timeout=5)

Skriv som primär (toggle) → om avstängd skrivs primärt till Postgres och MySQL blir read‑side; om påslagen är MySQL både read/write.

Läsreplika (toggle) → visar Replica host/port/user/pass (frivilligt)

Knappar:

Testa anslutning → ping + SELECT 1, visar serverversion, tidszon

Kör migrationer nu → kör DB‑migrationer till head

Status‑etiketter:

“Ansluten ✓ (MySQL 8.0.35)”

“Migrationer: på version head” eller “ligger efter: 3 steg”

B.2 Fil‑lagring

Lokal (radio)

Bas‑katalog (text, default ./data)

Max filstorlek (MB)

Rensa gamla (dagar)

Moln (radio: S3‑kompatibel)

Endpoint (text)

Bucket (text)

Prefix (text)

Access key / Secret key (password)

Kryptera på server‑sidan (checkbox)

Testa anslutning (knapp)

B.3 Externa connectorer

Elasticsearch / OpenSearch

URL, Index‑prefix, Auth (user/pass eller API‑nyckel), SSL verify

Testa anslutning

BigQuery

Project, Dataset, Auth JSON (textarea/filuppladdning)

Testa anslutning

Snowflake

Account, User, Role, Warehouse, Database, Schema, Key/Password

Testa anslutning

Google Sheets

Service account JSON, Impersonated user (valfritt)

Testa anslutning

B.4 Logg/Observability

Prometheus endpoint /metrics (toggle)

OpenTelemetry exporter (OTLP gRPC/HTTP, endpoint, sampling‑rate)

Loggnivå (DEBUG/INFO/WARN/ERROR) per modul

Strukturerad logg (JSON) (toggle)

Testa logg (skicka prov‑event och visa i UI)

B.5 Säkerhetsinställningar

CORS

Allowed origins (lista)

Allowed methods (checklist)

Allowed headers (lista)

Rate‑limits (defaultar)

Per IP: req/min (tal)

Per API‑nyckel: req/min (tal)

Burst (tal)

Svar vid limit (429 text)

Session/Cookie policy (SameSite/HttpOnly/Secure) (visas för UI)

B.6 Licens & Organisation

Licensnyckel (text/password) + Verifiera

Organisationsnamn (text), Kontaktmail (mail)

B.7 Knappar (globalt)

Spara

Testa anslutning (contextual per sektion)

Kör migrationer nu

C) Vad händer (bakom kulisserna)

Spara
Inställningar valideras i UI → POST till /api/system/settings. Hemligheter krypteras i DB. En konfig‑snapshot loggas till Audit (se §18).

Testa anslutning (DB)
Backend skapar en tillfällig pool med angivna parametrar → SELECT 1, @@version, @@system_time_zone. Resultat visas i UI och loggas (utan lösenord).

Kör migrationer nu
Backend kör Alembic/SQLa‑migrationer mot den valda primära DB:n.

Om MySQL är satt “Skriv som primär” ⇒ migrationer körs mot MySQL.

Om Läsreplika ifylld ⇒ endast read‑pool byggs för SELECTs.

Vid lyckad migrering uppdateras alembic_version och en health‑write sker (ex: insert i system_health).

Växla read/write repo
Efter sparat val uppdateras ConnectionManager:

write_repo = mysql_primary (om påslaget),

read_repo = mysql_replica || mysql_primary.
Pub/Sub signal skickas till workers som “hot‑swapar” anslutningar utan att droppa pågående jobb.

D) API‑kontrakt & kommandon
D.1 REST
GET  /api/system/settings
POST /api/system/settings                 -- sparar
POST /api/system/test/db                  -- testar DB (body: mysql/postgres creds)
POST /api/system/migrate                  -- kör migrationer för vald primär DB
POST /api/system/test/storage             -- testar lokal/S3
POST /api/system/test/connector           -- testar Elastic/BQ/Snowflake/Sheets
POST /api/system/license/verify
GET  /api/system/health                   -- sammanfattning: DB ok, storage ok, metrics ok

D.2 Exempel (curl)

Testa MySQL lokalt

curl -s -X POST http://localhost:8000/api/system/test/db \
  -H "Content-Type: application/json" \
  -d '{"kind":"mysql","host":"127.0.0.1","port":3306,"db":"crawler","user":"crawler","password":"secret","ssl":"DISABLED","params":"charset=utf8mb4"}' | jq


Kör migrationer nu

curl -s -X POST http://localhost:8000/api/system/migrate | jq


Hälsa

curl -s http://localhost:8000/api/system/health | jq

E) MySQL – förbered exakt (kommando för kommando)

1) Skapa databas & användare

CREATE DATABASE IF NOT EXISTS crawler CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER IF NOT EXISTS 'crawler'@'%' IDENTIFIED BY 'secret';
GRANT ALL PRIVILEGES ON crawler.* TO 'crawler'@'%';
FLUSH PRIVILEGES;


2) Snabbtest med mysql‑klient

mysql -h127.0.0.1 -uroot -p -e "SELECT @@version, @@system_time_zone;"
mysql -h127.0.0.1 -ucrawler -psecret -e "SELECT 1;" crawler


Tolkningshjälp: får du en 1‑radig tabell med 1 är anslutningen ok.

F) Konfig‑fil: config/system.yaml (fullt innehåll)

Skapa filen om den inte finns. Denna fil läses vid uppstart och kan skrivas om via UI. Hemligheter kan lagras krypterat i DB; men vi visar allt här för lokal dev.

# config/system.yaml
version: 1

database:
  primary:
    driver: mysql            # mysql | postgres
    host: 127.0.0.1
    port: 3306
    name: crawler
    user: crawler
    password: secret
    ssl: DISABLED            # DISABLED | PREFERRED | REQUIRED
    params: "charset=utf8mb4&connect_timeout=5"
  read_replica:
    enabled: false
    host: 127.0.0.1
    port: 3306
    name: crawler
    user: crawler
    password: secret
    ssl: DISABLED
    params: "charset=utf8mb4"
  write_as_primary: true     # om true: MySQL är write/read

storage:
  kind: local                # local | s3
  local:
    base_path: "./data"
    max_file_mb: 1024
    retention_days: 365
  s3:
    endpoint: ""
    bucket: ""
    prefix: ""
    access_key: ""
    secret_key: ""
    sse: false

connectors:
  elastic:
    enabled: false
    url: "https://localhost:9200"
    index_prefix: "spark"
    auth:
      mode: basic
      username: "elastic"
      password: "changeme"
    ssl_verify: true
  bigquery:
    enabled: false
    project: ""
    dataset: ""
    credentials_json: ""     # base64 eller path
  snowflake:
    enabled: false
    account: ""
    user: ""
    role: ""
    warehouse: ""
    database: ""
    schema: ""
    auth:
      mode: password         # password | keypair
      password: ""
      private_key_pem: ""
  sheets:
    enabled: false
    service_account_json: ""
    impersonated_user: ""

observability:
  prometheus:
    enabled: true
    path: "/metrics"
  otlp:
    enabled: false
    endpoint: "http://localhost:4318"
    sampling_rate: 0.2
  logging:
    level:
      root: "INFO"
      api: "INFO"
      worker: "INFO"
      scheduler: "INFO"
    json: true

security:
  cors:
    allowed_origins: ["http://localhost:5173","http://localhost:3000"]
    allowed_methods: ["GET","POST","PUT","DELETE","OPTIONS"]
    allowed_headers: ["Content-Type","Authorization","X-Api-Key"]
  ratelimits:
    per_ip_per_min: 120
    per_key_per_min: 600
    burst: 60
    message: "Rate limit exceeded"
  session:
    same_site: "Lax"
    http_only: true
    secure: false            # true i prod
license:
  organization: "Acme AB"
  key: ""                    # valfritt i dev


Verifiering: ändra i UI → spara → öppna filen och se att ändringen slår igenom (eller att DB‑lagringen speglar samma värden i /api/system/settings).

G) Alembic (MySQL) – körning & kontroll

alembic.ini (relevant utdrag)

Vi antar att backend använder SQLAlchemy. Uppdatera sqlalchemy.url dynamiskt via miljö eller CLI‑argument.

# alembic.ini
[alembic]
script_location = db/migrations
sqlalchemy.url = driver://will-be-overridden

[loggers]
keys = root,sqlalchemy,alembic

[logger_alembic]
level = INFO
handlers = console
qualname = alembic


Kör via CLI (exempel):

export DB_URL="mysql+pymysql://crawler:secret@127.0.0.1:3306/crawler?charset=utf8mb4"
alembic -x db_url="$DB_URL" upgrade head


Kontrollera version:

SELECT version_num FROM alembic_version;


Förväntat: exakt en rad med nuvarande “head”.

Health‑skrivning (snabb koll att write fungerar):

CREATE TABLE IF NOT EXISTS system_health (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  probe VARCHAR(32) NOT NULL,
  at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO system_health (probe) VALUES ('write_ok');
SELECT * FROM system_health ORDER BY id DESC LIMIT 1;

H) Verifieringslista (checkbox‑vänlig)

 Testa anslutning (MySQL) visar “Ansluten ✓” + version.

 Kör migrationer kör till head (kolla alembic_version).

 Skriv som primär påslaget → insert i system_health fungerar.

 Lagring: skriv testfil (/api/system/test/storage) → fil syns under ./data/test/.

 Observability: curl localhost:8000/metrics ger Prometheus‑text.

 CORS: frontend‑origin i listan → inga CORS‑fel i dev.

I) Kantfall & säkerhet

Fel lösenord/port → “Testa anslutning” visar tydligt fel (ER_ACCESS_DENIED_ERROR / timeout) utan att läcka hemligheter.

SSL‑krav i moln → visa guidance (“sätt ssl=REQUIRED och importera CA”).

Failover: om primär blir otillgänglig och läsreplika finns, sätt read only‑läge (UI‑banner) tills primär återkommer.

Hemligheter: UI aldrig loggar hemligheter; DB‑kryptering (KMS/nyckelfil) och rotationsstöd.

Rate‑limits: skydda /api/system/* med hårdare limits och Admin‑roll.

18) Audit & Händelseloggar
A) Enkel förklaring (för icke‑tekniker)

Det här är svarta lådan: allt som händer i systemet loggas här — vem gjorde vad, vad ändrades, när, och resultat. Du kan söka på jobb/policy/mall/data, se diff mellan versioner och exportera till JSON. Loggen är append‑only (går inte att ändra i efterhand) och manipulationsspårbar (hash‑kedja).

B) UI/UX – rutor & flöden
B.1 Filterpanel

Typ (multi‑select): jobb, policy, mall, data, system, auth, export, privacy, proxy, scheduler

Tid (datumintervall, snabbar: 1h, 24h, 7d)

Aktör (användare, service account, API‑nyckelprefix)

Korrelation: job_id, run_id, policy_id, template, export_id, session_key

Resultat: ok | denied | error

Sök (fri text på sammanfattning/metadata)

B.2 Resultatlista

Kolumner: Tid, Typ, Aktör, Sammanfattning, Korrelation‑chips, Resultat.

Radklick: öppnar detaljvy med:

Full payload (JSON, pretty)

Diff‑vy (om ändring av mall/policy/inställning): vänster/höger med färgmarkering

Hash‑kedja: prev_hash, event_hash + “Verifiera kedja”

Relaterade händelser (samma korrelationsID)

B.3 Knappar

Exportera logg (JSON) (respekterar filter)

Öppna i Datalager (om händelsen gäller data)

Kopiera referens (permalänk)

Verifiera kedja (kör hash‑verifiering i UI och visar OK/FAIL)

C) Händelsetyper (minimi‑uppsättning)

policy.changed (skapat/ändrat/publicerat/rollback) – innehåller diff

template.changed (dito) – innehåller diff och versionsnummer

job.created/updated/deleted, job.run.started/succeeded/failed (inkl. orsak)

scheduler.window.changed, priority.rule.changed

system.settings.changed (inställningar), system.migration.ran

privacy.scan.started/completed, privacy.erase.requested/completed

export.started/completed/failed

auth.login.success/failure, user.role.changed, apikey.created/revoked

proxy.provider.added/blacklisted/validated

Varje händelse innehåller actor, ip/ua (om UI/API), resource, before/after (vid ändring), result.

D) MySQL – tabeller (append‑only & diff)
CREATE TABLE IF NOT EXISTS audit_event (
  id            BIGINT PRIMARY KEY AUTO_INCREMENT,
  ts            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  type          VARCHAR(64) NOT NULL,              -- ex: policy.changed
  actor         VARCHAR(128) NOT NULL,             -- user:elin / sa:exporter
  actor_ip      VARCHAR(64) NULL,
  actor_ua      VARCHAR(256) NULL,
  resource_type VARCHAR(64) NULL,                  -- policy/template/job/system/data
  resource_id   VARCHAR(64) NULL,                  -- id för resursen
  correlation_id VARCHAR(64) NULL,                 -- job_id/run_id/export_id...
  summary       VARCHAR(512) NOT NULL,
  result        ENUM('ok','denied','error') NOT NULL DEFAULT 'ok',
  before_json   JSON NULL,
  after_json    JSON NULL,
  meta_json     JSON NULL,                         -- extra detaljer
  prev_hash     CHAR(64) NULL,
  event_hash    CHAR(64) NULL,
  INDEX (ts), INDEX (type), INDEX (actor), INDEX (resource_type, resource_id),
  INDEX (correlation_id), INDEX (result)
);


Hash‑kedja: event_hash = SHA2(CONCAT(ts, type, actor, COALESCE(resource_type,''), COALESCE(resource_id,''), COALESCE(correlation_id,''), summary, COALESCE(JSON_EXTRACT(before_json, '$'),''), COALESCE(JSON_EXTRACT(after_json, '$'),''), COALESCE(prev_hash,'')), 256)
Applikationen läser senaste event_hash och sätter prev_hash på nästa post.

Diff‑hjälp (lagring av textdiff valfritt):

CREATE TABLE IF NOT EXISTS audit_diff_text (
  id          BIGINT PRIMARY KEY AUTO_INCREMENT,
  audit_id    BIGINT NOT NULL,
  side        ENUM('before','after') NOT NULL,
  blob_text   MEDIUMTEXT NOT NULL,
  INDEX (audit_id, side)
);


Index‑optimering (sök):

ALTER TABLE audit_event ADD FULLTEXT INDEX ft_summary (summary);

E) API – sök & export
GET  /api/audit?type=policy.changed&from=...&to=...&actor=elin&result=ok&limit=100&cursor=...
GET  /api/audit/{id}
GET  /api/audit/{id}/diff            -- returnerar unified diff om finns
POST /api/audit/verify-chain         -- kör hashkedje‑verifiering (från..till)
GET  /api/audit/export.json?from=...&to=...&type=...   -- streaming‑export
GET  /api/audit/stream               -- SSE/WebSocket för live‑events


Exempel (curl):

# Lista senaste policy-ändringar
curl -s "http://localhost:8000/api/audit?type=policy.changed&limit=20" | jq

# Hämta ett event + diff
curl -s http://localhost:8000/api/audit/123 | jq
curl -s http://localhost:8000/api/audit/123/diff

# Exportera logg (JSON)
curl -s -L "http://localhost:8000/api/audit/export.json?from=2025-08-01T00:00:00Z&to=2025-08-21T23:59:59Z&type=job.run.failed" -o audit_failed.json

F) Integration (så loggen fylls)

Middleware plockar upp: aktör (user/service/api‑key), ip, user‑agent.

Decorator @audited(type="policy.changed", resource=("policy", id)) runt alla muterande endpoints.

Jobb/Workers emitterar job.run.* & export.* (med korrelationer).

System skriver system.migration.ran efter Alembic, system.settings.changed efter lyckad POST /settings.

Privacy/Proxy/Scheduler skriver sina domän‑event.

G) Verifiering – gör så här (steg för steg)

1) Ändra en policy (ex via tidigare Policies‑UI)

Spara → Publicera.

Kontroll:

SELECT id, ts, type, actor, summary, result FROM audit_event
WHERE type='policy.changed'
ORDER BY id DESC LIMIT 1;


Förväntat: en rad med ok och summary typ “policy *.car.info v2 published”.

2) Kör migrationer (från §17)

Kontroll:

SELECT type, summary FROM audit_event
WHERE type='system.migration.ran' ORDER BY id DESC LIMIT 1;


Förväntat: sammanfattning med versions‑intervall from=a1b2 -> to=head.

3) Starta och stoppa ett jobb

Kontroll:

SELECT type, correlation_id, result
FROM audit_event
WHERE correlation_id='job_abc'
ORDER BY ts DESC;


Förväntat: job.run.started följt av job.run.succeeded|failed.

4) Verifiera hash‑kedja

Hämta senaste 50 id:n och kör POST /api/audit/verify-chain (UI‑knapp “Verifiera kedja”).

Förväntat: “Chain OK”.

5) Diff‑vy för mall

Ändra en selector i Template Wizard → spara.

Kontroll: öppna senaste template.changed i UI → diff visar ändrad rad.

H) Kantfall & säkerhet

PII i logg: maska känsliga fält (e‑post/telefon/regnr/personnr) i summary/meta_json.

Tamper‑evidens: aktivera hash‑kedja; valfritt att signera blockvis (t.ex. var 10:e event signeras med HMAC).

Retention: exportera till kall‑lagring och trimma tabellen efter t.ex. 365 dagar (om policy tillåter).

RBAC: endast Admin/Auditor får se hela audit; Operatör ser händelser i sina projekt; Läsare får en subset (utan meta).

Prestanda: partitionera tabellen per månad vid hög volym (MySQL 8.0: partition by range on ts).

Loop‑risk: audit av audit undviks (middleware hoppar /api/audit/*).

I) “Snabb problemlista” (vad UI ska guida)

Inget syns i audit: kontrollera att middleware är aktiv och att audit_event inte saknar rättigheter.

Kedjan FAIL: någon har raderat/ändrat event; exportera perioden och slå larm.

Stor tabell: slå på streaming‑export och partitionering; index på (type, ts) och (resource_type, resource_id).

J) Mini‑checklista (daglig drift)

Systemhälsa (§17): DB ✓, storage ✓, metrics ✓

Audit (§18): senaste timmarna har job.run.* och inga error stormar

Hashkedja: verifikat OK (daglig automatisk körning)

Backup/export: nattlig JSON‑export funkar (filer växer dag för dag)















