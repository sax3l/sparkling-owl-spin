openapi: 3.1.0
info:
  title: "Ethical Crawler & Data Platform API"
  version: "1.0.0"
  description: "API for managing scraping jobs, templates, and accessing data."
servers:
  - url: /v1

components:
  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key

  schemas:
    # Crawl Job Schemas
    FeatureFlags:
      type: object
      properties:
        detect_templates: { type: boolean, default: true }
        paginate_auto: { type: boolean, default: true }
        infinite_scroll: { type: boolean, default: false }
    
    CrawlPolicy:
      type: object
      properties:
        respect_robots: { type: boolean, default: true }
        crawl_delay_ms: { type: integer, default: 1000 }
        parallelism: { type: integer, default: 8 }
        transport: { type: string, enum: ["http", "browser", "auto"], default: "http" }
        user_agent_profile: { type: string, default: "chrome-stable" }
        feature_flags: { $ref: "#/components/schemas/FeatureFlags" }

    CrawlCaps:
      type: object
      properties:
        rps_per_domain: { type: number, format: float, default: 1.5 }
        max_concurrent_per_domain: { type: integer, default: 4 }

    CrawlJobCreate:
      type: object
      required: [seeds, allow_domains]
      properties:
        seeds: { type: array, items: { type: string, format: uri } }
        max_depth: { type: integer, default: 3 }
        max_urls: { type: integer, default: 20000 }
        allow_domains: { type: array, items: { type: string } }
        disallow_patterns: { type: array, items: { type: string } }
        policy: { $ref: "#/components/schemas/CrawlPolicy" }
        caps: { $ref: "#/components/schemas/CrawlCaps" }
        tags: { type: array, items: { type: string } }

    # Scrape Job Schemas
    SitemapQuery:
      type: object
      properties:
        domain: { type: string }
        pattern: { type: string }
        limit: { type: integer, default: 5000 }

    ScrapeSource:
      type: object
      properties:
        sitemap_query: { $ref: "#/components/schemas/SitemapQuery" }
        urls: { type: array, items: { type: string, format: uri } }
      description: "Must contain exactly one of `sitemap_query` or `urls`."

    ScrapePolicy:
      type: object
      properties:
        transport: { type: string, enum: ["http", "browser", "auto"], default: "auto" }
        max_retries: { type: integer, default: 2 }
        delay_profile: { type: string, default: "default" }

    ScrapeCaps:
      type: object
      properties:
        max_concurrent: { type: integer, default: 16 }
        browser_pool_size: { type: integer, default: 4 }

    ExportDestination:
      type: object
      properties:
        type: { type: string, enum: ["internal_staging", "s3_presigned", "gcs_signed", "supabase_storage"], default: "internal_staging" }
        retention_hours: { type: integer, default: 72 }

    ExportConfig:
      type: object
      properties:
        format: { type: string, enum: ["json", "csv", "ndjson"], default: "ndjson" }
        compress: { type: string, enum: ["none", "gzip"], default: "gzip" }
        destination: { $ref: "#/components/schemas/ExportDestination" }

    ScrapeJobCreate:
      type: object
      required: [template_id, source]
      properties:
        template_id: { type: string }
        template_version: { type: string }
        source: { $ref: "#/components/schemas/ScrapeSource" }
        policy: { $ref: "#/components/schemas/ScrapePolicy" }
        caps: { $ref: "#/components/schemas/ScrapeCaps" }
        export: { $ref: "#/components/schemas/ExportConfig" }
        tags: { type: array, items: { type: string } }

    # New Diagnostic Job Schema
    DiagnosticJobCreate:
      type: object
      required: [template_id]
      properties:
        template_id: { type: string }
        template_version: { type: string }
        target_url: { type: string, format: uri, nullable: true, description: "URL to run diagnostic against. Cannot be used with sample_html." }
        sample_html: { type: string, nullable: true, description: "Inline HTML content for diagnostic. Cannot be used with target_url." }
        tags: { type: array, items: { type: string } }
      description: "Creates a job to run a template against a specific URL or inline HTML for diagnostic purposes."

    # New Export Schemas
    ExportCreate:
      type: object
      required: [export_type]
      properties:
        export_type: { type: string, description: "Type of data to export (e.g., 'person', 'company', 'vehicle')" }
        filters: { type: object, additionalProperties: true, default: {}, description: "JSON object of filters to apply to the data" }
        format: { type: string, enum: ["json", "csv", "ndjson"], default: "csv" }
        compress: { type: string, enum: ["none", "gzip"], default: "gzip" }
        destination: { $ref: "#/components/schemas/ExportDestination" }
        file_name_prefix: { type: string, nullable: true, description: "Optional prefix for the exported file name" }

    ExportRead:
      type: object
      properties:
        id: { type: string, format: uuid }
        user_id: { type: string, format: uuid, nullable: true }
        export_type: { type: string }
        file_name: { type: string }
        file_size_mb: { type: number, format: float, nullable: true }
        credits_used: { type: integer }
        status: { type: string, enum: ["pending", "queued", "running", "completed", "failed", "cancelled"] }
        download_url: { type: string, format: uri, nullable: true }
        expires_at: { type: string, format: date-time, nullable: true }
        created_at: { type: string, format: date-time }
        filters_json: { type: object, additionalProperties: true, nullable: true }

    # Common Schemas
    JobAcceptedResponse:
      type: object
      properties:
        job_id: { type: string, format: uuid }
        status: { type: string, enum: ["queued", "pending"] }
        links: { type: object, properties: { self: { type: string, example: "/v1/jobs/..." } } }

    ErrorResponse:
      type: object
      properties:
        detail: { type: string }
    
    ProxyStats:
      type: object
      properties:
        active_proxies: { type: integer, description: "Number of currently active proxies." }
        healthy_proxies: { type: integer, description: "Number of healthy proxies in the pool." }
        unhealthy_proxies: { type: integer, description: "Number of unhealthy proxies in the pool." }
        domains_in_backoff: { type: integer, description: "Number of domains currently under backoff policy." }
        total_requests_last_hour: { type: integer, description: "Total requests made in the last hour." }
        average_latency_ms: { type: number, format: float, description: "Average request latency in milliseconds." }
        policy_manager_status: { type: string, description: "Status of the policy manager (e.g., active, degraded)." }
        last_updated: { type: string, format: date-time, description: "Timestamp of when these statistics were last updated." }

    DataQualityMetricInput:
      type: object
      required: [entity_type, entity_id]
      properties:
        entity_type: { type: string, description: "Type of entity (e.g., 'person', 'company', 'vehicle')." }
        entity_id: { type: integer, format: int64, description: "ID of the entity." }
        field_name: { type: string, nullable: true, description: "Specific field name if metric is field-level." }
        completeness: { type: number, format: float, nullable: true, description: "Completeness score (0.0-1.0)." }
        validity: { type: number, format: float, nullable: true, description: "Validity score (0.0-1.0)." }
        consistency: { type: number, format: float, nullable: true, description: "Consistency score (0.0-1.0)." }
        measured_at: { type: string, format: date-time, nullable: true, description: "Timestamp when metric was measured (defaults to now)." }

    TemplateStatusUpdate:
      type: object
      required: [status]
      properties:
        status: { type: string, enum: ["active", "inactive", "draft"], description: "New status for the template." }


paths:
  /jobs/crawl:
    post:
      summary: "Submit a new crawl job"
      operationId: "submit_crawl_job"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - { name: "Idempotency-Key", in: "header", required: false, schema: { type: "string", format: "uuid" } }
      requestBody:
        required: true
        content: { application/json: { schema: { $ref: "#/components/schemas/CrawlJobCreate" } } }
      responses:
        '202':
          description: "Job accepted and queued for execution."
          content: { application/json: { schema: { $ref: "#/components/schemas/JobAcceptedResponse" } } }
        '400': { description: "Bad Request", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '409': { description: "Conflict", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '429': { description: "Too Many Requests", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /jobs/scrape:
    post:
      summary: "Submit a new scrape job"
      operationId: "submit_scrape_job"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - { name: "Idempotency-Key", in: "header", required: false, schema: { type: "string", format: "uuid" } }
      requestBody:
        required: true
        content: { application/json: { schema: { $ref: "#/components/schemas/ScrapeJobCreate" } } }
      responses:
        '202':
          description: "Job accepted and queued for execution."
          content: { application/json: { schema: { $ref: "#/components/schemas/JobAcceptedResponse" } } }
        '400': { description: "Bad Request", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '409': { description: "Conflict", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '429': { description: "Too Many Requests", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /jobs/diagnostic:
    post:
      summary: "Submit a new diagnostic job"
      operationId: "submit_diagnostic_job"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - { name: "Idempotency-Key", in: "header", required: false, schema: { type: "string", format: "uuid" } }
      requestBody:
        required: true
        content: { application/json: { schema: { $ref: "#/components/schemas/DiagnosticJobCreate" } } }
      responses:
        '202':
          description: "Diagnostic job accepted and queued for execution."
          content: { application/json: { schema: { $ref: "#/components/schemas/JobAcceptedResponse" } } }
        '400': { description: "Bad Request", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '409': { description: "Conflict", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '429': { description: "Too Many Requests", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /exports:
    post:
      summary: "Initiate a new asynchronous data export job"
      operationId: "create_export_job"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - { name: "Idempotency-Key", in: "header", required: false, schema: { type: "string", format: "uuid" } }
      requestBody:
        required: true
        content: { application/json: { schema: { $ref: "#/components/schemas/ExportCreate" } } }
      responses:
        '202':
          description: "Export job accepted and queued for execution."
          content: { application/json: { schema: { $ref: "#/components/schemas/ExportRead" } } }
        '400': { description: "Bad Request", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '409': { description: "Conflict", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
    get:
      summary: "List all export jobs for the authenticated tenant"
      operationId: "list_exports"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: status
          in: query
          schema: { type: string, enum: ["pending", "queued", "running", "completed", "failed", "cancelled"] }
          description: "Filter by job status"
        - name: export_type
          in: query
          schema: { type: string }
          description: "Filter by export type (e.g., 'person', 'company')"
        - name: limit
          in: query
          schema: { type: integer, default: 100, minimum: 1, maximum: 1000 }
          description: "Maximum number of results to return"
        - name: offset
          in: query
          schema: { type: integer, default: 0, minimum: 0 }
          description: "Number of results to skip"
      responses:
        '200':
          description: "A list of export jobs."
          content: { application/json: { schema: { type: array, items: { $ref: "#/components/schemas/ExportRead" } } } }
        '401': { description: "Unauthorized", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /exports/{export_id}:
    get:
      summary: "Retrieve the status of a specific export job"
      operationId: "get_export_status"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: export_id
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200':
          description: "Details of the export job."
          content: { application/json: { schema: { $ref: "#/components/schemas/ExportRead" } } }
        '404': { description: "Export job not found", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '401': { description: "Unauthorized", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /data/{export_type}:
    get:
      summary: "Directly retrieve data in specified format (CSV, NDJSON, JSON)"
      operationId: "get_data_direct"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: export_type
          in: path
          required: true
          schema: { type: string, description: "Type of data to export (e.g., 'person', 'company', 'vehicle')" }
        - name: format
          in: query
          schema: { type: string, enum: ["csv", "ndjson", "json"] }
          description: "Desired output format. If not specified, determined by Accept header."
        - name: compress
          in: query
          schema: { type: boolean, default: false }
          description: "Apply gzip compression to the output."
        - name: filters
          in: query
          schema: { type: string }
          description: "JSON string of filters, e.g., '{\"field\":\"value\"}' or '{\"field\":{\"gte\":\"value\"}}'"
        - name: sort_by
          in: query
          schema: { type: string }
          description: "Field to sort by, e.g., 'created_at' or '-created_at' for descending. Multiple fields not supported yet."
        - name: fields
          in: query
          schema: { type: string }
          description: "Comma-separated list of fields to include, e.g., 'id,name,email'"
        - name: mask_pii
          in: query
          schema: { type: boolean, default: true }
          description: "Apply PII masking to sensitive fields (e.g., personal numbers, salaries). Requires 'data:read:pii' scope to disable."
        - name: limit
          in: query
          schema: { type: integer, minimum: 1 }
          description: "Maximum number of records to return."
        - name: offset
          in: query
          schema: { type: integer, minimum: 0, default: 0 }
          description: "Number of records to skip."
      responses:
        '200':
          description: "Streamed data in the requested format."
          content:
            text/csv:
              schema: { type: string, format: binary }
            application/x-ndjson:
              schema: { type: string, format: binary }
            application/json:
              schema: { type: string, format: binary }
            application/gzip:
              schema: { type: string, format: binary }
        '400': { description: "Bad Request", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '401': { description: "Unauthorized", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '404': { description: "Export type not found", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
  
  /monitoring/proxy-stats:
    get:
      summary: "Retrieve current statistics about the proxy pool and anti-bot policies"
      operationId: "get_proxy_stats"
      security: [{ ApiKeyAuth: [] }]
      responses:
        '200':
          description: "Current proxy and policy statistics."
          content: { application/json: { schema: { $ref: "#/components/schemas/ProxyStats" } } }
        '401': { description: "Unauthorized", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '403': { description: "Forbidden", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '500': { description: "Internal Server Error", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /data-quality-metrics:
    post:
      summary: "Submit data quality metrics for entities"
      operationId: "submit_data_quality_metrics"
      security: [{ ApiKeyAuth: [] }]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: "#/components/schemas/DataQualityMetricInput"
      responses:
        '201':
          description: "Metrics submitted successfully."
          content:
            application/json:
              schema:
                type: object
                properties:
                  message: { type: string }
        '400': { description: "Bad Request", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '401': { description: "Unauthorized", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '403': { description: "Forbidden", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /templates:
    post:
      summary: "Creates a new scraping template."
      operationId: "create_template"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - { name: "Idempotency-Key", in: "header", required: false, schema: { type: "string", format: "uuid" } }
      requestBody:
        required: true
        content: { application/json: { schema: { $ref: "#/components/schemas/TemplateCreate" } } }
      responses:
        '201':
          description: "Template created successfully."
          content: { application/json: { schema: { $ref: "#/components/schemas/TemplateRead" } } }
        '409': { description: "Conflict", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
    get:
      summary: "Retrieves all templates for the authenticated tenant."
      operationId: "get_all_templates"
      security: [{ ApiKeyAuth: [] }]
      responses:
        '200':
          description: "A list of templates."
          content: { application/json: { schema: { type: array, items: { $ref: "#/components/schemas/TemplateRead" } } } }

  /templates/{template_id}:
    get:
      summary: "Retrieves a specific template by its ID."
      operationId: "get_template"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: template_id
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200':
          description: "Template details."
          content: { application/json: { schema: { $ref: "#/components/schemas/TemplateRead" } } }
        '404': { description: "Template not found", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
    put:
      summary: "Updates an existing template."
      operationId: "update_template"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: template_id
          in: path
          required: true
          schema: { type: string, format: uuid }
        - name: If-Match
          in: header
          required: true
          schema: { type: string }
          description: "ETag of the template for optimistic concurrency control."
      requestBody:
        required: true
        content: { application/json: { schema: { $ref: "#/components/schemas/TemplateUpdate" } } }
      responses:
        '200':
          description: "Template updated successfully."
          content: { application/json: { schema: { $ref: "#/components/schemas/TemplateRead" } } }
        '404': { description: "Template not found", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '412': { description: "Precondition Failed: ETag mismatch.", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
    delete:
      summary: "Deletes a template."
      operationId: "delete_template"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: template_id
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        '204': { description: "Template deleted successfully." }
        '404': { description: "Template not found", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /templates/{template_id}/status:
    patch:
      summary: "Update the status of a template"
      operationId: "update_template_status"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: template_id
          in: path
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/TemplateStatusUpdate"
      responses:
        '200':
          description: "Template status updated successfully."
          content: { application/json: { schema: { $ref: "#/components/schemas/TemplateRead" } } }
        '400': { description: "Bad Request", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '401': { description: "Unauthorized", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '403': { description: "Forbidden", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '404': { description: "Template not found", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /webhooks/endpoints:
    post:
      summary: "Registers a new webhook endpoint for a tenant."
      operationId: "create_webhook_endpoint"
      security: [{ ApiKeyAuth: [] }]
      requestBody:
        required: true
        content: { application/json: { schema: { $ref: "#/components/schemas/WebhookEndpointCreate" } } }
      responses:
        '201':
          description: "Webhook endpoint created successfully."
          content: { application/json: { schema: { $ref: "#/components/schemas/WebhookEndpoint" } } }
    get:
      summary: "Lists all webhook endpoints for the authenticated tenant."
      operationId: "list_webhook_endpoints"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: active
          in: query
          schema: { type: boolean }
          description: "Filter by active status."
        - name: event_type
          in: query
          schema: { $ref: "#/components/schemas/WebhookEventType" }
          description: "Filter by event type."
      responses:
        '200':
          description: "A list of webhook endpoints."
          content: { application/json: { schema: { type: array, items: { $ref: "#/components/schemas/WebhookEndpoint" } } } }

  /webhooks/endpoints/{endpoint_id}:
    patch:
      summary: "Updates an existing webhook endpoint (e.g., activate/deactivate, rotate secret)."
      operationId: "update_webhook_endpoint"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: endpoint_id
          in: path
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content: { application/json: { schema: { type: object, properties: { active: { type: boolean }, secret_rotate: { type: boolean } } } } }
      responses:
        '200':
          description: "Webhook endpoint updated successfully."
          content: { application/json: { schema: { $ref: "#/components/schemas/WebhookEndpoint" } } }
        '404': { description: "Webhook endpoint not found", content: { application/json: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }

  /webhooks/deliveries:
    get:
      summary: "Lists webhook delivery attempts for the authenticated tenant."
      operationId: "list_webhook_deliveries"
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - name: endpoint_id
          in: query
          schema: { type: string, format: uuid }
          description: "Filter by endpoint ID."
        - name: event_id
          in: query
          schema: { type: string }
          description: "Filter by event ID."
        - name: status_code
          in: query
          schema: { type: integer }
          description: "Filter by HTTP status code of the delivery."
        - name: limit
          in: query
          schema: { type: integer, default: 100, minimum: 1, maximum: 1000 }
          description: "Maximum number of results to return."
        - name: offset
          in: query
          schema: { type: integer, default: 0, minimum: 0 }
          description: "Number of results to skip."
      responses:
        '200':
          description: "A list of webhook deliveries."
          content: { application/json: { schema: { type: array, items: { $ref: "#/components/schemas/WebhookDelivery" } } } }

  /oauth/token:
    post:
      summary: "OAuth2 Client Credentials flow to generate an access token."
      operationId: "generate_oauth_token"
      requestBody:
        required: true
        content:
          application/x-www-form-urlencoded:
            schema:
              type: object
              properties:
                grant_type: { type: string, enum: ["client_credentials"] }
                username: { type: string, description: "Your client_id." }
                password: { type: string, description: "Your client_secret." }
                scope: { type: string, description: "Space-separated list of requested scopes." }
              required: [grant_type, username, password]
      responses:
        '200':
          description: "Access token generated successfully."
          content: { application/json: { schema: { $ref: "#/components/schemas/APIKeySecret" } } }
        '400': { description: "Bad Request", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }
        '401': { description: "Unauthorized", content: { application: { schema: { $ref: "#/components/schemas/ErrorResponse" } } } }