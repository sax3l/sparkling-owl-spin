# GitHub Copilot Test Framework Guide

Denna fil hjälper GitHub Copilot att förstå vårt testframework och generera bättre testsuggestions.

## Test Framework Overview

Vi använder pytest med följande struktur:
- Unit tests: `tests/unit/` - Snabba, isolerade tester
- Integration tests: `tests/integration/` - Komponentinteraktion
- E2E tests: `tests/e2e/` - Browser-baserade end-to-end tester

## Naming Conventions

### Test Files
- Format: `test_*.py`
- Exempel: `test_transformers.py`, `test_validators.py`

### Test Functions  
- Format: `test_*` eller `test_*_when_*_then_*`
- Exempel: `test_decimal_conversion`, `test_validation_when_invalid_then_fails`

### Test Classes
- Format: `Test*` (PascalCase)
- Exempel: `TestVehicleValidator`, `TestProxyManager`

## Pytest Markers

Använd dessa markers för att kategorisera tester:

```python
@pytest.mark.unit         # Unit test
@pytest.mark.integration  # Integration test  
@pytest.mark.e2e          # End-to-end test
@pytest.mark.db           # Requires database
@pytest.mark.browser      # Requires browser
@pytest.mark.slow         # Takes >5 seconds
```

## Test Documentation Pattern

Varje test ska ha en docstring som följer detta mönster:

```python
def test_example():
    """
    Test: Kort beskrivning av vad som testas
    
    För nybörjare: Förklaring av konceptet och varför det är viktigt.
    Beskriver vad funktionen gör och varför vi testar det.
    """
    # Given - Arrangera testdata
    input_data = "test_input"
    expected = "expected_output"
    
    # When - Utför åtgärden som testas
    result = function_under_test(input_data)
    
    # Then - Verifiera resultatet
    assert result == expected
```

## Common Fixtures

Dessa fixtures finns tillgängliga i conftest.py:

- `redis_client` - FakeRedis instance för tester
- `temp_database` - Tillfällig testdatabas
- `sample_html(filename)` - Laddar HTML från fixtures/
- `mock_response` - HTTP response mocks
- `synthetic_hosts` - URLs till syntetiska test-tjänster

## Test Data Patterns

### Parametriserade tester
```python
@pytest.mark.parametrize("input_value,expected", [
    ("123.45", 123.45),
    ("123,45", 123.45),  # Svenska decimaler
    ("invalid", None),   # Error case
])
def test_decimal_conversion(input_value, expected):
    result = to_decimal(input_value)
    assert result == expected
```

### Svenska testdata
```python
# Använd svenska format för realistiska tester
registration_numbers = ["ABC123", "XYZ789", "DEF45G"]
swedish_dates = ["2024-03-15", "15/3/2024", "15 mars 2024"]
decimal_formats = ["123,45", "1 234,56", "2.500,75"]
```

## Browser Test Patterns

### Playwright setup
```python
@pytest.mark.e2e
@pytest.mark.browser
async def test_form_interaction(page):
    """Test user interaction with web form"""
    await page.goto("http://localhost:8083/form")
    await page.fill("#input_field", "test_value")
    await page.click("button[type=submit]")
    await page.wait_for_url("**/success")
```

### Synthetic services
- Static List: `http://localhost:8081/list`
- Infinite Scroll: `http://localhost:8082/scroll`  
- Form Flow: `http://localhost:8083/form`

## Error Testing Patterns

Testa alltid både success och failure scenarios:

```python
def test_validation_success():
    """Test valid input passes validation"""
    assert validate_registration("ABC123") == True

def test_validation_failure():
    """Test invalid input fails validation"""
    assert validate_registration("invalid") == False
    
def test_validation_error_handling():
    """Test proper error handling for edge cases"""
    with pytest.raises(ValidationError):
        validate_registration(None)
```

## Mock Patterns

### HTTP responses
```python
@pytest.fixture
def mock_http_response():
    return Mock(
        status_code=200,
        text='<html>test content</html>',
        json=lambda: {'key': 'value'}
    )
```

### Database operations
```python
@pytest.fixture
def mock_database():
    db = Mock()
    db.query.return_value = [{'id': 1, 'name': 'test'}]
    return db
```

## Async Test Patterns

```python
@pytest.mark.asyncio
async def test_async_operation():
    """Test asynchronous function"""
    result = await async_function()
    assert result is not None
```

## Integration Test Patterns

### Database tests
```python
@pytest.mark.integration
@pytest.mark.db
def test_database_operation(temp_database):
    """Test database interaction"""
    # Använd temp_database fixture
    record = temp_database.insert(test_data)
    assert record.id is not None
```

### Redis tests
```python
@pytest.mark.integration
def test_redis_operation(redis_client):
    """Test Redis cache operation"""
    redis_client.set("key", "value")
    assert redis_client.get("key") == b"value"
```

## Performance Test Patterns

```python
@pytest.mark.slow
def test_performance():
    """Test performance requirements"""
    import time
    start = time.time()
    
    result = slow_operation()
    
    duration = time.time() - start
    assert duration < 5.0  # Max 5 seconds
    assert result is not None
```

## Security Test Patterns

```python
def test_csrf_protection():
    """Test CSRF token validation"""
    response = client.post('/form', data={'field': 'value'})
    assert response.status_code == 403  # No CSRF token
    
def test_input_sanitization():
    """Test XSS prevention"""
    malicious_input = "<script>alert('xss')</script>"
    result = sanitize_input(malicious_input)
    assert "<script>" not in result
```

## Data Quality Test Patterns

```python
def test_data_quality():
    """Test scraped data meets quality requirements"""
    scraped_data = scrape_website()
    
    for item in scraped_data:
        # Kolla obligatoriska fält
        assert item.get('registration_number')
        assert len(item['registration_number']) >= 6
        
        # Kolla datatyper
        assert isinstance(item.get('year'), int)
        assert 1980 <= item['year'] <= 2024
        
        # Kolla format
        assert re.match(r'^[A-Z]{3}\d{3}$', item['registration_number'])
```

## Command Line Test Patterns

För att köra specifika tester:

```bash
# Kör alla unit-tester
pytest tests/unit/ -v

# Kör tester för specifik fil
pytest tests/unit/test_transformers.py -v

# Kör tester med specifik marker
pytest -m "unit and not slow" -v

# Kör specifik test-funktion
pytest tests/unit/test_transformers.py::test_decimal_conversion -v

# Kör med coverage
pytest --cov=src tests/unit/ --cov-report=html
```

## CI/CD Patterns

Tester ska vara:
- Deterministiska (samma resultat varje gång)
- Isolerade (påverkar inte varandra)
- Snabba (unit-tester <1s, integration <10s, E2E <60s)
- Självständiga (kan köras i vilken ordning som helst)

## Common Assertions

```python
# Basic assertions
assert result == expected
assert result is not None
assert len(items) > 0
assert 'key' in dictionary

# String assertions  
assert 'substring' in text
assert text.startswith('prefix')
assert re.match(r'pattern', text)

# Numeric assertions
assert 0 < value < 100
assert abs(result - expected) < 0.01  # Float comparison

# Collection assertions
assert item in collection
assert all(condition for item in collection)
assert any(condition for item in collection)

# Exception assertions
with pytest.raises(ValueError):
    function_that_should_fail()
```

## Best Practices för Copilot

1. Använd beskrivande funktionsnamn
2. Skriv docstrings som förklarar "vad" och "varför"
3. Kommentera komplexa logik med "För nybörjare:"
4. Använd konsekvent namngivning för liknande tester
5. Gruppera relaterade tester i klasser
6. Testa edge cases och error conditions
7. Använd realistic svenska testdata när relevant
8. Dokumentera test-setup och förutsättningar
