name: Deploy to Staging

on:
  push:
    branches: [ develop, staging ]
  pull_request:
    branches: [ main ]
    types: [ labeled ]
  workflow_dispatch:
    inputs:
      deploy_reason:
        description: 'Reason for manual deployment'
        required: true
        default: 'Manual staging deployment'

permissions:
  contents: read
  packages: write
  deployments: write
  checks: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  check-deployment-label:
    name: Check Deployment Label
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    
    steps:
    - name: Check for deploy label
      id: check
      run: |
        if [[ "${{ contains(github.event.pull_request.labels.*.name, 'deploy:staging') }}" == "true" ]]; then
          echo "should_deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        fi

  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' || 
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'pull_request' && needs.check-deployment-label.outputs.should_deploy == 'true')
    needs: [check-deployment-label]
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements_dev.txt

    - name: Run linting
      run: |
        ruff check src/ tests/
        mypy src/

    - name: Run unit tests
      run: |
        pytest tests/unit/ -v --cov=src --cov-report=xml

    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

    - name: Check database migrations
      run: |
        python scripts/init_db.py --check-migrations

  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    strategy:
      matrix:
        component: [app, worker, browser]
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.component }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=staging-
          type=raw,value=staging-latest

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.${{ matrix.component }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.component }}:staging-latest
        output-file: sbom-${{ matrix.component }}.spdx.json
        format: spdx-json

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ matrix.component }}
        path: sbom-${{ matrix.component }}.spdx.json

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [build-and-push]
    
    strategy:
      matrix:
        component: [app, worker, browser]
    
    steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.component }}:staging-latest
        format: 'sarif'
        output: 'trivy-results-${{ matrix.component }}.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results-${{ matrix.component }}.sarif'

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-and-push]
    environment: staging
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: eu-west-1

    - name: Terraform Init
      run: |
        cd iac/terraform/envs/staging
        terraform init

    - name: Terraform Plan
      run: |
        cd iac/terraform/envs/staging
        terraform plan -out=tfplan

    - name: Terraform Apply
      run: |
        cd iac/terraform/envs/staging
        terraform apply -auto-approve tfplan

  deploy-to-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure]
    environment: staging
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config

    - name: Create namespace if not exists
      run: |
        kubectl create namespace scrapy-staging --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy secrets
      run: |
        kubectl create secret generic app-secrets \
          --namespace=scrapy-staging \
          --from-literal=db-password="${{ secrets.DB_PASSWORD_STAGING }}" \
          --from-literal=redis-password="${{ secrets.REDIS_PASSWORD_STAGING }}" \
          --from-literal=hmac-secret="${{ secrets.HMAC_SECRET_STAGING }}" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy ConfigMaps
      run: |
        kubectl create configmap app-config \
          --namespace=scrapy-staging \
          --from-file=config/ \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Apply Kubernetes manifests
      run: |
        # Update image tags in manifests
        sed -i "s|{{IMAGE_TAG}}|staging-${{ github.sha }}|g" k8s/staging/*.yaml
        
        # Apply manifests
        kubectl apply -f k8s/staging/ --namespace=scrapy-staging

    - name: Wait for deployment
      run: |
        kubectl rollout status deployment/api --namespace=scrapy-staging --timeout=600s
        kubectl rollout status deployment/worker --namespace=scrapy-staging --timeout=600s

    - name: Run database migrations
      run: |
        kubectl run migration-job \
          --namespace=scrapy-staging \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app:staging-${{ github.sha }} \
          --restart=Never \
          --command -- python scripts/init_db.py --migrate
        
        # Wait for migration to complete
        kubectl wait --for=condition=complete job/migration-job --namespace=scrapy-staging --timeout=300s

  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-to-k8s]
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install test dependencies
      run: |
        pip install requests pytest

    - name: Wait for services to be ready
      run: |
        sleep 60  # Give services time to start

    - name: Run API health check
      run: |
        python -c "
        import requests
        import sys
        
        try:
            response = requests.get('${{ secrets.STAGING_API_URL }}/health', timeout=10)
            response.raise_for_status()
            print('API health check passed')
        except Exception as e:
            print(f'API health check failed: {e}')
            sys.exit(1)
        "

    - name: Test basic functionality
      run: |
        pytest tests/smoke/ -v --staging-url="${{ secrets.STAGING_API_URL }}"

  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    if: github.event_name != 'pull_request'  # Skip for PRs
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install performance testing tools
      run: |
        pip install locust

    - name: Run performance tests
      run: |
        locust --headless \
          --users 10 \
          --spawn-rate 2 \
          --run-time 5m \
          --host ${{ secrets.STAGING_API_URL }} \
          -f tests/performance/locustfile.py

  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [smoke-tests, performance-tests]
    if: always()
    
    steps:
    - name: Determine deployment status
      id: status
      run: |
        if [[ "${{ needs.smoke-tests.result }}" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=✅ Staging deployment successful" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=❌ Staging deployment failed" >> $GITHUB_OUTPUT
        fi

    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ steps.status.outputs.status }}
        channel: '#deployments'
        message: |
          ${{ steps.status.outputs.message }}
          
          **Environment:** Staging
          **Commit:** ${{ github.sha }}
          **Author:** ${{ github.actor }}
          **Workflow:** ${{ github.workflow }}
          
          **Services deployed:**
          • API: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app:staging-${{ github.sha }}
          • Worker: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-worker:staging-${{ github.sha }}
          • Browser: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-browser:staging-${{ github.sha }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Create deployment
      uses: chrnorm/deployment-action@v2
      with:
        token: ${{ github.token }}
        environment: staging
        description: "Staging deployment of ${{ github.sha }}"

  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [deploy-to-k8s, smoke-tests]
    if: failure()
    
    steps:
    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config

    - name: Rollback deployment
      run: |
        kubectl rollout undo deployment/api --namespace=scrapy-staging || true
        kubectl rollout undo deployment/worker --namespace=scrapy-staging || true

    - name: Clean up failed resources
      run: |
        kubectl delete job migration-job --namespace=scrapy-staging || true

    - name: Notify failure
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#alerts'
        message: |
          🚨 **STAGING DEPLOYMENT FAILED** 🚨
          
          A staging deployment has failed and been rolled back.
          
          **Commit:** ${{ github.sha }}
          **Author:** ${{ github.actor }}
          **Workflow:** ${{ github.workflow }}
          **Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Please check the workflow logs for details.
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
