#!/usr/bin/env python3
"""
CAPTCHA Solver Adapter f√∂r Sparkling-Owl-Spin
Penetrationstestning av egna servrar med CAPTCHA-skydd
"""

import logging
import asyncio
import aiohttp
import json
import time
import base64
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import io
from PIL import Image

logger = logging.getLogger(__name__)

class CaptchaType(Enum):
    """CAPTCHA types"""
    IMAGE = "image"
    RECAPTCHA_V2 = "recaptcha_v2"
    RECAPTCHA_V3 = "recaptcha_v3"
    HCAPTCHA = "hcaptcha"
    TURNSTILE = "turnstile"
    FUNCAPTCHA = "funcaptcha"
    TEXT = "text"

class SolverService(Enum):
    """CAPTCHA solver services"""
    TWOCAPTCHA = "2captcha"
    ANTICAPTCHA = "anticaptcha"
    CAPMONSTER = "capmonster"
    NOPECHA = "nopecha"
    MOCK = "mock"

@dataclass
class CaptchaChallenge:
    """CAPTCHA challenge data"""
    type: CaptchaType
    image_data: Optional[bytes] = None
    site_key: Optional[str] = None
    site_url: Optional[str] = None
    text_challenge: Optional[str] = None
    additional_params: Optional[Dict[str, Any]] = None

@dataclass
class CaptchaSolution:
    """CAPTCHA solution result"""
    success: bool
    solution: Optional[str] = None
    task_id: Optional[str] = None
    cost: Optional[float] = None
    solving_time: Optional[float] = None
    solver_used: Optional[SolverService] = None
    error_message: Optional[str] = None

class CaptchaSolverAdapter:
    """CAPTCHA Solver integration f√∂r penetrationstestning av egna servrar"""
    
    def __init__(self, plugin_info):
        self.plugin_info = plugin_info
        self.initialized = False
        self.session: Optional[aiohttp.ClientSession] = None
        
        # API keys f√∂r olika tj√§nster
        self.api_keys = {
            SolverService.TWOCAPTCHA: None,
            SolverService.ANTICAPTCHA: None,
            SolverService.CAPMONSTER: None,
            SolverService.NOPECHA: None
        }
        
        # API endpoints
        self.endpoints = {
            SolverService.TWOCAPTCHA: "http://2captcha.com",
            SolverService.ANTICAPTCHA: "https://api.anti-captcha.com",
            SolverService.CAPMONSTER: "https://api.capmonster.cloud",
            SolverService.NOPECHA: "https://api.nopecha.com"
        }
        
        # Penetrationstestning disclaimer
        self.authorized_domains = set()
        
        # Statistik
        self.stats = {
            "total_captchas_solved": 0,
            "successful_solutions": 0,
            "failed_solutions": 0,
            "by_type": {},
            "by_service": {},
            "total_cost": 0.0,
            "average_solving_time": 0.0
        }
        
    async def initialize(self):
        """Initialize CAPTCHA Solver adapter"""
        try:
            logger.info("üß© Initializing CAPTCHA Solver Adapter (Authorized Pentest Only)")
            
            # Skapa aiohttp session
            timeout = aiohttp.ClientTimeout(total=120, connect=30)
            self.session = aiohttp.ClientSession(timeout=timeout)
            
            # Initiera statistik
            for captcha_type in CaptchaType:
                self.stats["by_type"][captcha_type.value] = {
                    "attempts": 0,
                    "successes": 0,
                    "failures": 0
                }
                
            for service in SolverService:
                self.stats["by_service"][service.value] = {
                    "attempts": 0,
                    "successes": 0,
                    "failures": 0,
                    "total_cost": 0.0
                }
            
            # Ladda API keys fr√•n milj√∂variabler
            await self._load_api_keys()
            
            self.initialized = True
            logger.info("‚úÖ CAPTCHA Solver Adapter initialized f√∂r penetrationstestning")
            logger.warning("‚ö†Ô∏è ENDAST F√ñR PENETRATIONSTESTNING AV EGNA SERVRAR")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize CAPTCHA Solver: {str(e)}")
            self.initialized = True  # Continue with mock functionality
            
    async def _load_api_keys(self):
        """Ladda API keys fr√•n milj√∂variabler"""
        import os
        
        env_mapping = {
            SolverService.TWOCAPTCHA: "TWOCAPTCHA_API_KEY",
            SolverService.ANTICAPTCHA: "ANTICAPTCHA_API_KEY", 
            SolverService.CAPMONSTER: "CAPMONSTER_API_KEY",
            SolverService.NOPECHA: "NOPECHA_API_KEY"
        }
        
        for service, env_var in env_mapping.items():
            api_key = os.getenv(env_var)
            if api_key:
                self.api_keys[service] = api_key
                logger.info(f"‚úÖ Loaded API key f√∂r {service.value}")
            else:
                logger.warning(f"‚ö†Ô∏è No API key found f√∂r {service.value} ({env_var})")
                
    def add_authorized_domain(self, domain: str):
        """L√§gg till auktoriserad dom√§n f√∂r penetrationstestning"""
        self.authorized_domains.add(domain.lower())
        logger.info(f"‚úÖ Added authorized domain f√∂r CAPTCHA testing: {domain}")
        
    def _is_domain_authorized(self, url: str) -> bool:
        """Kontrollera om dom√§n √§r auktoriserad f√∂r testning"""
        from urllib.parse import urlparse
        
        domain = urlparse(url).netloc.lower()
        
        if domain in self.authorized_domains:
            return True
            
        for auth_domain in self.authorized_domains:
            if domain.endswith(f".{auth_domain}"):
                return True
                
        return False
        
    async def solve_captcha(self, challenge: CaptchaChallenge, 
                          preferred_service: Optional[SolverService] = None) -> CaptchaSolution:
        """L√∂s CAPTCHA (endast f√∂r auktoriserade dom√§ner)"""
        
        if not self.initialized:
            await self.initialize()
            
        # S√§kerhetskontroll f√∂r site_url
        if challenge.site_url and not self._is_domain_authorized(challenge.site_url):
            error_msg = f"üö´ Domain not authorized f√∂r CAPTCHA testing: {challenge.site_url}"
            logger.error(error_msg)
            return CaptchaSolution(
                success=False,
                error_message=error_msg
            )
            
        self.stats["total_captchas_solved"] += 1
        self.stats["by_type"][challenge.type.value]["attempts"] += 1
        
        start_time = time.time()
        
        # V√§lj solver service
        if preferred_service and self.api_keys.get(preferred_service):
            services_to_try = [preferred_service]
        else:
            # Prova i ordning baserat p√• tillg√§nglighet
            services_to_try = [
                service for service in [
                    SolverService.TWOCAPTCHA,
                    SolverService.ANTICAPTCHA, 
                    SolverService.CAPMONSTER,
                    SolverService.NOPECHA
                ] if self.api_keys.get(service)
            ]
            
        # L√§gg till mock som fallback
        if not services_to_try or SolverService.MOCK not in services_to_try:
            services_to_try.append(SolverService.MOCK)
            
        # Prova services
        for service in services_to_try:
            try:
                self.stats["by_service"][service.value]["attempts"] += 1
                
                if service == SolverService.TWOCAPTCHA:
                    solution = await self._solve_with_2captcha(challenge)
                elif service == SolverService.ANTICAPTCHA:
                    solution = await self._solve_with_anticaptcha(challenge)
                elif service == SolverService.CAPMONSTER:
                    solution = await self._solve_with_capmonster(challenge)
                elif service == SolverService.NOPECHA:
                    solution = await self._solve_with_nopecha(challenge)
                else:  # MOCK
                    solution = await self._solve_with_mock(challenge)
                    
                # Ber√§kna solving time
                solving_time = time.time() - start_time
                solution.solving_time = solving_time
                solution.solver_used = service
                
                # Uppdatera statistik
                if solution.success:
                    self.stats["successful_solutions"] += 1
                    self.stats["by_type"][challenge.type.value]["successes"] += 1
                    self.stats["by_service"][service.value]["successes"] += 1
                    
                    if solution.cost:
                        self.stats["total_cost"] += solution.cost
                        self.stats["by_service"][service.value]["total_cost"] += solution.cost
                        
                    logger.info(f"‚úÖ CAPTCHA solved med {service.value} ({solving_time:.2f}s)")
                    return solution
                else:
                    self.stats["by_service"][service.value]["failures"] += 1
                    logger.warning(f"‚ùå CAPTCHA solving failed med {service.value}: {solution.error_message}")
                    
            except Exception as e:
                logger.error(f"‚ùå Error med {service.value}: {str(e)}")
                self.stats["by_service"][service.value]["failures"] += 1
                continue
                
        # Alla services misslyckades
        self.stats["failed_solutions"] += 1
        self.stats["by_type"][challenge.type.value]["failures"] += 1
        
        return CaptchaSolution(
            success=False,
            solving_time=time.time() - start_time,
            error_message="All solver services failed"
        )
        
    async def _solve_with_2captcha(self, challenge: CaptchaChallenge) -> CaptchaSolution:
        """L√∂s CAPTCHA med 2captcha service"""
        
        api_key = self.api_keys[SolverService.TWOCAPTCHA]
        if not api_key:
            return CaptchaSolution(
                success=False,
                error_message="2captcha API key not configured"
            )
            
        try:
            # Skicka CAPTCHA f√∂r l√∂sning
            if challenge.type == CaptchaType.IMAGE:
                task_id = await self._submit_image_captcha_2captcha(challenge, api_key)
            elif challenge.type == CaptchaType.RECAPTCHA_V2:
                task_id = await self._submit_recaptcha_v2_2captcha(challenge, api_key)
            elif challenge.type == CaptchaType.TURNSTILE:
                task_id = await self._submit_turnstile_2captcha(challenge, api_key)
            else:
                return CaptchaSolution(
                    success=False,
                    error_message=f"Unsupported CAPTCHA type f√∂r 2captcha: {challenge.type}"
                )
                
            if not task_id:
                return CaptchaSolution(
                    success=False,
                    error_message="Failed to submit CAPTCHA to 2captcha"
                )
                
            # V√§nta p√• l√∂sning
            solution = await self._get_2captcha_result(task_id, api_key)
            
            return CaptchaSolution(
                success=bool(solution),
                solution=solution,
                task_id=task_id,
                cost=0.002  # Approximate cost per CAPTCHA
            )
            
        except Exception as e:
            return CaptchaSolution(
                success=False,
                error_message=f"2captcha error: {str(e)}"
            )
            
    async def _submit_image_captcha_2captcha(self, challenge: CaptchaChallenge, api_key: str) -> Optional[str]:
        """Skicka image CAPTCHA till 2captcha"""
        
        if not challenge.image_data:
            return None
            
        # Encode image to base64
        image_base64 = base64.b64encode(challenge.image_data).decode()
        
        data = {
            'key': api_key,
            'method': 'base64',
            'body': image_base64,
            'json': 1
        }
        
        async with self.session.post(f"{self.endpoints[SolverService.TWOCAPTCHA]}/in.php", data=data) as response:
            result = await response.json()
            
            if result.get('status') == 1:
                return result.get('request')
                
        return None
        
    async def _submit_recaptcha_v2_2captcha(self, challenge: CaptchaChallenge, api_key: str) -> Optional[str]:
        """Skicka reCAPTCHA v2 till 2captcha"""
        
        data = {
            'key': api_key,
            'method': 'userrecaptcha',
            'googlekey': challenge.site_key,
            'pageurl': challenge.site_url,
            'json': 1
        }
        
        async with self.session.post(f"{self.endpoints[SolverService.TWOCAPTCHA]}/in.php", data=data) as response:
            result = await response.json()
            
            if result.get('status') == 1:
                return result.get('request')
                
        return None
        
    async def _submit_turnstile_2captcha(self, challenge: CaptchaChallenge, api_key: str) -> Optional[str]:
        """Skicka Turnstile till 2captcha"""
        
        data = {
            'key': api_key,
            'method': 'turnstile',
            'sitekey': challenge.site_key,
            'pageurl': challenge.site_url,
            'json': 1
        }
        
        async with self.session.post(f"{self.endpoints[SolverService.TWOCAPTCHA]}/in.php", data=data) as response:
            result = await response.json()
            
            if result.get('status') == 1:
                return result.get('request')
                
        return None
        
    async def _get_2captcha_result(self, task_id: str, api_key: str, max_wait: int = 120) -> Optional[str]:
        """H√§mta resultat fr√•n 2captcha"""
        
        start_time = time.time()
        
        while time.time() - start_time < max_wait:
            await asyncio.sleep(5)  # V√§nta 5 sekunder mellan polls
            
            params = {
                'key': api_key,
                'action': 'get',
                'id': task_id,
                'json': 1
            }
            
            try:
                async with self.session.get(f"{self.endpoints[SolverService.TWOCAPTCHA]}/res.php", params=params) as response:
                    result = await response.json()
                    
                    if result.get('status') == 1:
                        return result.get('request')
                    elif result.get('error_text'):
                        logger.error(f"2captcha error: {result['error_text']}")
                        break
                        
            except Exception as e:
                logger.error(f"Error polling 2captcha: {str(e)}")
                break
                
        return None
        
    async def _solve_with_anticaptcha(self, challenge: CaptchaChallenge) -> CaptchaSolution:
        """L√∂s CAPTCHA med Anti-Captcha service"""
        
        # Similar implementation as 2captcha but with Anti-Captcha API
        return CaptchaSolution(
            success=False,
            error_message="Anti-Captcha implementation not complete"
        )
        
    async def _solve_with_capmonster(self, challenge: CaptchaChallenge) -> CaptchaSolution:
        """L√∂s CAPTCHA med CapMonster service"""
        
        # Similar implementation as 2captcha but with CapMonster API
        return CaptchaSolution(
            success=False,
            error_message="CapMonster implementation not complete"
        )
        
    async def _solve_with_nopecha(self, challenge: CaptchaChallenge) -> CaptchaSolution:
        """L√∂s CAPTCHA med NopeCHA service"""
        
        api_key = self.api_keys[SolverService.NOPECHA]
        if not api_key:
            return CaptchaSolution(
                success=False,
                error_message="NopeCHA API key not configured"
            )
            
        try:
            headers = {
                'Authorization': f'Bearer {api_key}',
                'Content-Type': 'application/json'
            }
            
            if challenge.type == CaptchaType.TURNSTILE:
                payload = {
                    'type': 'turnstile',
                    'sitekey': challenge.site_key,
                    'url': challenge.site_url
                }
            elif challenge.type == CaptchaType.RECAPTCHA_V2:
                payload = {
                    'type': 'recaptcha',
                    'sitekey': challenge.site_key,
                    'url': challenge.site_url
                }
            else:
                return CaptchaSolution(
                    success=False,
                    error_message=f"Unsupported CAPTCHA type f√∂r NopeCHA: {challenge.type}"
                )
                
            async with self.session.post(f"{self.endpoints[SolverService.NOPECHA]}/solve", 
                                       json=payload, headers=headers) as response:
                result = await response.json()
                
                if response.status == 200 and result.get('solution'):
                    return CaptchaSolution(
                        success=True,
                        solution=result['solution'],
                        cost=0.001  # Approximate cost
                    )
                else:
                    return CaptchaSolution(
                        success=False,
                        error_message=result.get('error', 'Unknown NopeCHA error')
                    )
                    
        except Exception as e:
            return CaptchaSolution(
                success=False,
                error_message=f"NopeCHA error: {str(e)}"
            )
            
    async def _solve_with_mock(self, challenge: CaptchaChallenge) -> CaptchaSolution:
        """Mock CAPTCHA solver f√∂r testning"""
        
        # Simulera solving time
        await asyncio.sleep(2 + (time.time() % 3))  # 2-5 seconds
        
        # Mock solutions baserat p√• type
        mock_solutions = {
            CaptchaType.IMAGE: "mock_text_result",
            CaptchaType.RECAPTCHA_V2: "03AGdBq24PBCbwiDRaS_MJ7XgxI6bF9XYv8AuHj-T5NXNKL7Zg",
            CaptchaType.RECAPTCHA_V3: "03AGdBq24PBCbwiDRaS_MJ7XgxI6bF9XYv8AuHj-T5NXNKL7Zg", 
            CaptchaType.TURNSTILE: "0.BWKdaOoJ1Y_RWFLjTvn_7-RQ7WlLrTnl3Rln5_RT3kQ",
            CaptchaType.HCAPTCHA: "P1_eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9",
            CaptchaType.TEXT: "5A7B9"
        }
        
        # 85% success rate f√∂r mock
        success = (time.time() % 100) < 85
        
        if success:
            return CaptchaSolution(
                success=True,
                solution=mock_solutions.get(challenge.type, "mock_solution"),
                cost=0.0  # Mock √§r gratis
            )
        else:
            return CaptchaSolution(
                success=False,
                error_message="Mock solver randomly failed"
            )
            
    async def solve_image_captcha_from_url(self, image_url: str, site_url: str) -> CaptchaSolution:
        """L√∂s image CAPTCHA fr√•n URL"""
        
        if not self._is_domain_authorized(site_url):
            return CaptchaSolution(
                success=False,
                error_message=f"Domain not authorized: {site_url}"
            )
            
        try:
            # Ladda ner bild
            async with self.session.get(image_url) as response:
                if response.status == 200:
                    image_data = await response.read()
                    
                    challenge = CaptchaChallenge(
                        type=CaptchaType.IMAGE,
                        image_data=image_data,
                        site_url=site_url
                    )
                    
                    return await self.solve_captcha(challenge)
                else:
                    return CaptchaSolution(
                        success=False,
                        error_message=f"Failed to download image: {response.status}"
                    )
                    
        except Exception as e:
            return CaptchaSolution(
                success=False,
                error_message=f"Error loading image: {str(e)}"
            )
            
    def get_captcha_statistics(self) -> Dict[str, Any]:
        """H√§mta CAPTCHA-statistik"""
        return {
            "total_captchas_solved": self.stats["total_captchas_solved"],
            "successful_solutions": self.stats["successful_solutions"],
            "failed_solutions": self.stats["failed_solutions"],
            "success_rate": (
                self.stats["successful_solutions"] / max(1, self.stats["total_captchas_solved"])
            ) * 100,
            "by_type": self.stats["by_type"],
            "by_service": self.stats["by_service"],
            "total_cost": self.stats["total_cost"],
            "average_solving_time": self.stats["average_solving_time"],
            "authorized_domains": list(self.authorized_domains),
            "available_services": [
                service.value for service in SolverService 
                if self.api_keys.get(service) or service == SolverService.MOCK
            ]
        }
        
    def set_api_key(self, service: SolverService, api_key: str):
        """S√§tt API key f√∂r en service"""
        self.api_keys[service] = api_key
        logger.info(f"‚úÖ API key updated f√∂r {service.value}")
        
    async def test_solver_services(self) -> Dict[str, bool]:
        """Testa alla tillg√§ngliga solver services"""
        
        results = {}
        
        # Skapa test challenge
        test_challenge = CaptchaChallenge(
            type=CaptchaType.IMAGE,
            image_data=self._create_test_captcha_image(),
            site_url="https://test.localhost"
        )
        
        # L√§gg till test domain som auktoriserad
        self.add_authorized_domain("test.localhost")
        
        for service in SolverService:
            try:
                if service == SolverService.MOCK or self.api_keys.get(service):
                    solution = await self.solve_captcha(test_challenge, service)
                    results[service.value] = solution.success
                else:
                    results[service.value] = False
                    
            except Exception as e:
                logger.error(f"Error testing {service.value}: {str(e)}")
                results[service.value] = False
                
        return results
        
    def _create_test_captcha_image(self) -> bytes:
        """Skapa test CAPTCHA image"""
        try:
            # Skapa enkel test-bild
            img = Image.new('RGB', (200, 50), color='white')
            
            # Konvertera till bytes
            img_bytes = io.BytesIO()
            img.save(img_bytes, format='PNG')
            return img_bytes.getvalue()
            
        except ImportError:
            # Fallback om PIL inte √§r tillg√§ngligt
            return b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\xc8\x00\x00\x002'  # Minimal PNG header
            
    async def cleanup(self):
        """Cleanup CAPTCHA Solver adapter"""
        logger.info("üßπ Cleaning up CAPTCHA Solver Adapter")
        
        if self.session:
            await self.session.close()
            
        self.api_keys.clear()
        self.authorized_domains.clear()
        self.stats.clear()
        self.initialized = False
        logger.info("‚úÖ CAPTCHA Solver Adapter cleanup completed")
