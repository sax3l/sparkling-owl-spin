#!/usr/bin/env python3
"""
Cloudflare Bypass Adapter fÃ¶r Sparkling-Owl-Spin
Penetrationstestning av egna servrar med Cloudflare-skydd
"""

import logging
import asyncio
import aiohttp
import json
import time
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import re
import subprocess
from pathlib import Path

logger = logging.getLogger(__name__)

class BypassMethod(Enum):
    """Cloudflare bypass methods"""
    FLARESOLVERR = "flaresolverr"
    CLOUDSCRAPER = "cloudscraper" 
    UNDETECTED_CHROME = "undetected_chrome"
    CUSTOM_TLS = "custom_tls"
    HEADERS_MANIPULATION = "headers_manipulation"

@dataclass
class BypassConfig:
    """Configuration fÃ¶r bypass-fÃ¶rsÃ¶k"""
    method: BypassMethod
    timeout: int = 60
    max_retries: int = 3
    delay_between_retries: float = 2.0
    custom_headers: Optional[Dict[str, str]] = None
    proxy: Optional[str] = None
    user_agent: Optional[str] = None

@dataclass
class BypassResult:
    """Result frÃ¥n bypass-fÃ¶rsÃ¶k"""
    success: bool
    method_used: BypassMethod
    response_content: Optional[str] = None
    cookies: Optional[Dict[str, str]] = None
    headers: Optional[Dict[str, str]] = None
    status_code: Optional[int] = None
    execution_time: Optional[float] = None
    error_message: Optional[str] = None

class CloudflareBypassAdapter:
    """Cloudflare Bypass integration fÃ¶r penetrationstestning av egna servrar"""
    
    def __init__(self, plugin_info):
        self.plugin_info = plugin_info
        self.initialized = False
        self.session: Optional[aiohttp.ClientSession] = None
        
        # FlareSolverr konfiguration
        self.flaresolverr_url = "http://localhost:8191/v1"
        
        # Penetrationstestning disclaimer
        self.authorized_domains = set()  # Endast auktoriserade domÃ¤ner
        
        # Statistik
        self.stats = {
            "total_bypass_attempts": 0,
            "successful_bypasses": 0,
            "failed_bypasses": 0,
            "by_method": {},
            "by_domain": {},
            "average_response_time": 0.0
        }
        
    async def initialize(self):
        """Initialize Cloudflare Bypass adapter"""
        try:
            logger.info("ðŸ”“ Initializing Cloudflare Bypass Adapter (Authorized Pentest Only)")
            
            # Skapa aiohttp session
            timeout = aiohttp.ClientTimeout(total=60, connect=30)
            self.session = aiohttp.ClientSession(timeout=timeout)
            
            # Initiera statistik fÃ¶r metoder
            for method in BypassMethod:
                self.stats["by_method"][method.value] = {
                    "attempts": 0,
                    "successes": 0,
                    "failures": 0,
                    "avg_time": 0.0
                }
            
            # Testa FlareSolverr-anslutning
            await self._test_flaresolverr_connection()
            
            # Testa andra verktyg
            await self._test_cloudscraper_availability()
            await self._test_undetected_chrome()
            
            self.initialized = True
            logger.info("âœ… Cloudflare Bypass Adapter initialized fÃ¶r penetrationstestning")
            
            # Varning om auktoriserad anvÃ¤ndning
            logger.warning("âš ï¸ ENDAST FÃ–R PENETRATIONSTESTNING AV EGNA SERVRAR")
            
        except Exception as e:
            logger.error(f"âŒ Failed to initialize Cloudflare Bypass: {str(e)}")
            # FortsÃ¤tt med begrÃ¤nsad funktionalitet
            self.initialized = True
            
    def add_authorized_domain(self, domain: str):
        """LÃ¤gg till auktoriserad domÃ¤n fÃ¶r penetrationstestning"""
        self.authorized_domains.add(domain.lower())
        logger.info(f"âœ… Added authorized domain fÃ¶r pentest: {domain}")
        
    def _is_domain_authorized(self, url: str) -> bool:
        """Kontrollera om domÃ¤n Ã¤r auktoriserad fÃ¶r testning"""
        from urllib.parse import urlparse
        
        domain = urlparse(url).netloc.lower()
        
        # Kontrollera exact match
        if domain in self.authorized_domains:
            return True
            
        # Kontrollera subdomain match
        for auth_domain in self.authorized_domains:
            if domain.endswith(f".{auth_domain}"):
                return True
                
        return False
        
    async def _test_flaresolverr_connection(self):
        """Testa anslutning till FlareSolverr"""
        try:
            async with self.session.post(
                self.flaresolverr_url,
                json={"cmd": "sessions.list"},
                timeout=aiohttp.ClientTimeout(total=10)
            ) as response:
                if response.status == 200:
                    logger.info("âœ… FlareSolverr connection successful")
                    return True
        except Exception as e:
            logger.warning(f"âš ï¸ FlareSolverr not available: {str(e)}")
        return False
        
    async def _test_cloudscraper_availability(self):
        """Testa om cloudscraper Ã¤r tillgÃ¤ngligt"""
        try:
            import cloudscraper
            logger.info("âœ… CloudScraper library available")
            return True
        except ImportError:
            logger.warning("âš ï¸ CloudScraper library not installed")
            return False
            
    async def _test_undetected_chrome(self):
        """Testa om undetected-chromedriver Ã¤r tillgÃ¤ngligt"""
        try:
            import undetected_chromedriver as uc
            logger.info("âœ… Undetected ChromeDriver available")
            return True
        except ImportError:
            logger.warning("âš ï¸ Undetected ChromeDriver not installed")
            return False
            
    async def bypass_cloudflare(self, url: str, config: Optional[BypassConfig] = None) -> BypassResult:
        """Bypass Cloudflare protection (endast auktoriserade domÃ¤ner)"""
        
        if not self.initialized:
            await self.initialize()
            
        # SÃ¤kerhetskontroll - endast auktoriserade domÃ¤ner
        if not self._is_domain_authorized(url):
            error_msg = f"ðŸš« Domain not authorized fÃ¶r penetrationstestning: {url}"
            logger.error(error_msg)
            return BypassResult(
                success=False,
                method_used=BypassMethod.FLARESOLVERR,
                error_message=error_msg
            )
            
        # Default config
        if not config:
            config = BypassConfig(method=BypassMethod.FLARESOLVERR)
            
        self.stats["total_bypass_attempts"] += 1
        self.stats["by_method"][config.method.value]["attempts"] += 1
        
        start_time = time.time()
        
        try:
            # VÃ¤lj bypass-metod
            if config.method == BypassMethod.FLARESOLVERR:
                result = await self._bypass_with_flaresolverr(url, config)
            elif config.method == BypassMethod.CLOUDSCRAPER:
                result = await self._bypass_with_cloudscraper(url, config)
            elif config.method == BypassMethod.UNDETECTED_CHROME:
                result = await self._bypass_with_undetected_chrome(url, config)
            elif config.method == BypassMethod.CUSTOM_TLS:
                result = await self._bypass_with_custom_tls(url, config)
            elif config.method == BypassMethod.HEADERS_MANIPULATION:
                result = await self._bypass_with_headers(url, config)
            else:
                result = BypassResult(
                    success=False,
                    method_used=config.method,
                    error_message=f"Unsupported method: {config.method}"
                )
                
            # BerÃ¤kna execution time
            execution_time = time.time() - start_time
            result.execution_time = execution_time
            
            # Uppdatera statistik
            domain = url.split('/')[2]
            if domain not in self.stats["by_domain"]:
                self.stats["by_domain"][domain] = {"attempts": 0, "successes": 0}
                
            self.stats["by_domain"][domain]["attempts"] += 1
            
            if result.success:
                self.stats["successful_bypasses"] += 1
                self.stats["by_method"][config.method.value]["successes"] += 1
                self.stats["by_domain"][domain]["successes"] += 1
                logger.info(f"âœ… Cloudflare bypass successful fÃ¶r {url} ({execution_time:.2f}s)")
            else:
                self.stats["failed_bypasses"] += 1
                self.stats["by_method"][config.method.value]["failures"] += 1
                logger.warning(f"âŒ Cloudflare bypass failed fÃ¶r {url}: {result.error_message}")
                
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            error_result = BypassResult(
                success=False,
                method_used=config.method,
                execution_time=execution_time,
                error_message=str(e)
            )
            
            self.stats["failed_bypasses"] += 1
            self.stats["by_method"][config.method.value]["failures"] += 1
            
            logger.error(f"âŒ Cloudflare bypass error fÃ¶r {url}: {str(e)}")
            return error_result
            
    async def _bypass_with_flaresolverr(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med FlareSolverr"""
        
        payload = {
            "cmd": "request.get",
            "url": url,
            "maxTimeout": config.timeout * 1000,
            "returnOnlyCookies": False
        }
        
        # LÃ¤gg till proxy om specificerat
        if config.proxy:
            payload["proxy"] = {
                "url": config.proxy
            }
            
        # Custom headers
        if config.custom_headers:
            payload["headers"] = config.custom_headers
            
        try:
            async with self.session.post(
                self.flaresolverr_url,
                json=payload,
                timeout=aiohttp.ClientTimeout(total=config.timeout + 10)
            ) as response:
                
                if response.status != 200:
                    return BypassResult(
                        success=False,
                        method_used=BypassMethod.FLARESOLVERR,
                        error_message=f"FlareSolverr HTTP {response.status}"
                    )
                    
                result_json = await response.json()
                
                if result_json.get("status") == "ok":
                    solution = result_json.get("solution", {})
                    return BypassResult(
                        success=True,
                        method_used=BypassMethod.FLARESOLVERR,
                        response_content=solution.get("response"),
                        cookies=solution.get("cookies", {}),
                        headers=solution.get("headers", {}),
                        status_code=solution.get("status", 200)
                    )
                else:
                    return BypassResult(
                        success=False,
                        method_used=BypassMethod.FLARESOLVERR,
                        error_message=result_json.get("message", "Unknown FlareSolverr error")
                    )
                    
        except asyncio.TimeoutError:
            return BypassResult(
                success=False,
                method_used=BypassMethod.FLARESOLVERR,
                error_message="FlareSolverr timeout"
            )
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.FLARESOLVERR,
                error_message=f"FlareSolverr error: {str(e)}"
            )
            
    async def _bypass_with_cloudscraper(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med CloudScraper library"""
        
        try:
            import cloudscraper
            
            # Skapa scraper med anpassade instÃ¤llningar
            scraper = cloudscraper.create_scraper(
                browser={
                    'browser': 'chrome',
                    'platform': 'windows',
                    'mobile': False
                }
            )
            
            # Custom headers
            if config.custom_headers:
                scraper.headers.update(config.custom_headers)
                
            # User agent
            if config.user_agent:
                scraper.headers['User-Agent'] = config.user_agent
                
            # Proxy
            proxies = None
            if config.proxy:
                proxies = {'http': config.proxy, 'https': config.proxy}
                
            # UtfÃ¶r request
            response = scraper.get(url, timeout=config.timeout, proxies=proxies)
            
            return BypassResult(
                success=True,
                method_used=BypassMethod.CLOUDSCRAPER,
                response_content=response.text,
                cookies={cookie.name: cookie.value for cookie in response.cookies},
                headers=dict(response.headers),
                status_code=response.status_code
            )
            
        except ImportError:
            return BypassResult(
                success=False,
                method_used=BypassMethod.CLOUDSCRAPER,
                error_message="CloudScraper library not installed"
            )
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.CLOUDSCRAPER,
                error_message=f"CloudScraper error: {str(e)}"
            )
            
    async def _bypass_with_undetected_chrome(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med Undetected ChromeDriver"""
        
        try:
            import undetected_chromedriver as uc
            from selenium.webdriver.common.by import By
            from selenium.webdriver.support.ui import WebDriverWait
            from selenium.webdriver.support import expected_conditions as EC
            
            # Chrome options
            options = uc.ChromeOptions()
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--disable-gpu')
            
            if config.user_agent:
                options.add_argument(f'--user-agent={config.user_agent}')
                
            # Proxy
            if config.proxy:
                options.add_argument(f'--proxy-server={config.proxy}')
                
            # Skapa driver
            driver = None
            try:
                driver = uc.Chrome(options=options)
                driver.set_page_load_timeout(config.timeout)
                
                # Navigera till sida
                driver.get(url)
                
                # VÃ¤nta tills sidan Ã¤r laddad (eller Cloudflare Ã¤r bypassad)
                wait = WebDriverWait(driver, config.timeout)
                
                # VÃ¤nta pÃ¥ att sidan inte innehÃ¥ller Cloudflare-indikatorer
                try:
                    wait.until_not(
                        lambda d: "Checking your browser" in d.page_source or 
                                 "DDoS protection by Cloudflare" in d.page_source
                    )
                except:
                    pass  # FortsÃ¤tt Ã¤ven om vÃ¤ntan timeout
                    
                # HÃ¤mta cookies
                cookies = {cookie['name']: cookie['value'] for cookie in driver.get_cookies()}
                
                return BypassResult(
                    success=True,
                    method_used=BypassMethod.UNDETECTED_CHROME,
                    response_content=driver.page_source,
                    cookies=cookies,
                    status_code=200  # Selenium ger inte direkt Ã¥tkomst till status kod
                )
                
            finally:
                if driver:
                    driver.quit()
                    
        except ImportError:
            return BypassResult(
                success=False,
                method_used=BypassMethod.UNDETECTED_CHROME,
                error_message="Undetected ChromeDriver not installed"
            )
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.UNDETECTED_CHROME,
                error_message=f"Undetected Chrome error: {str(e)}"
            )
            
    async def _bypass_with_custom_tls(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med custom TLS fingerprinting"""
        
        try:
            # Anpassade TLS-instÃ¤llningar fÃ¶r att efterlikna Chrome
            connector = aiohttp.TCPConnector(
                ssl_context=self._create_chrome_ssl_context(),
                limit=100,
                limit_per_host=10
            )
            
            headers = {
                'User-Agent': config.user_agent or self._get_chrome_user_agent(),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9,sv;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
                'Cache-Control': 'max-age=0'
            }
            
            if config.custom_headers:
                headers.update(config.custom_headers)
                
            async with aiohttp.ClientSession(connector=connector) as session:
                async with session.get(
                    url,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=config.timeout)
                ) as response:
                    
                    content = await response.text()
                    
                    return BypassResult(
                        success=True,
                        method_used=BypassMethod.CUSTOM_TLS,
                        response_content=content,
                        cookies={cookie.key: cookie.value for cookie in response.cookies.values()},
                        headers=dict(response.headers),
                        status_code=response.status
                    )
                    
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.CUSTOM_TLS,
                error_message=f"Custom TLS error: {str(e)}"
            )
            
    def _create_chrome_ssl_context(self):
        """Skapa SSL context som efterliknar Chrome"""
        import ssl
        
        context = ssl.create_default_context()
        
        # Chrome-liknande cipher suites
        context.set_ciphers(':'.join([
            'TLS_AES_128_GCM_SHA256',
            'TLS_AES_256_GCM_SHA384', 
            'TLS_CHACHA20_POLY1305_SHA256',
            'ECDHE-ECDSA-AES128-GCM-SHA256',
            'ECDHE-RSA-AES128-GCM-SHA256',
            'ECDHE-ECDSA-AES256-GCM-SHA384',
            'ECDHE-RSA-AES256-GCM-SHA384',
            'ECDHE-ECDSA-CHACHA20-POLY1305',
            'ECDHE-RSA-CHACHA20-POLY1305',
            'DHE-RSA-AES128-GCM-SHA256',
            'DHE-RSA-AES256-GCM-SHA384'
        ]))
        
        return context
        
    def _get_chrome_user_agent(self) -> str:
        """Generera Chrome User-Agent"""
        return "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36"
        
    async def _bypass_with_headers(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med header manipulation"""
        
        # Olika header-kombinationer att prova
        header_sets = [
            # Standard Chrome headers
            {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
            # Mobile headers
            {
                'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
            },
            # Bot-like headers (ironisk nog)
            {
                'User-Agent': 'Googlebot/2.1 (+http://www.google.com/bot.html)',
                'Accept': '*/*',
            }
        ]
        
        # Prova olika header-kombinationer
        for i, headers in enumerate(header_sets):
            try:
                if config.custom_headers:
                    headers.update(config.custom_headers)
                    
                async with self.session.get(
                    url,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=config.timeout)
                ) as response:
                    
                    content = await response.text()
                    
                    # Kontrollera om vi bypassade Cloudflare
                    if not self._has_cloudflare_challenge(content):
                        return BypassResult(
                            success=True,
                            method_used=BypassMethod.HEADERS_MANIPULATION,
                            response_content=content,
                            cookies={cookie.key: cookie.value for cookie in response.cookies.values()},
                            headers=dict(response.headers),
                            status_code=response.status
                        )
                        
            except Exception as e:
                logger.debug(f"Header set {i} failed: {str(e)}")
                continue
                
        return BypassResult(
            success=False,
            method_used=BypassMethod.HEADERS_MANIPULATION,
            error_message="All header combinations failed"
        )
        
    def _has_cloudflare_challenge(self, content: str) -> bool:
        """Kontrollera om sidan innehÃ¥ller Cloudflare challenge"""
        indicators = [
            "Checking your browser",
            "DDoS protection by Cloudflare",
            "cf-browser-verification",
            "cf-captcha-container",
            "__cf_chl_jschl_tk__",
            "ray ID"
        ]
        
        content_lower = content.lower()
        return any(indicator.lower() in content_lower for indicator in indicators)
        
    async def auto_bypass(self, url: str, timeout: int = 60) -> BypassResult:
        """Automatisk bypass - prova alla metoder tills en lyckas"""
        
        methods_to_try = [
            BypassMethod.FLARESOLVERR,
            BypassMethod.CLOUDSCRAPER,
            BypassMethod.HEADERS_MANIPULATION,
            BypassMethod.CUSTOM_TLS,
            BypassMethod.UNDETECTED_CHROME
        ]
        
        for method in methods_to_try:
            try:
                config = BypassConfig(method=method, timeout=timeout // len(methods_to_try))
                result = await self.bypass_cloudflare(url, config)
                
                if result.success:
                    logger.info(f"âœ… Auto-bypass successful med {method.value}")
                    return result
                    
            except Exception as e:
                logger.debug(f"Auto-bypass method {method.value} failed: {str(e)}")
                continue
                
        return BypassResult(
            success=False,
            method_used=BypassMethod.FLARESOLVERR,  # Default
            error_message="All auto-bypass methods failed"
        )
        
    def get_bypass_statistics(self) -> Dict[str, Any]:
        """HÃ¤mta bypass-statistik"""
        return {
            "total_attempts": self.stats["total_bypass_attempts"],
            "successful_bypasses": self.stats["successful_bypasses"],
            "failed_bypasses": self.stats["failed_bypasses"],
            "success_rate": (
                self.stats["successful_bypasses"] / max(1, self.stats["total_bypass_attempts"])
            ) * 100,
            "by_method": self.stats["by_method"],
            "by_domain": self.stats["by_domain"],
            "authorized_domains": list(self.authorized_domains)
        }
        
    def get_authorized_domains(self) -> List[str]:
        """HÃ¤mta lista Ã¶ver auktoriserade domÃ¤ner"""
        return list(self.authorized_domains)
        
    def remove_authorized_domain(self, domain: str):
        """Ta bort auktoriserad domÃ¤n"""
        self.authorized_domains.discard(domain.lower())
        logger.info(f"ðŸ—‘ï¸ Removed authorized domain: {domain}")
        
    async def test_bypass_methods(self, test_url: str) -> Dict[str, BypassResult]:
        """Testa alla tillgÃ¤ngliga bypass-metoder pÃ¥ en URL"""
        
        if not self._is_domain_authorized(test_url):
            logger.error(f"ðŸš« Domain not authorized fÃ¶r testing: {test_url}")
            return {}
            
        results = {}
        
        for method in BypassMethod:
            try:
                config = BypassConfig(method=method, timeout=30)
                result = await self.bypass_cloudflare(test_url, config)
                results[method.value] = result
                
                # FÃ¶rdrÃ¶jning mellan tester
                await asyncio.sleep(2)
                
            except Exception as e:
                results[method.value] = BypassResult(
                    success=False,
                    method_used=method,
                    error_message=str(e)
                )
                
        return results
        
    async def cleanup(self):
        """Cleanup Cloudflare Bypass adapter"""
        logger.info("ðŸ§¹ Cleaning up Cloudflare Bypass Adapter")
        
        if self.session:
            await self.session.close()
            
        self.authorized_domains.clear()
        self.stats.clear()
        self.initialized = False
        logger.info("âœ… Cloudflare Bypass Adapter cleanup completed")
