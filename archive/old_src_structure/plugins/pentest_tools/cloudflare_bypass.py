#!/usr/bin/env python3
"""
Cloudflare Bypass Adapter för Sparkling-Owl-Spin
Penetrationstestning av egna servrar med Cloudflare-skydd
"""

import logging
import asyncio
import aiohttp
import json
import time
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import re
import subprocess
from pathlib import Path

logger = logging.getLogger(__name__)

class BypassMethod(Enum):
    """Cloudflare bypass methods"""
    FLARESOLVERR = "flaresolverr"
    CLOUDSCRAPER = "cloudscraper" 
    UNDETECTED_CHROME = "undetected_chrome"
    CUSTOM_TLS = "custom_tls"
    HEADERS_MANIPULATION = "headers_manipulation"

@dataclass
class BypassConfig:
    """Configuration för bypass-försök"""
    method: BypassMethod
    timeout: int = 60
    max_retries: int = 3
    delay_between_retries: float = 2.0
    custom_headers: Optional[Dict[str, str]] = None
    proxy: Optional[str] = None
    user_agent: Optional[str] = None

@dataclass
class BypassResult:
    """Result från bypass-försök"""
    success: bool
    method_used: BypassMethod
    response_content: Optional[str] = None
    cookies: Optional[Dict[str, str]] = None
    headers: Optional[Dict[str, str]] = None
    status_code: Optional[int] = None
    execution_time: Optional[float] = None
    error_message: Optional[str] = None

class CloudflareBypassAdapter:
    """Cloudflare Bypass integration för penetrationstestning av egna servrar"""
    
    def __init__(self, plugin_info):
        self.plugin_info = plugin_info
        self.initialized = False
        self.session: Optional[aiohttp.ClientSession] = None
        
        # FlareSolverr konfiguration
        self.flaresolverr_url = "http://localhost:8191/v1"
        
        # Penetrationstestning disclaimer
        self.authorized_domains = set()  # Endast auktoriserade domäner
        
        # Statistik
        self.stats = {
            "total_bypass_attempts": 0,
            "successful_bypasses": 0,
            "failed_bypasses": 0,
            "by_method": {},
            "by_domain": {},
            "average_response_time": 0.0
        }
        
    async def initialize(self):
        """Initialize Cloudflare Bypass adapter"""
        try:
            logger.info("🔓 Initializing Cloudflare Bypass Adapter (Authorized Pentest Only)")
            
            # Skapa aiohttp session
            timeout = aiohttp.ClientTimeout(total=60, connect=30)
            self.session = aiohttp.ClientSession(timeout=timeout)
            
            # Initiera statistik för metoder
            for method in BypassMethod:
                self.stats["by_method"][method.value] = {
                    "attempts": 0,
                    "successes": 0,
                    "failures": 0,
                    "avg_time": 0.0
                }
            
            # Testa FlareSolverr-anslutning
            await self._test_flaresolverr_connection()
            
            # Testa andra verktyg
            await self._test_cloudscraper_availability()
            await self._test_undetected_chrome()
            
            self.initialized = True
            logger.info("✅ Cloudflare Bypass Adapter initialized för penetrationstestning")
            
            # Varning om auktoriserad användning
            logger.warning("⚠️ ENDAST FÖR PENETRATIONSTESTNING AV EGNA SERVRAR")
            
        except Exception as e:
            logger.error(f"❌ Failed to initialize Cloudflare Bypass: {str(e)}")
            # Fortsätt med begränsad funktionalitet
            self.initialized = True
            
    def add_authorized_domain(self, domain: str):
        """Lägg till auktoriserad domän för penetrationstestning"""
        self.authorized_domains.add(domain.lower())
        logger.info(f"✅ Added authorized domain för pentest: {domain}")
        
    def _is_domain_authorized(self, url: str) -> bool:
        """Kontrollera om domän är auktoriserad för testning"""
        from urllib.parse import urlparse
        
        domain = urlparse(url).netloc.lower()
        
        # Kontrollera exact match
        if domain in self.authorized_domains:
            return True
            
        # Kontrollera subdomain match
        for auth_domain in self.authorized_domains:
            if domain.endswith(f".{auth_domain}"):
                return True
                
        return False
        
    async def _test_flaresolverr_connection(self):
        """Testa anslutning till FlareSolverr"""
        try:
            async with self.session.post(
                self.flaresolverr_url,
                json={"cmd": "sessions.list"},
                timeout=aiohttp.ClientTimeout(total=10)
            ) as response:
                if response.status == 200:
                    logger.info("✅ FlareSolverr connection successful")
                    return True
        except Exception as e:
            logger.warning(f"⚠️ FlareSolverr not available: {str(e)}")
        return False
        
    async def _test_cloudscraper_availability(self):
        """Testa om cloudscraper är tillgängligt"""
        try:
            import cloudscraper
            logger.info("✅ CloudScraper library available")
            return True
        except ImportError:
            logger.warning("⚠️ CloudScraper library not installed")
            return False
            
    async def _test_undetected_chrome(self):
        """Testa om undetected-chromedriver är tillgängligt"""
        try:
            import undetected_chromedriver as uc
            logger.info("✅ Undetected ChromeDriver available")
            return True
        except ImportError:
            logger.warning("⚠️ Undetected ChromeDriver not installed")
            return False
            
    async def bypass_cloudflare(self, url: str, config: Optional[BypassConfig] = None) -> BypassResult:
        """Bypass Cloudflare protection (endast auktoriserade domäner)"""
        
        if not self.initialized:
            await self.initialize()
            
        # Säkerhetskontroll - endast auktoriserade domäner
        if not self._is_domain_authorized(url):
            error_msg = f"🚫 Domain not authorized för penetrationstestning: {url}"
            logger.error(error_msg)
            return BypassResult(
                success=False,
                method_used=BypassMethod.FLARESOLVERR,
                error_message=error_msg
            )
            
        # Default config
        if not config:
            config = BypassConfig(method=BypassMethod.FLARESOLVERR)
            
        self.stats["total_bypass_attempts"] += 1
        self.stats["by_method"][config.method.value]["attempts"] += 1
        
        start_time = time.time()
        
        try:
            # Välj bypass-metod
            if config.method == BypassMethod.FLARESOLVERR:
                result = await self._bypass_with_flaresolverr(url, config)
            elif config.method == BypassMethod.CLOUDSCRAPER:
                result = await self._bypass_with_cloudscraper(url, config)
            elif config.method == BypassMethod.UNDETECTED_CHROME:
                result = await self._bypass_with_undetected_chrome(url, config)
            elif config.method == BypassMethod.CUSTOM_TLS:
                result = await self._bypass_with_custom_tls(url, config)
            elif config.method == BypassMethod.HEADERS_MANIPULATION:
                result = await self._bypass_with_headers(url, config)
            else:
                result = BypassResult(
                    success=False,
                    method_used=config.method,
                    error_message=f"Unsupported method: {config.method}"
                )
                
            # Beräkna execution time
            execution_time = time.time() - start_time
            result.execution_time = execution_time
            
            # Uppdatera statistik
            domain = url.split('/')[2]
            if domain not in self.stats["by_domain"]:
                self.stats["by_domain"][domain] = {"attempts": 0, "successes": 0}
                
            self.stats["by_domain"][domain]["attempts"] += 1
            
            if result.success:
                self.stats["successful_bypasses"] += 1
                self.stats["by_method"][config.method.value]["successes"] += 1
                self.stats["by_domain"][domain]["successes"] += 1
                logger.info(f"✅ Cloudflare bypass successful för {url} ({execution_time:.2f}s)")
            else:
                self.stats["failed_bypasses"] += 1
                self.stats["by_method"][config.method.value]["failures"] += 1
                logger.warning(f"❌ Cloudflare bypass failed för {url}: {result.error_message}")
                
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            error_result = BypassResult(
                success=False,
                method_used=config.method,
                execution_time=execution_time,
                error_message=str(e)
            )
            
            self.stats["failed_bypasses"] += 1
            self.stats["by_method"][config.method.value]["failures"] += 1
            
            logger.error(f"❌ Cloudflare bypass error för {url}: {str(e)}")
            return error_result
            
    async def _bypass_with_flaresolverr(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med FlareSolverr"""
        
        payload = {
            "cmd": "request.get",
            "url": url,
            "maxTimeout": config.timeout * 1000,
            "returnOnlyCookies": False
        }
        
        # Lägg till proxy om specificerat
        if config.proxy:
            payload["proxy"] = {
                "url": config.proxy
            }
            
        # Custom headers
        if config.custom_headers:
            payload["headers"] = config.custom_headers
            
        try:
            async with self.session.post(
                self.flaresolverr_url,
                json=payload,
                timeout=aiohttp.ClientTimeout(total=config.timeout + 10)
            ) as response:
                
                if response.status != 200:
                    return BypassResult(
                        success=False,
                        method_used=BypassMethod.FLARESOLVERR,
                        error_message=f"FlareSolverr HTTP {response.status}"
                    )
                    
                result_json = await response.json()
                
                if result_json.get("status") == "ok":
                    solution = result_json.get("solution", {})
                    return BypassResult(
                        success=True,
                        method_used=BypassMethod.FLARESOLVERR,
                        response_content=solution.get("response"),
                        cookies=solution.get("cookies", {}),
                        headers=solution.get("headers", {}),
                        status_code=solution.get("status", 200)
                    )
                else:
                    return BypassResult(
                        success=False,
                        method_used=BypassMethod.FLARESOLVERR,
                        error_message=result_json.get("message", "Unknown FlareSolverr error")
                    )
                    
        except asyncio.TimeoutError:
            return BypassResult(
                success=False,
                method_used=BypassMethod.FLARESOLVERR,
                error_message="FlareSolverr timeout"
            )
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.FLARESOLVERR,
                error_message=f"FlareSolverr error: {str(e)}"
            )
            
    async def _bypass_with_cloudscraper(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med CloudScraper library"""
        
        try:
            import cloudscraper
            
            # Skapa scraper med anpassade inställningar
            scraper = cloudscraper.create_scraper(
                browser={
                    'browser': 'chrome',
                    'platform': 'windows',
                    'mobile': False
                }
            )
            
            # Custom headers
            if config.custom_headers:
                scraper.headers.update(config.custom_headers)
                
            # User agent
            if config.user_agent:
                scraper.headers['User-Agent'] = config.user_agent
                
            # Proxy
            proxies = None
            if config.proxy:
                proxies = {'http': config.proxy, 'https': config.proxy}
                
            # Utför request
            response = scraper.get(url, timeout=config.timeout, proxies=proxies)
            
            return BypassResult(
                success=True,
                method_used=BypassMethod.CLOUDSCRAPER,
                response_content=response.text,
                cookies={cookie.name: cookie.value for cookie in response.cookies},
                headers=dict(response.headers),
                status_code=response.status_code
            )
            
        except ImportError:
            return BypassResult(
                success=False,
                method_used=BypassMethod.CLOUDSCRAPER,
                error_message="CloudScraper library not installed"
            )
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.CLOUDSCRAPER,
                error_message=f"CloudScraper error: {str(e)}"
            )
            
    async def _bypass_with_undetected_chrome(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med Undetected ChromeDriver"""
        
        try:
            import undetected_chromedriver as uc
            from selenium.webdriver.common.by import By
            from selenium.webdriver.support.ui import WebDriverWait
            from selenium.webdriver.support import expected_conditions as EC
            
            # Chrome options
            options = uc.ChromeOptions()
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--disable-gpu')
            
            if config.user_agent:
                options.add_argument(f'--user-agent={config.user_agent}')
                
            # Proxy
            if config.proxy:
                options.add_argument(f'--proxy-server={config.proxy}')
                
            # Skapa driver
            driver = None
            try:
                driver = uc.Chrome(options=options)
                driver.set_page_load_timeout(config.timeout)
                
                # Navigera till sida
                driver.get(url)
                
                # Vänta tills sidan är laddad (eller Cloudflare är bypassad)
                wait = WebDriverWait(driver, config.timeout)
                
                # Vänta på att sidan inte innehåller Cloudflare-indikatorer
                try:
                    wait.until_not(
                        lambda d: "Checking your browser" in d.page_source or 
                                 "DDoS protection by Cloudflare" in d.page_source
                    )
                except:
                    pass  # Fortsätt även om väntan timeout
                    
                # Hämta cookies
                cookies = {cookie['name']: cookie['value'] for cookie in driver.get_cookies()}
                
                return BypassResult(
                    success=True,
                    method_used=BypassMethod.UNDETECTED_CHROME,
                    response_content=driver.page_source,
                    cookies=cookies,
                    status_code=200  # Selenium ger inte direkt åtkomst till status kod
                )
                
            finally:
                if driver:
                    driver.quit()
                    
        except ImportError:
            return BypassResult(
                success=False,
                method_used=BypassMethod.UNDETECTED_CHROME,
                error_message="Undetected ChromeDriver not installed"
            )
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.UNDETECTED_CHROME,
                error_message=f"Undetected Chrome error: {str(e)}"
            )
            
    async def _bypass_with_custom_tls(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med custom TLS fingerprinting"""
        
        try:
            # Anpassade TLS-inställningar för att efterlikna Chrome
            connector = aiohttp.TCPConnector(
                ssl_context=self._create_chrome_ssl_context(),
                limit=100,
                limit_per_host=10
            )
            
            headers = {
                'User-Agent': config.user_agent or self._get_chrome_user_agent(),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9,sv;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
                'Cache-Control': 'max-age=0'
            }
            
            if config.custom_headers:
                headers.update(config.custom_headers)
                
            async with aiohttp.ClientSession(connector=connector) as session:
                async with session.get(
                    url,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=config.timeout)
                ) as response:
                    
                    content = await response.text()
                    
                    return BypassResult(
                        success=True,
                        method_used=BypassMethod.CUSTOM_TLS,
                        response_content=content,
                        cookies={cookie.key: cookie.value for cookie in response.cookies.values()},
                        headers=dict(response.headers),
                        status_code=response.status
                    )
                    
        except Exception as e:
            return BypassResult(
                success=False,
                method_used=BypassMethod.CUSTOM_TLS,
                error_message=f"Custom TLS error: {str(e)}"
            )
            
    def _create_chrome_ssl_context(self):
        """Skapa SSL context som efterliknar Chrome"""
        import ssl
        
        context = ssl.create_default_context()
        
        # Chrome-liknande cipher suites
        context.set_ciphers(':'.join([
            'TLS_AES_128_GCM_SHA256',
            'TLS_AES_256_GCM_SHA384', 
            'TLS_CHACHA20_POLY1305_SHA256',
            'ECDHE-ECDSA-AES128-GCM-SHA256',
            'ECDHE-RSA-AES128-GCM-SHA256',
            'ECDHE-ECDSA-AES256-GCM-SHA384',
            'ECDHE-RSA-AES256-GCM-SHA384',
            'ECDHE-ECDSA-CHACHA20-POLY1305',
            'ECDHE-RSA-CHACHA20-POLY1305',
            'DHE-RSA-AES128-GCM-SHA256',
            'DHE-RSA-AES256-GCM-SHA384'
        ]))
        
        return context
        
    def _get_chrome_user_agent(self) -> str:
        """Generera Chrome User-Agent"""
        return "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36"
        
    async def _bypass_with_headers(self, url: str, config: BypassConfig) -> BypassResult:
        """Bypass med header manipulation"""
        
        # Olika header-kombinationer att prova
        header_sets = [
            # Standard Chrome headers
            {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
            # Mobile headers
            {
                'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
            },
            # Bot-like headers (ironisk nog)
            {
                'User-Agent': 'Googlebot/2.1 (+http://www.google.com/bot.html)',
                'Accept': '*/*',
            }
        ]
        
        # Prova olika header-kombinationer
        for i, headers in enumerate(header_sets):
            try:
                if config.custom_headers:
                    headers.update(config.custom_headers)
                    
                async with self.session.get(
                    url,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=config.timeout)
                ) as response:
                    
                    content = await response.text()
                    
                    # Kontrollera om vi bypassade Cloudflare
                    if not self._has_cloudflare_challenge(content):
                        return BypassResult(
                            success=True,
                            method_used=BypassMethod.HEADERS_MANIPULATION,
                            response_content=content,
                            cookies={cookie.key: cookie.value for cookie in response.cookies.values()},
                            headers=dict(response.headers),
                            status_code=response.status
                        )
                        
            except Exception as e:
                logger.debug(f"Header set {i} failed: {str(e)}")
                continue
                
        return BypassResult(
            success=False,
            method_used=BypassMethod.HEADERS_MANIPULATION,
            error_message="All header combinations failed"
        )
        
    def _has_cloudflare_challenge(self, content: str) -> bool:
        """Kontrollera om sidan innehåller Cloudflare challenge"""
        indicators = [
            "Checking your browser",
            "DDoS protection by Cloudflare",
            "cf-browser-verification",
            "cf-captcha-container",
            "__cf_chl_jschl_tk__",
            "ray ID"
        ]
        
        content_lower = content.lower()
        return any(indicator.lower() in content_lower for indicator in indicators)
        
    async def auto_bypass(self, url: str, timeout: int = 60) -> BypassResult:
        """Automatisk bypass - prova alla metoder tills en lyckas"""
        
        methods_to_try = [
            BypassMethod.FLARESOLVERR,
            BypassMethod.CLOUDSCRAPER,
            BypassMethod.HEADERS_MANIPULATION,
            BypassMethod.CUSTOM_TLS,
            BypassMethod.UNDETECTED_CHROME
        ]
        
        for method in methods_to_try:
            try:
                config = BypassConfig(method=method, timeout=timeout // len(methods_to_try))
                result = await self.bypass_cloudflare(url, config)
                
                if result.success:
                    logger.info(f"✅ Auto-bypass successful med {method.value}")
                    return result
                    
            except Exception as e:
                logger.debug(f"Auto-bypass method {method.value} failed: {str(e)}")
                continue
                
        return BypassResult(
            success=False,
            method_used=BypassMethod.FLARESOLVERR,  # Default
            error_message="All auto-bypass methods failed"
        )
        
    def get_bypass_statistics(self) -> Dict[str, Any]:
        """Hämta bypass-statistik"""
        return {
            "total_attempts": self.stats["total_bypass_attempts"],
            "successful_bypasses": self.stats["successful_bypasses"],
            "failed_bypasses": self.stats["failed_bypasses"],
            "success_rate": (
                self.stats["successful_bypasses"] / max(1, self.stats["total_bypass_attempts"])
            ) * 100,
            "by_method": self.stats["by_method"],
            "by_domain": self.stats["by_domain"],
            "authorized_domains": list(self.authorized_domains)
        }
        
    def get_authorized_domains(self) -> List[str]:
        """Hämta lista över auktoriserade domäner"""
        return list(self.authorized_domains)
        
    def remove_authorized_domain(self, domain: str):
        """Ta bort auktoriserad domän"""
        self.authorized_domains.discard(domain.lower())
        logger.info(f"🗑️ Removed authorized domain: {domain}")
        
    async def test_bypass_methods(self, test_url: str) -> Dict[str, BypassResult]:
        """Testa alla tillgängliga bypass-metoder på en URL"""
        
        if not self._is_domain_authorized(test_url):
            logger.error(f"🚫 Domain not authorized för testing: {test_url}")
            return {}
            
        results = {}
        
        for method in BypassMethod:
            try:
                config = BypassConfig(method=method, timeout=30)
                result = await self.bypass_cloudflare(test_url, config)
                results[method.value] = result
                
                # Fördröjning mellan tester
                await asyncio.sleep(2)
                
            except Exception as e:
                results[method.value] = BypassResult(
                    success=False,
                    method_used=method,
                    error_message=str(e)
                )
                
        return results
        
    async def cleanup(self):
        """Cleanup Cloudflare Bypass adapter"""
        logger.info("🧹 Cleaning up Cloudflare Bypass Adapter")
        
        if self.session:
            await self.session.close()
            
        self.authorized_domains.clear()
        self.stats.clear()
        self.initialized = False
        logger.info("✅ Cloudflare Bypass Adapter cleanup completed")
