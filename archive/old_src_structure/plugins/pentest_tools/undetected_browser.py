#!/usr/bin/env python3
"""
Browser Automation & TLS Impersonation för Sparkling-Owl-Spin
Undetected browser drivers för penetrationstestning av egna servrar
"""

import logging
import asyncio
import json
import time
from typing import Dict, List, Any, Optional, Union, Set
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import random
import ssl
import socket
from urllib.parse import urlparse

try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options as ChromeOptions
    from selenium.webdriver.firefox.options import Options as FirefoxOptions
    from selenium.common.exceptions import TimeoutException, WebDriverException
    SELENIUM_AVAILABLE = True
except ImportError:
    SELENIUM_AVAILABLE = False

try:
    import undetected_chromedriver as uc
    UC_AVAILABLE = True
except ImportError:
    UC_AVAILABLE = False

try:
    from playwright.async_api import async_playwright
    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE = False

logger = logging.getLogger(__name__)

class BrowserType(Enum):
    """Browser types"""
    CHROME = "chrome"
    FIREFOX = "firefox"
    EDGE = "edge"
    SAFARI = "safari"
    UNDETECTED_CHROME = "undetected_chrome"
    PLAYWRIGHT_CHROMIUM = "playwright_chromium"
    PLAYWRIGHT_FIREFOX = "playwright_firefox"
    PLAYWRIGHT_WEBKIT = "playwright_webkit"

class TLSVersion(Enum):
    """TLS versions"""
    TLS_1_0 = "TLSv1.0"
    TLS_1_1 = "TLSv1.1" 
    TLS_1_2 = "TLSv1.2"
    TLS_1_3 = "TLSv1.3"

@dataclass
class BrowserFingerprint:
    """Browser fingerprinting data"""
    user_agent: str
    viewport_size: tuple
    screen_resolution: tuple
    timezone: str
    language: str
    platform: str
    webgl_vendor: Optional[str] = None
    webgl_renderer: Optional[str] = None
    canvas_fingerprint: Optional[str] = None
    audio_fingerprint: Optional[str] = None
    fonts: Optional[List[str]] = None

@dataclass
class TLSFingerprint:
    """TLS fingerprinting data"""
    version: TLSVersion
    cipher_suites: List[str]
    extensions: List[str]
    compression_methods: List[str]
    signature_algorithms: List[str]
    supported_groups: List[str]

class UndetectedBrowserAdapter:
    """Undetected Browser & TLS Impersonation för penetrationstestning av egna servrar"""
    
    def __init__(self, plugin_info):
        self.plugin_info = plugin_info
        self.initialized = False
        self.active_browsers = {}
        
        # Penetrationstestning disclaimer
        self.authorized_domains = set()
        
        # Browser fingerprints database
        self.browser_fingerprints = {
            BrowserType.CHROME: [],
            BrowserType.FIREFOX: [],
            BrowserType.EDGE: [],
            BrowserType.SAFARI: []
        }
        
        # TLS fingerprints database
        self.tls_fingerprints = []
        
        # Statistik
        self.stats = {
            "total_sessions": 0,
            "successful_bypasses": 0,
            "failed_attempts": 0,
            "by_browser": {},
            "by_target": {},
            "detection_rate": 0.0
        }
        
    async def initialize(self):
        """Initialize Undetected Browser adapter"""
        try:
            logger.info("🕵️ Initializing Undetected Browser Adapter (Authorized Pentest Only)")
            
            # Kontrollera tillgängliga libraries
            available_drivers = []
            
            if SELENIUM_AVAILABLE:
                available_drivers.append("Selenium WebDriver")
                
            if UC_AVAILABLE:
                available_drivers.append("Undetected ChromeDriver")
                
            if PLAYWRIGHT_AVAILABLE:
                available_drivers.append("Playwright")
                
            logger.info(f"📋 Available drivers: {', '.join(available_drivers)}")
            
            # Initiera browser fingerprints
            await self._initialize_browser_fingerprints()
            
            # Initiera TLS fingerprints
            await self._initialize_tls_fingerprints()
            
            # Initiera statistik
            for browser_type in BrowserType:
                self.stats["by_browser"][browser_type.value] = {
                    "sessions": 0,
                    "successes": 0,
                    "failures": 0
                }
                
            self.initialized = True
            logger.info("✅ Undetected Browser Adapter initialized för penetrationstestning")
            logger.warning("⚠️ ENDAST FÖR PENETRATIONSTESTNING AV EGNA SERVRAR")
            
        except Exception as e:
            logger.error(f"❌ Failed to initialize Undetected Browser: {str(e)}")
            self.initialized = True  # Continue with limited functionality
            
    async def _initialize_browser_fingerprints(self):
        """Initiera browser fingerprint database"""
        
        # Chrome fingerprints (vanliga versioner)
        chrome_fingerprints = [
            BrowserFingerprint(
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                viewport_size=(1920, 1080),
                screen_resolution=(1920, 1080),
                timezone="Europe/Stockholm",
                language="sv-SE,sv;q=0.9,en;q=0.8",
                platform="Win32",
                webgl_vendor="Google Inc. (Intel)",
                webgl_renderer="ANGLE (Intel, Intel(R) UHD Graphics Direct3D11 vs_5_0 ps_5_0)",
                fonts=["Arial", "Helvetica", "Times New Roman", "Courier New"]
            ),
            BrowserFingerprint(
                user_agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                viewport_size=(1440, 900),
                screen_resolution=(2560, 1440),
                timezone="Europe/Stockholm",
                language="en-US,en;q=0.9",
                platform="MacIntel",
                webgl_vendor="Google Inc. (Apple)",
                webgl_renderer="ANGLE (Apple, Apple M1 Pro, OpenGL 4.1)",
                fonts=["Arial", "Helvetica", "Times", "Courier"]
            )
        ]
        
        # Firefox fingerprints
        firefox_fingerprints = [
            BrowserFingerprint(
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0",
                viewport_size=(1920, 1080),
                screen_resolution=(1920, 1080),
                timezone="Europe/Stockholm",
                language="sv-SE,sv;q=0.8,en-US;q=0.5,en;q=0.3",
                platform="Win32",
                webgl_vendor="Mozilla",
                webgl_renderer="Mozilla -- ANGLE (Intel, Intel(R) UHD Graphics Direct3D11 vs_5_0 ps_5_0)"
            )
        ]
        
        self.browser_fingerprints[BrowserType.CHROME] = chrome_fingerprints
        self.browser_fingerprints[BrowserType.FIREFOX] = firefox_fingerprints
        
    async def _initialize_tls_fingerprints(self):
        """Initiera TLS fingerprint database"""
        
        # Chrome TLS fingerprint
        chrome_tls = TLSFingerprint(
            version=TLSVersion.TLS_1_3,
            cipher_suites=[
                "TLS_AES_128_GCM_SHA256",
                "TLS_AES_256_GCM_SHA384", 
                "TLS_CHACHA20_POLY1305_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
            ],
            extensions=[
                "server_name",
                "supported_groups",
                "signature_algorithms",
                "key_share",
                "psk_key_exchange_modes"
            ],
            compression_methods=["null"],
            signature_algorithms=[
                "ecdsa_secp256r1_sha256",
                "rsa_pss_rsae_sha256", 
                "rsa_pkcs1_sha256"
            ],
            supported_groups=[
                "x25519",
                "secp256r1",
                "secp384r1"
            ]
        )
        
        self.tls_fingerprints.append(chrome_tls)
        
    def add_authorized_domain(self, domain: str):
        """Lägg till auktoriserad domän för penetrationstestning"""
        self.authorized_domains.add(domain.lower())
        logger.info(f"✅ Added authorized domain för browser testing: {domain}")
        
    def _is_domain_authorized(self, url: str) -> bool:
        """Kontrollera om domän är auktoriserad för testning"""
        domain = urlparse(url).netloc.lower()
        
        if domain in self.authorized_domains:
            return True
            
        for auth_domain in self.authorized_domains:
            if domain.endswith(f".{auth_domain}"):
                return True
                
        return False
        
    async def create_undetected_browser(self, browser_type: BrowserType = BrowserType.UNDETECTED_CHROME,
                                       fingerprint: Optional[BrowserFingerprint] = None,
                                       proxy: Optional[str] = None,
                                       headless: bool = False) -> Optional[str]:
        """Skapa undetected browser session"""
        
        if not self.initialized:
            await self.initialize()
            
        session_id = f"browser_{int(time.time())}_{random.randint(1000, 9999)}"
        
        try:
            self.stats["total_sessions"] += 1
            self.stats["by_browser"][browser_type.value]["sessions"] += 1
            
            # Välj fingerprint
            if not fingerprint:
                fingerprint = self._get_random_fingerprint(browser_type)
                
            # Skapa browser baserat på typ
            if browser_type == BrowserType.UNDETECTED_CHROME and UC_AVAILABLE:
                browser = await self._create_undetected_chrome(fingerprint, proxy, headless)
            elif browser_type.value.startswith("playwright") and PLAYWRIGHT_AVAILABLE:
                browser = await self._create_playwright_browser(browser_type, fingerprint, proxy, headless)
            elif SELENIUM_AVAILABLE:
                browser = await self._create_selenium_browser(browser_type, fingerprint, proxy, headless)
            else:
                logger.error(f"❌ Browser type {browser_type.value} not available")
                return None
                
            if browser:
                self.active_browsers[session_id] = {
                    "browser": browser,
                    "type": browser_type,
                    "fingerprint": fingerprint,
                    "created_at": datetime.now(),
                    "proxy": proxy
                }
                
                logger.info(f"✅ Created undetected browser session: {session_id}")
                return session_id
            else:
                logger.error(f"❌ Failed to create browser session")
                return None
                
        except Exception as e:
            logger.error(f"❌ Error creating browser session: {str(e)}")
            self.stats["by_browser"][browser_type.value]["failures"] += 1
            return None
            
    async def _create_undetected_chrome(self, fingerprint: BrowserFingerprint, 
                                       proxy: Optional[str], headless: bool):
        """Skapa undetected Chrome session"""
        
        options = uc.ChromeOptions()
        
        # Basic undetection options
        options.add_argument("--no-first-run")
        options.add_argument("--no-service-autorun") 
        options.add_argument("--no-default-browser-check")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-gpu")
        options.add_argument("--disable-extensions")
        options.add_argument("--disable-plugins")
        options.add_argument("--disable-images")
        options.add_argument("--disable-javascript")  # Kan justeras beroende på behov
        
        # Fingerprint spoofing
        options.add_argument(f"--user-agent={fingerprint.user_agent}")
        options.add_argument(f"--window-size={fingerprint.viewport_size[0]},{fingerprint.viewport_size[1]}")
        
        # Language and locale
        options.add_argument(f"--lang={fingerprint.language.split(',')[0]}")
        options.add_experimental_option("prefs", {
            "intl.accept_languages": fingerprint.language
        })
        
        # Proxy configuration
        if proxy:
            options.add_argument(f"--proxy-server={proxy}")
            
        if headless:
            options.add_argument("--headless=new")
            
        # Additional stealth options
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # Create driver
        driver = uc.Chrome(options=options, version_main=None)
        
        # Execute script to remove webdriver property
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
        return driver
        
    async def _create_playwright_browser(self, browser_type: BrowserType,
                                        fingerprint: BrowserFingerprint,
                                        proxy: Optional[str], headless: bool):
        """Skapa Playwright browser session"""
        
        playwright = await async_playwright().start()
        
        # Browser type mapping
        if browser_type == BrowserType.PLAYWRIGHT_CHROMIUM:
            browser_launcher = playwright.chromium
        elif browser_type == BrowserType.PLAYWRIGHT_FIREFOX:
            browser_launcher = playwright.firefox
        elif browser_type == BrowserType.PLAYWRIGHT_WEBKIT:
            browser_launcher = playwright.webkit
        else:
            browser_launcher = playwright.chromium
            
        # Launch options
        launch_options = {
            "headless": headless,
            "args": [
                "--no-first-run",
                "--disable-dev-shm-usage",
                "--disable-gpu"
            ]
        }
        
        if proxy:
            launch_options["proxy"] = {"server": proxy}
            
        browser = await browser_launcher.launch(**launch_options)
        
        # Create context with fingerprint
        context = await browser.new_context(
            user_agent=fingerprint.user_agent,
            viewport={"width": fingerprint.viewport_size[0], "height": fingerprint.viewport_size[1]},
            screen={"width": fingerprint.screen_resolution[0], "height": fingerprint.screen_resolution[1]},
            locale=fingerprint.language.split(',')[0],
            timezone_id=fingerprint.timezone
        )
        
        return context
        
    async def _create_selenium_browser(self, browser_type: BrowserType,
                                     fingerprint: BrowserFingerprint,
                                     proxy: Optional[str], headless: bool):
        """Skapa Selenium browser session"""
        
        if browser_type == BrowserType.CHROME:
            options = ChromeOptions()
            options.add_argument(f"--user-agent={fingerprint.user_agent}")
            options.add_argument(f"--window-size={fingerprint.viewport_size[0]},{fingerprint.viewport_size[1]}")
            
            if proxy:
                options.add_argument(f"--proxy-server={proxy}")
                
            if headless:
                options.add_argument("--headless")
                
            # Stealth options
            options.add_experimental_option("excludeSwitches", ["enable-automation"])
            options.add_experimental_option('useAutomationExtension', False)
            
            driver = webdriver.Chrome(options=options)
            
        elif browser_type == BrowserType.FIREFOX:
            options = FirefoxOptions()
            options.set_preference("general.useragent.override", fingerprint.user_agent)
            
            if headless:
                options.add_argument("--headless")
                
            driver = webdriver.Firefox(options=options)
            
        else:
            logger.error(f"❌ Unsupported Selenium browser type: {browser_type}")
            return None
            
        return driver
        
    def _get_random_fingerprint(self, browser_type: BrowserType) -> BrowserFingerprint:
        """Få random fingerprint för browser type"""
        
        fingerprints = self.browser_fingerprints.get(browser_type, [])
        
        if fingerprints:
            return random.choice(fingerprints)
        else:
            # Fallback fingerprint
            return BrowserFingerprint(
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                viewport_size=(1920, 1080),
                screen_resolution=(1920, 1080),
                timezone="Europe/Stockholm",
                language="sv-SE,sv;q=0.9,en;q=0.8",
                platform="Win32"
            )
            
    async def navigate_with_stealth(self, session_id: str, url: str,
                                  wait_for_element: Optional[str] = None,
                                  timeout: int = 30) -> bool:
        """Navigera till URL med stealth (endast auktoriserade domäner)"""
        
        if not self._is_domain_authorized(url):
            logger.error(f"🚫 Domain not authorized för browser testing: {url}")
            return False
            
        if session_id not in self.active_browsers:
            logger.error(f"❌ Browser session not found: {session_id}")
            return False
            
        try:
            session = self.active_browsers[session_id]
            browser = session["browser"]
            browser_type = session["type"]
            
            # Navigate baserat på browser type
            if browser_type == BrowserType.UNDETECTED_CHROME or browser_type in [BrowserType.CHROME, BrowserType.FIREFOX]:
                browser.get(url)
                
                # Vänta på element om specificerat
                if wait_for_element:
                    wait = WebDriverWait(browser, timeout)
                    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, wait_for_element)))
                    
            elif browser_type.value.startswith("playwright"):
                page = await browser.new_page()
                await page.goto(url, timeout=timeout * 1000)
                
                if wait_for_element:
                    await page.wait_for_selector(wait_for_element, timeout=timeout * 1000)
                    
            else:
                logger.error(f"❌ Unsupported browser type för navigation: {browser_type}")
                return False
                
            # Uppdatera statistik
            domain = urlparse(url).netloc
            if domain not in self.stats["by_target"]:
                self.stats["by_target"][domain] = {"visits": 0, "successes": 0}
                
            self.stats["by_target"][domain]["visits"] += 1
            self.stats["by_target"][domain]["successes"] += 1
            self.stats["successful_bypasses"] += 1
            
            logger.info(f"✅ Successfully navigated to: {url}")
            return True
            
        except Exception as e:
            logger.error(f"❌ Navigation failed: {str(e)}")
            
            # Uppdatera failure statistik
            domain = urlparse(url).netloc
            if domain not in self.stats["by_target"]:
                self.stats["by_target"][domain] = {"visits": 0, "successes": 0}
                
            self.stats["by_target"][domain]["visits"] += 1
            self.stats["failed_attempts"] += 1
            
            return False
            
    async def execute_javascript(self, session_id: str, script: str) -> Any:
        """Exekvera JavaScript i browser session"""
        
        if session_id not in self.active_browsers:
            logger.error(f"❌ Browser session not found: {session_id}")
            return None
            
        try:
            session = self.active_browsers[session_id]
            browser = session["browser"]
            browser_type = session["type"]
            
            if browser_type == BrowserType.UNDETECTED_CHROME or browser_type in [BrowserType.CHROME, BrowserType.FIREFOX]:
                result = browser.execute_script(script)
            elif browser_type.value.startswith("playwright"):
                # För Playwright behöver vi en page
                pages = browser.pages
                if pages:
                    result = await pages[0].evaluate(script)
                else:
                    page = await browser.new_page()
                    result = await page.evaluate(script)
            else:
                logger.error(f"❌ JavaScript execution not supported för {browser_type}")
                return None
                
            return result
            
        except Exception as e:
            logger.error(f"❌ JavaScript execution failed: {str(e)}")
            return None
            
    async def take_screenshot(self, session_id: str, filepath: Optional[str] = None) -> Optional[bytes]:
        """Ta screenshot av browser session"""
        
        if session_id not in self.active_browsers:
            logger.error(f"❌ Browser session not found: {session_id}")
            return None
            
        try:
            session = self.active_browsers[session_id]
            browser = session["browser"]
            browser_type = session["type"]
            
            if browser_type == BrowserType.UNDETECTED_CHROME or browser_type in [BrowserType.CHROME, BrowserType.FIREFOX]:
                if filepath:
                    browser.save_screenshot(filepath)
                    with open(filepath, 'rb') as f:
                        return f.read()
                else:
                    return browser.get_screenshot_as_png()
                    
            elif browser_type.value.startswith("playwright"):
                pages = browser.pages
                if pages:
                    screenshot_bytes = await pages[0].screenshot(path=filepath)
                    return screenshot_bytes
                else:
                    page = await browser.new_page()
                    screenshot_bytes = await page.screenshot(path=filepath)
                    return screenshot_bytes
                    
            else:
                logger.error(f"❌ Screenshot not supported för {browser_type}")
                return None
                
        except Exception as e:
            logger.error(f"❌ Screenshot failed: {str(e)}")
            return None
            
    async def close_browser(self, session_id: str):
        """Stäng browser session"""
        
        if session_id not in self.active_browsers:
            logger.warning(f"⚠️ Browser session not found: {session_id}")
            return
            
        try:
            session = self.active_browsers[session_id]
            browser = session["browser"]
            browser_type = session["type"]
            
            if browser_type == BrowserType.UNDETECTED_CHROME or browser_type in [BrowserType.CHROME, BrowserType.FIREFOX]:
                browser.quit()
            elif browser_type.value.startswith("playwright"):
                await browser.close()
                
            del self.active_browsers[session_id]
            logger.info(f"✅ Browser session closed: {session_id}")
            
        except Exception as e:
            logger.error(f"❌ Error closing browser session: {str(e)}")
            
    def get_browser_statistics(self) -> Dict[str, Any]:
        """Hämta browser-statistik"""
        return {
            "total_sessions": self.stats["total_sessions"],
            "active_sessions": len(self.active_browsers),
            "successful_bypasses": self.stats["successful_bypasses"],
            "failed_attempts": self.stats["failed_attempts"],
            "success_rate": (
                self.stats["successful_bypasses"] / max(1, self.stats["total_sessions"])
            ) * 100,
            "by_browser": self.stats["by_browser"],
            "by_target": self.stats["by_target"],
            "authorized_domains": list(self.authorized_domains),
            "available_browsers": [
                browser_type.value for browser_type in BrowserType
                if self._is_browser_available(browser_type)
            ],
            "active_browser_sessions": list(self.active_browsers.keys())
        }
        
    def _is_browser_available(self, browser_type: BrowserType) -> bool:
        """Kontrollera om browser type är tillgänglig"""
        
        if browser_type == BrowserType.UNDETECTED_CHROME:
            return UC_AVAILABLE
        elif browser_type.value.startswith("playwright"):
            return PLAYWRIGHT_AVAILABLE
        elif browser_type in [BrowserType.CHROME, BrowserType.FIREFOX]:
            return SELENIUM_AVAILABLE
        else:
            return False
            
    async def test_detection_bypass(self, test_urls: List[str]) -> Dict[str, Any]:
        """Testa detection bypass på angivna URLs"""
        
        results = {}
        
        for url in test_urls:
            if not self._is_domain_authorized(url):
                results[url] = {
                    "success": False,
                    "error": "Domain not authorized"
                }
                continue
                
            # Testa olika browser types
            for browser_type in [BrowserType.UNDETECTED_CHROME, BrowserType.PLAYWRIGHT_CHROMIUM]:
                if not self._is_browser_available(browser_type):
                    continue
                    
                try:
                    session_id = await self.create_undetected_browser(browser_type)
                    if session_id:
                        success = await self.navigate_with_stealth(session_id, url)
                        await self.close_browser(session_id)
                        
                        results[f"{url}_{browser_type.value}"] = {
                            "success": success,
                            "browser_type": browser_type.value
                        }
                        
                except Exception as e:
                    results[f"{url}_{browser_type.value}"] = {
                        "success": False,
                        "error": str(e),
                        "browser_type": browser_type.value
                    }
                    
        return results
        
    async def cleanup(self):
        """Cleanup Undetected Browser adapter"""
        logger.info("🧹 Cleaning up Undetected Browser Adapter")
        
        # Stäng alla aktiva browser sessions
        for session_id in list(self.active_browsers.keys()):
            await self.close_browser(session_id)
            
        self.authorized_domains.clear()
        self.browser_fingerprints.clear()
        self.tls_fingerprints.clear()
        self.stats.clear()
        self.initialized = False
        logger.info("✅ Undetected Browser Adapter cleanup completed")
